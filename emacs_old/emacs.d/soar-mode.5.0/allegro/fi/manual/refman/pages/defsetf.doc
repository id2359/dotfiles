
                                                                     defsetf


    MACRO
    defsetf  -  define an update function for a generalized-variable

    USAGE
    defsetf access-fn {update-fn [doc-string] | lambda-list (store-variable)
      {declaration | doc-string}* {form}*}

    SIDE EFFECTS
    Defines  an update function for generalized-variable references  of  the
    form (ACCESS-FN ...).

    DESCRIPTION
    Returns the name of the access function ACCESS-FN.  This access function
    must evaluate all of its arguments, so if more control over treatment of
    arguments is desired, use define-setf-method.  There are two ways to use
    defsetf,  either  by supplying the argument UPDATE-FN, or by supplying a
    LAMBDA-LIST, a STORE-VARIABLE (in parentheses), and a body.

    In the simple case, UPDATE-FN must be a function  that  takes  the  same
    arguments as ACCESS-FN, plus one more, the new value that will be stored
    into the location referenced by ACCESS-FN.   Care  must  be  taken  that
    UPDATE-FN returns this last argument.

    In the complex case, the form of the call to defsetf parallels defmacro.
    The  LAMBDA-LIST  describes  the arguments to ACCESS-FN, with &optional,
    &rest, and &key markers being permitted.  The symbols in LAMBDA-LIST may
    be  thought of as being bound to the arguments of ACCESS-FN in the first
    subform of the setf form.  The variable STORE-VARIABLE denotes  the  new
    value that will be returned, and can be thought of as being bound to the
    second subform of setf.  The code generated by the body must modify  the
    value  of  the  generalized-variable  and return the value of the store-
    variable.

    EXAMPLES
    ;;  First define a macro that does what cdr does.
    (defmacro tail (l) `(cdr ,l))

    ;;  If we want to be able to setf the tail of a list, we first
    ;;  must define a setf method.
    (defsetf tail (l) (new-tail)
      `(progn (rplacd ,l ,new-tail) ,new-tail))

    ;;  Now test the new setf method.
    (setf my-lis '(a b c)) => (a b c)
    (tail my-lis)=> (b c)
    (setf (tail my-lis) '(y z)) => (y z)
    ;;  My-lis reflects the changes.
    my-lis => (a y z)

    ;; A similar example for car, except we use the function `set-head',
    ;; rather than a progn.
    (defmacro head (l) `(car ,l))
    (defun set-head (l new-head)
      (rplaca l new-head))
    (defsetf head set-head)
    ;;  Test the example.
    (setf my-lis '(a b c)) => (a b c)
    (head my-lis) =>  a
    (setf (head my-lis) 'z) => (z b c)
    my-lis => (z b c)



    SEE ALSO
    CLtL 7:102, about generalized variables, define-modify-macro, define-
    setf-method, get-setf-method, get-setf-method-multiple-value






























































