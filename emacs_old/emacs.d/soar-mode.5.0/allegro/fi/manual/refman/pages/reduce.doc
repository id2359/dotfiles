
                                                                      reduce


    FUNCTION
    reduce  -  combine elements of a sequence using a binary function

    Usage
    reduce FUNCTION SEQUENCE [:from-end FE] [:start SN] [:end EN]
      [:initial-value IVAL]

    DESCRIPTION
    Returns the result of applying a binary function (such as +) to elements
    of  a  sequence.   Which elements and in what order is determined by the
    values of the keyword arguments.  When no keyword arguments  are  speci-
    fied,  FUNCTION  is applied to the first two elements (passed in order),
    then to the result and the third element, and so on until the end of the
    sequence is reached.  Then the resulting value is returned.

    If the :from-end argument is specified non-nil, FUNCTION is  applied  to
    arguments  starting  at  the end.  But note that the first two arguments
    passed to FUNCTION are passed in the order in which they appear  in  the
    sequence (not in reverse order). Then, successive elements are passed as
    the first argument and the accumulating result as the  second  argument.
    the  following  two pairs of forms indicate the order of evaluation when
    :from-end is not specified and when :from-end is specified to be t.

    (reduce #'- '(1 2 3)) => -4
    (- (- 1 2) 3)) => -4

    (reduce #'- '(1 2 3) :from-end t) => 2
    (- 1 (- 2 3)) => 2

    To reduce only a subsequence of SEQUENCE, specify the  :start  and  :end
    keyword  arguments.   The :start keyword argument indicates the index of
    the first element of the subsequence to reduce.  Its value  defaults  to
    zero  (indicating  the first element).  The :end keyword argument speci-
    fies an index one greater than the index of the last element to  reduce.
    A value of nil is equivalent to the default, the length of the sequence.
    If SEQUENCE is a vector with a fill pointer, only the active elements of
    SEQUENCE can be reduced.

    If a value is specified for the :initial-value keyword argument, it will
    be treated as if it were appended onto the front (the back, if :from-end
    is non-nil) of the subsequence to be reduced.  There it is treated  just
    like other sequence elements.

    There are several boundary cases.  If the subsequence (with the  initial
    value  appended,  if  it is given) has just one element, that element is
    returned (and FUNCTION is not called).  If it  has  no  elements  (i.e.,
    either  SEQUENCE or the designated subsequence has length zero and there
    is no initial value), FUNCTION is  called  with  no  arguments  and  the
    result  is  returned.   (This  is the only case where FUNCTION is called
    with other than exactly two arguments.)

    EXAMPLES
    (reduce #'+ '(2 4 6)) => 12
    (reduce #'list '(a b c d)) => (((a b) c) d)
    (reduce #'- '(2 4 6)) => -8
    (reduce #'- '(2 4 6) :from-end t) => 4
    (reduce #'list '(a b c d) :initial-value 'z)
      => ((((z a) b) c) d)
    (reduce #'+ '(foo)) => foo
    (reduce #'car '() :initial-value 6) => 6
    (reduce #'+ '()) => 0

    SEE ALSO
    CLtL 14:251, :end, :key, :start






















































































































































































































































































































































































































































































































































































































