
                                                                   eval-when


    SPECIAL FORM
    eval-when  -  control evaluation context of forms

    USAGE
    eval-when ({situation}*) {form}*

    DESCRIPTION
    Evaluates each FORM and returns the values of the  last,  provided  that
    one  of  the  SITUATIONS  specified prevails, and returns nil otherwise.
    Each SITUATION may be one of three symbols: compile, load, or eval.  The
    SITUATION  eval  means that evaluation will be done when the interpreter
    processes the FORMS.  The SITUATION compile means that  evaluation  will
    be  done  at compile time in the compiler's execution context.  Finally,
    when the SITUATION load is specified, the compiler will  arrange  it  so
    that  the  FORMS  are  evaluated  when  the  file in which the eval-when
    appears is loaded.

    eval-when forms are usually placed in a LISP source file.  It does  make
    sense to type an eval-when form directly to the top level of LISP.  Note
    that the situation names are somewhat  confusing.   The  eval  situation
    holds when an source (uncompiled) file is loaded.  The compile situation
    is clear enough.  It holds when the file is being  compiled.   The  load
    situation  holds  when  a  compiled file is being loaded, but not when a
    source file is being loaded.

    One of the issues that eval-when deals with  is  whether  certain  forms
    should  be evaluated by the compiler when they are seen by the compiler,
    thus changing the compilation  context.   The  issue  is  clearest  with
    defmacro.   Suppose that you have a macro definition in a file, and then
    many uses of that macro in subsequent source code in the same file.  The
    compiler  will  compile the macro definition AND evaluate it so that the
    definition is available in the  compilation  context.   This  is  almost
    always  what  you want, but you can wrap a defmacro form in an eval-when
    form with the situation compile not specified and  the  definition  will
    not  be  evaluated.   Note  that  if  the defmacro form is wrapped in an
    eval-when without the situation load  but  with  the  situation  compile
    specified,  references  to  the macro in the file are compiled correctly
    but the macro definition is not loaded with the compiled file.  This  is
    useful  when  the  macro is specific to the file being loaded.  Once the
    file is compiled, the definition has no further use and  space  will  be
    saved by not loading it.

    The list of forms which will be evaluated by default when  seen  by  the
    compiler  is  implementation-dependent  (and  the  subject  of some con-
    troversy in the COMMON LISP community).  In all implementations defmacro
    and  probably  in all implementations, the package functions in-package,
    make-package, shadow, shadowing-import, export,  unexport,  use-package,
    unuse-package,  and  import  are evaluated as if wrapped in an eval-when
    form with all three situations specified.

    EXAMPLES
    ;;  Suppose a file foo.cl has the following three forms in it:
    (eval-when (eval) (format t "Compile this file!~%"))
    (eval-when (compile) (format t "Load this file!~%"))
    (eval-when (load) (provide :mod-name))
    ;;  The following will be printed (perhaps along with other
    ;;  implementation-dependent messages generated by LOAD:
    (load "foo.cl") PRINTS Compile this file!
    (compile-file "foo.cl") PRINTS Load this file!
    ;;  And now, after the file is loaded,
    ;;  MOD-NAME will be on the *MODULES* list.


    SEE ALSO
    CLtL 5:69, compile, defun, eval, load































































