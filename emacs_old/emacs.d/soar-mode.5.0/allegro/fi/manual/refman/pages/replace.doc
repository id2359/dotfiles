
                                                                     replace


    FUNCTION
    replace  -  change a sequence by replacing all or part of it with all or
      part of another (destructive)

    Usage
    replace SEQUENCE1 SEQUENCE2 [:start1 SN1] [:end1 EN1] [:start2 SN2]
      [:end2 EN2]

    SIDE EFFECTS
    The argument SEQUENCE1 may be changed.

    DESCRIPTION
    Returns  SEQUENCE1  after  copying  successive  elements  into  it  from
    SEQUENCE2.   (Note  that,  depending  on  the  implementation, SEQUENCE1
    itself may be returned after being modified, SEQUENCE1 may  be  modified
    and another sequence returned, or SEQUENCE1 may be unchanged and another
    sequence returned.)

    This function will only operate on a subsequence  of  SEQUENCE1  if  the
    :start1 and :end1 keyword arguments are specified.  The beginning of the
    subsequence is specified with the :start1 keyword argument.  Its default
    value  is 0, denoting the beginning of the whole sequence.  The value of
    the :end keyword argument specifies the index one larger than the end of
    the subsequence.  A value of nil is equivalent to the default value, the
    length of SEQUENCE1.

    A subsequence of SEQUENCE2 may be  specified  in  the  same  way,  using
    start2 and :end2.

    Thus, there are two subsequences (either or both of  which  may  be  the
    entire  sequence).   If  they  are  the  same length, the subsequence of
    SEQUENCE2 replaces the subsequence of SEQUENCE1.  If they have different
    lengths,  extra  elements at the end of the longer one are ignored (that
    is unchanged if in SEQUENCE1 and unused if in SEQUENCE2).

    There are two special cases.  If the two argument sequences are eq  (and
    the  subsequences  overlap),  replace  works as if a copy is made of the
    subsequence of SEQUENCE2 which is then copied back into  SEQUENCE1.   If
    the  two  sequences  are  not eq but they share memory (perhaps they are
    both displaced into the same array), the result is undefined.

    EXAMPLES
    (setq foo1 '(0 1 2 3)) => (0 1 2 3)
    (setq foo2 '(a b c d)) => (a b c d)
    (setq foo1 (replace foo1 foo2)) => (a b c d)
    foo1 => (a b c d)
    foo2 => (a b c d)
    (setq foo3 '(0 1 2 3)) => (0 1 2 3)
    (replace foo1 foo3 :start1 0 :end1 2 :start2 2 :end2 4)
      => (2 3 c d)

    SEE ALSO
    CLtL 14:252, :end, eq, fill, :start

































































































































































































































































































































































































































































































































































































































