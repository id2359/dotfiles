
                              Soar User's Manual
                                  Version 5.2



                                  JOHN LAIRD

                              CLARE BATES CONGDON

                                 ERIK ALTMANN

                                 KATHY SWEDLOW


                                 OCTOBER 1990



                              Soar User's Manual
                                  Version 5.2



                      JOHN LAIRD AND CLARE BATES CONGDON
            ELECTRICAL ENGINEERING AND COMPUTER SCIENCE DEPARTMENT
                          THE UNIVERSITY OF MICHIGAN

                        ERIK ALTMANN AND KATHY SWEDLOW
                          SCHOOL OF COMPUTER SCIENCE
                          CARNEGIE MELLON UNIVERSITY


    Copyright (C) 1991  J. Laird, C.B. Congdon, E. Altmann, and K. Swedlow.

This  research was sponsored in part by NASA Ames under grant NCC2-517; in part
by the Defense Advanced Research Projects Agency (DOD)  and  monitored  by  the
Avionics  Laboratory,  Air Force Wright Aeronautical Laboratories, Aeronautical
Systems Division (AFSC), Wright-Patterson AFB, Ohio 45433-6543  under  contract
F33615-87-C-1499,  ARPA  Order  No.    4976,  Amendment  20; and in part by the
Natural Sciences and Engineering Research Council of Canada.    The  views  and
conclusions  contained in this document are those of the authors and should not
be interpreted as representing  the  official  policies,  either  expressed  or
implied, of NASA, DARPA, the U.S. Government, or the Government of Canada.
Preface
Soar  is  an  integrated  architecture  for  knowledge-based  problem  solving,
learning, and interaction with external environments.    The  authors  of  this
manual   assume  a  basic  understanding  of  artificial  intelligence,  and/or
information processing psychology, and some specific  knowledge  of  production
systems.

This  manual  is  specific to version 5 of Soar, which incorporates significant
changes from version 4.  It is also specific to release  2  (i.e.,  Soar  5.2).
Future  releases  of  Soar 5 will be accompanied by release notes that describe
changes relative to this manual.  Soar is written in Common Lisp and runs on  a
variety of machines.

The  authors  would  like  to  give special thanks to Paul Rosenbloom and Allen
Newell for their invaluable comments  on  this  and  earlier  versions  of  the
manual.  We would like to thank Brian Milnes, Gary Pelton, David Steier, Milind
Tambe, and Mark Wiesmeyer for their comments and technical advice.    We  would
also  like  to  thank  the  Soar  group  for their patient support.  Soar 5 was
implemented by Karen McMahon.
Mailing Lists
The Soar project supports several INTERNET mailing lists.  They are:

     soar-requests@cs.cmu.edu      For requests for copies of Soar.

     soar-doc@cs.cmu.edu           For  comments  and  suggestions  about  this
                                   manual  or  any  other  piece of Soar system
                                   documentation.  Requests  for  documentation
                                   (including  this manual) should also be sent
                                   to this address.

     soar-bugs@cs.cmu.edu          For reporting Soar bugs.

If you cannot reach us on the INTERNET, please write to  us  at  the  following
address:
        The Soar Group
        School of Computer Science
        Carnegie Mellon University
        Pittsburgh, PA 15213-3890
        USA
1. Introduction
Soar is to be an architecture that can:

   - work  on  the  full  range of tasks expected of an intelligent agent,
     from highly routine to extremely difficult, open-ended problems;

   - represent and use appropriate forms of knowledge such as  procedural,
     declarative, and episodic;

   - employ  the full range of problem solving methods and representations
     required for the tasks;

   - interact with the outside world; and

   - learn about all aspects of the tasks and its performance on them.

In other words, our intention is for  Soar  to  support  all  the  capabilities
required of a general intelligent agent.

The  ultimate in intelligence would be complete rationality which would include
the ability to use all available knowledge  for  every  task  that  the  system
encounters.  Unfortunately, if the body of knowledge is sufficiently large, the
tasks are sufficiently diverse, and the system must respond in  a  sufficiently
limited  amount  of  time, this goal is impossible because of the computational
complexity involved in retrieving the relevant knowledge.  The best that can be
obtained  is  an approximation of complete rationality.  The design of Soar can
be seen as an investigation of one such approximation.   Below  are  the  major
principles  that  are  the  cornerstones  of  Soar's  design and its attempt to
approximate rational behavior.

   1. The number of distinct architectural mechanisms should be minimized.
      In  Soar  there  is  a  single  framework for all tasks and subtasks
      (problem spaces), a single  representation  of  permanent  knowledge
      (productions),   a  single  representation  of  temporary  knowledge
      (objects  with  attributes  and  values),  a  single  mechanism  for
      generating  goals  (automatic  subgoaling),  and  a  single learning
      mechanism (chunking).

   2. All decisions are made through the combination of relevant knowledge
      at  run-time.    In  Soar,  every  decision  is based on the current
      interpretation of sensory data and any relevant knowledge  retrieved
      from  permanent  memory.    Decisions  are never precompiled into an
      uninterruptible sequence.

1.1. Overview
This manual presents Soar at three  levels:  the  Problem  Space  Computational
Model (PSCM), the semantics of Symbol-Level Computational Model (SLCM), and the
syntax of the SLCM.   Chapter  2  describes  the  problem  space  level,  which
defines a computational model for formulating tasks in Soar.  The components of
the PSCM include  goals,  problem  spaces,  states  and  operators(Soar's  name
derives  from  the  basic  cycle  of  taking a State, applying an Operator, And
generating a Result.).  The basic functions of the PSCM include the generation,
refinement, selection, and application of these components.

Chapter  3  describes the semantics of the SLCM, which is a computational model
for implementing the PSCM.    The  components  of  the  SLCM  include  memories
(permanent  and  temporary)  and the processing of the data structures in those
memories.  Chapter 3 provides the semantics of Soar's operation without delving
into syntax.

Chapters  4  through  7  describe the details of the SLCM, including the actual
syntax of Soar.  Chapter 4 describes the syntax of the major components used in
problem  solving,  including productions, working memory elements, preferences,
and subgoals; Chapter 5 describes the  details  of  chunking,  Soar's  learning
mechanism; Chapter 6 describes input and output; and Chapter 7 describes Soar's
default knowledge.

Chapter 8 presents the complete implementation of a simple Blocks  World  task,
providing a tutorial on Soar.

Chapter 9 describes in detail the functions available in Soar's user interface.
A concise overview of the interface is given in the Function Summary and Index,
placed at the end of the manual for ready access.

Appendix  I  is a glossary of Soar terminology.  Appendix II contains templates
for the most common types of Soar productions.   The  Reference  section  is  a
complete  bibliography  of  all Soar-related publications.  This is followed by
the Index.  The last section of the manual is the Function  Summary  and  Index
mentioned above.

1.2. How to read this manual
Those  readers  unfamiliar with Soar should concentrate on the first two levels
presented in Chapters 2 and 3.  Those readers only interested  in  a  reference
manual  for  Soar  can  skip  Chapter  2,  but should read Chapter 3 carefully.
Chapters 4 through 7 present the syntax of Soar, and the  semantic  details  of
chunking,  I/O,  and  the  default  knowledge.    It  may  be  useful  to  skip
occasionally to Chapter 8 to see how a complete implementation fits together.

Cross-references include both the section number and  the  page  on  which  the
section starts.
2. The Problem Space Level

2.1. Overview
All  activity  in  Soar  is formulated as applying operators to states within a
problem space to achieve a goal as shown in Figure  2-1  for  a  simple  Blocks
World  task.    A goal is some desired situation, such as stacking three blocks
ontop of each other in a specific order to form a tower as shown at  the  right
of  Figure  2-1.    States  are  data structures that define possible stages of
progress in the problem, such as different  positions  of  blocks.    Operators
transform  a  state  via some action, such as changing the location of a block,
and are depicted by arrows in the figure.  A problem space is the collection of
states  and  operators  that are available for achieving a goal.  In general, a
problem space is not represented explicitly by enumerating all of  the  states,
which  may  be  infinite,  but  is instead generated through the application of
operators.

Problem solving is the process of moving from a  given  initial  state  in  the
problem  space,  through intermediate states generated by operators, reaching a
desired state, and thereby attaining the goal.  If we view problem solving from
this  perspective, it is a sequential activity, where only a single operator is
selected and applied at each stage.  Various search methods arise through using
knowledge  to  select  appropriate operators and states during problem solving.
Figure 2-1  shows  the  result  of  using  a  look-ahead  search  that  detects
dead-ends.

-------------------------------------------------------------------------------




 Figure 2-1:  Formulation of simple Blocks World task within a problem space.
-------------------------------------------------------------------------------

Consider  the  problem  of  stacking blocks with a robot that has a gripper for
grabbing the blocks and a camera for seeing the blocks, as shown in the left of
Figure  2-2.    A  state  in the problem space would consist mostly of the data
available from the sensors of the robot, such as the locations  of  the  blocks
and  the  gripper  in  an xyz-space, or that the gripper is open. The state may
have additional data built up through simple inferences, such as that  block  A
is  on  top  of  block B, or that the gripper is above block A. The state might
have other data recalled from earlier experiences, such  as  that  block  B  is
slippery and difficult to pick up.  In all, the state may contain data from any
of these sources.    The  right  of  Figure  2-2  includes  a  predicate  logic
description of this state.

-------------------------------------------------------------------------------



       Figure 2-2:  Example Blocks World problem and state description.
-------------------------------------------------------------------------------

The  operators  in  a  problem  space  transform  one  state  to  another.  The
transformation can be made directly by modifying the information in the  state.
For  example,  in  a  problem involving internal computation and reasoning, the
operators may directly modify the state by augmenting the state with the sum of
two  numbers.    The  transformation can also be made indirectly, by performing
actions in the external environment.  If a real robot is being controlled,  the
operators  will  make  changes to the world, which then will be detected by the
sensors, thus changing the state.  In many cases,  a  single  operator  may  do
both,  possibly  by  giving  a  command to move the arm, as well as creating an
internal expectation of the results of the action.

The set of available operators is determined by the actions that the system can
use  to  manipulate  its  environment  and by the system's own knowledge of the
task.  For a task involving a real robot, the operators  might  include  moving
the  gripper  to  a specific location, changing the orientation of the gripper,
opening the gripper, and closing the gripper.  This set of operators  might  be
restricted  by additional knowledge, such as that the current problem should be
solved by not moving more than one block at a time.   The  set  might  also  be
expanded  through  the  creation of complex operators that involve sequences of
relatively primitive operators.   In  controlling  the  robot,  which  requires
commands  for manipulating the gripper directly, the system may perform much of
its problem solving in a problem space consisting of  abstract  operators  that
move  blocks  directly from one position to another.  These operators will then
be implemented in a primitive problem space that  corresponds  to  the  robot's
physical actions.

For  a  task  that involves internal reasoning, such as multiplying two numbers
"in the head", the problem space may have the basic  operators  of  multiplying
two  single  digits  at  a time, as well as additional operators for activities
such as adding, keeping track of the current position in the  problem,  and  so
forth.    The  problem  space might also have a large number of special-purpose
operators that are acquired through experience (such as the squares from  1  to
20),  or  incorporate  special  properties of certain numbers (i.e., the digits
that result from multiplying by 9  always  sum  to  a  multiple  of  9).    The
available operators, and thus the available problem spaces for such a task, are
determined by the knowledge embedded in the system.

When an operator makes a modification  to  the  state,  the  modification  must
endure  even  after  the  operator  is  no  longer current. The modification is
persistent because the purpose  of  applying  an  operator  is  to  change  the
situation.  Usually the change affects only a small part of the state; however,
no matter how big or small the change is, it is a step in  the  problem  space.
Operator applications are the only way to make persistent changes to the state.
Other changes to the state that are  not  dependent  on  the  selection  of  an
operator,  but  are  instead  based  on  the  contents  of the state are called
refinements. Refinements are not persistent; they will be undone  whenever  the
situation  in which they were created changes.  For example, the inference that
one block is to the right of another should not  persist  if  it  is  based  on
specific  coordinates,  and  the  coordinates  change.    Similarly, the set of
operators that are relevant should change as the state changes.

Within a problem space, a problem is solved by starting at some initial  state,
transforming  that  state through the application of operators until a state is
reached that is recognized as being a  desired  state.    It  is  through  this
activity  of  selecting  and applying operators that Soar solves problems.  Our
use of  "problem  solving"  is  meant  to  be  generic,  so  that  it  includes
calculating,   reasoning,   and  similar  activities  that  involve  performing
operations on data.  The exact type of behavior that Soar produces is dependent
on  the  knowledge  encoded  in  it.  For example, if there is little knowledge
about a particular task, there will be extensive search, as different paths are
explored before the goal is achieved.  If the system has extensive knowledge of
a task, the behavior will appear controlled and devoid of search.

While trying to solve a problem in a  problem  space,  the  directly  available
knowledge  may  be  incomplete  or  inconsistent.    This  is  expected  in any
intelligent  system  that  is  working  with  limited  knowledge  in  a   novel
environment.    The system may not know the appropriate problem spaces, initial
states, or operators for the task.  The system may also not know which  of  the
available  objects is appropriate for the current situation, or it may not know
how to perform a complex action.  We call these situations impasses because the
system  is  unable  to make progress in the current problem given its available
knowledge. Figure 2-3 shows an example impasse in  the  Blocks  World  problem,
where  there  are  three  possible  operators,  but  the available knowledge is
insufficient for discriminating between them.

An impasse is an occasion in which to cast the lack of knowledge  itself  as  a
problem to be solved.  In a problem space formulation, this involves creating a
subgoal to resolve the impasse and then selecting an appropriate problem space,
initial  state, and so on, for working on the goal.  The problem space selected
for the subgoal may be the same as used for the goal where the  impasse  arose,
but  it  need  not.    It  should  be  a  problem space that is appropriate for
generating information that will lead to the resolution of the impasse.  If the
impasse  arises  from  the  inability to apply an operator to the current state
because some preconditions of the operator were not satisfied, then the impasse
can  be  resolved by operator subgoaling.   In operator subgoaling the state is
transformed  through  the  application  of  other   operators   so   that   the
preconditions  of the first operator are satisfied.  For an impasse that arises
to apply an operator, possibly because the application itself requires  problem
solving, a completely different problem space may be appropriate.

Within  a  subgoal, the problem solving may also reach an impasse, leading to a
hierarchy of goals, problem spaces, and impasses.   Such  a  hierarchy  is  not
uncommon  in  artificial intelligence (AI); however, they are for the most part
for  applications  of  complex  operators.    More  novel  are  problem   space
hierarchies  for  reasoning  about  control  decisions,  so-called  meta-goals.
Problem spaces with impasses provide a framework in which both types  of  goals
are  treated  uniformly,  so  that  a  meta-goal  is a goal to make a selection
between alternative problem spaces, states, or operators.   The  processing  in
the  goal  involves  search  of a problem space to select the best alternative.
One  hypothesis  made  in  Soar  is  that  impasse-driven  goal  generation  is
sufficient  for  all  goals  and  that  no  other goal generation and selection
mechanisms are required [Laird  84].    Thus,  no  deliberate  goal  generation
mechanism is available in Soar.

A  common approach in AI is to split a single goal into multiple subgoals, with
the expectation that the smaller  goals  will  be  easier  to  solve  than  the
original goal.  As shown in Figure 2-4, a goal can split into multiple subgoals
by having a problem space with operators for  each  subgoal.  The  sequence  of
operators  that  achieve each of the subgoals provides the standard conjunctive
decomposition of a goal.  The problem of  ordering  the  conjunctive  goals  is
exactly  the  problem  of  deciding  which operator to apply first. Disjunctive
decompositions arise when there is more than one operator available for a given
subgoal.    A  hierarchy  of  goals will arise if one of the selected operators
leads to an impasse, and thus another goal that can be further decomposed.

-------------------------------------------------------------------------------



    Figure 2-4:  Blocks  World  goals   decomposed   into   conjunctive
                 subgoals represented in Soar as operators.
-------------------------------------------------------------------------------

When  an  impasse  is  resolved,  it is because some result was produced by the
problem solving in a subgoal.  That result is new knowledge that was previously
not  directly  available  in  the  problem  space where the impasse arose.  The
knowledge had to be recalled or generated in the subgoal through time-consuming
problem  solving.    Producing the result provides an opportunity to learn.  If
the processing of the subgoal can be captured in an efficient form, so that the
results  of  the  subgoal can be produced directly without problem solving, the
impasse and associated problem solving can be avoided in  future.    This  will
speed up problem solving in the future, and possibly capture knowledge that was
only available at the time the original impasse arose.

The top-level goal and problem space are distinguished  because  they  are  not
generated  in  response  to impasses.  The top-level problem space is where the
system interacts with its environment in pursuit of its most basic goals,  such
as  maintaining its energy supply and avoiding damage to itself.  The operators
of this problem space can perform actions in the external environment  and  the
states  in  this  problem space reflect the system's perception of the external


-------------------------------------------------------------------------------



           Figure 2-3:  Example impasse in the Blocks World problem.
-------------------------------------------------------------------------------
environment.  Other operators in this  problem  space  can  be  more  abstract,
requiring  substantial  problem  solving  or at least sustained problem solving
that will naturally be carried out in a  subgoal.    Interaction  can  also  be
carried  out within a subgoal by using the state and operators of the top-level
problem space as part of the problem space in the subgoal.

2.2. The Problem Space Computational Model
The preceding description of goals, problem spaces, states,  and  operators  is
consistent  with  much  of  the  current  work  in AI and cognitive psychology,
although the use of multiple problem spaces and impasse-driven goal  generation
is  unusual.    The commitment in Soar to using problem spaces as the model for
all  symbolic  goal-oriented  computation  is  unique.    The   Problem   Space
Computational  Model  (PSCM)  is based on the primitive acts that are performed
while using problem spaces to achieve a goal.  Choosing the appropriate set  of
primitive acts is essential in defining the architecture.  Below we present the
complete set of functions that can be carried  out  within  the  PSCM.    These
functions  are  grouped  by  the  object  types  (goal,  problem  space, state,
operator) that they affect.



2.2.1. PSCM functions

   1. Goals:

         - Proposing, comparing and selecting a goal.
           Whenever progress cannot be made on the current goal, a subgoal
           can be created, so that the lack  of  progress  can  itself  be
           considered  a problem to be solved.   In Soar, goals arise only
           from  impasses  in  carrying  out  the  other   problem   space
           functions.   Because of the nature of impasses, a goal can have
           only a single subgoal.  A subgoal can itself  have  a  subgoal,
           but there is never any need to compare or select goals.

         - Refining the information available about the current goal.
           A goal arises in the context of  some  other  problem  solving,
           such  as trying to select or apply an operator.  New structures
           that are refinements of the current situation can be  added  to
           the  goal.    The refinements might be combinations of existing
           information or recollections of prior knowledge that relates to
           the cause of the impasse.  For example, if the goal is to apply
           an operator that creates a structure with block  A  on  top  of
           block  B,  it should be possible to add information that A does
           not have another block on top of it  (i.e.,  that  block  A  is
           clear).

         - Terminating a goal.
           The system must recognize when a problem space's current  state
           achieves  the current goal.  In Soar, goals are created because
           of impasses in performing PSCM functions.  When these  impasses
           are  resolved,  the  subgoal  will be automatically terminated.
           Therefore, goals based on different types of impasses  will  be
           terminated  in  different  ways.    For  example, if an impasse
           arises because an operator  cannot  be  directly  applied,  the
           goal's   termination   will   correspond   to   the  successful
           application of the operator.   If  an  impasse  arises  because
           there is insufficient knowledge to distinguish between a set of
           operators,  the  goal's  termination  will  correspond  to  the
           selection   of  an  operator.    Therefore,  a  test  for  goal
           achievement or failure is not an independent PSCM function, but
           instead  is embodied in the PSCM function that gave rise to the
           subgoal.

   2. Problem Spaces:

         - Proposing, comparing, and selecting a  problem  space  for  the
           goal.
           Many different problem spaces may be appropriate  for  a  given
           goal.    Knowledge  can  be  used  to propose different problem
           spaces, compare them, and select the one most  appropriate  for
           the  current goal.  If a problem space is selected and found to
           be inadequate, it must be possible to  select  another  problem
           space.    Only a single problem space may be used for a goal at
           one time.

         - Refining the information available about  the  current  problem
           space.
           Once a problem  space  is  proposed  or  selected,  it  may  be
           specialized to the current goal.  A problem space may also have
           refinements  that  are  explicit  descriptions   of   important
           invariants  that hold in the states or operators of the problem
           space.  For example, a general problem space  for  manipulating
           blocks  may  be specialized if all blocks are cubes of the same
           size.  Once  it  is  specialized,  the  problem  space  may  be
           augmented  with additional information, such as that it doesn't
           matter which way a block is oriented when it is stacked.

   3. States:

         - Proposing, comparing and selecting an initial state.
           The  initial  state of a problem is the starting situation from
           which progress will begin.  It will usually  be  based  on  the
           sensory  information  available from the environment, the local
           problem solving context  (the  goal  and  problem  space),  and
           permanent knowledge relevant in the context.  Different initial
           states are possible depending on what knowledge is relevant  to
           the   problem,  as  well  as  which  representations  are  most
           appropriate for the states.  Only a single initial state can be
           selected.

         - Refining the information available about the current state.
           Once a state is selected, additional  knowledge  may  exist  to
           augment  its  description  with  the refinements of the current
           situation.  For  example,  if  the   current   state   contains
           information  that  block  A  is  of  height 2 and block B is of
           height 4, the state could  be  augmented  with  knowledge  that
           block B is twice the height of block A.

   4. Operators:

         - Proposing, comparing and selecting an operator.
           One of the most  important  decisions  in  problem  solving  is
           selecting   which  operator  to  apply  next.    This  includes
           proposing  the  available  operators,   comparing   them,   and
           selecting the best one, given the available knowledge.  As part
           of proposing an operator, it may be  necessary  to  instantiate
           the  operator  with  data  from  the  current  state.  A single
           operator can be instantiated with different components  of  the
           state,  leading to the proposal of multiple specific operators.
           For example,  a  generic  operator  to  move  a  block  may  be
           instantiated  with  each  block  in the environment, leading to
           many different specific operators from which to choose.  Only a
           single  operator  can  be  selected  at  any  time.  As will be
           explained later, this does not constrain Soar to carry out  one
           external  action  at  a  time, as a single operator can involve
           many actions.

         - Refining the information available about the current operator.
           Once   an  operator  has  been  selected,  it  may  be  further
           instantiated with specific information from  the  state.    For
           example,  once  an  operator  is  selected to move a block, the
           operator might be augmented with a description of  the  block's
           exact location and destination.  This information may have been
           unnecessary for determining which operator to select.

         - Applying an operator to a state.
           Once  an  operator  has been selected for the current state, it
           can be applied to generate a new state.  The operator can apply
           by  making  direct  changes  to  the  state, or it can apply by
           adding motor commands to the  state  that  indirectly  lead  to
           changes  in  perception.  Direct changes are made by persistent
           modifications to the current state.

           One component of applying an operator  is  detecting  that  the
           operator  is  terminated.    In  most  cases, detecting that an
           operator is finished is independent of  how  the  operator  was
           actually  applied.    For  an  operator  that  changes  only an
           internal state, termination can be  signaled  as  soon  as  the
           change is made.  However, if the operator involves changes that
           are problematic, a separate test  may  be  required  to  signal
           termination.    For example, if a robot has an operator to pick
           up blocks, that  operator  would  terminate  only  through  the
           testing of feedback from the environment.

Missing  from  these  descriptions of the PSCM are functions for input, output,
and learning.  In this formulation, input occurs asynchronously in the  current
state  of  the problem space for interacting with the external environment.  No
PSCM function is required, it just happens.  Output occurs as part of  operator
application  in the current state of the problem space for interacting with the
external environment.  In this formulation, learning is not  a  PSCM  function,
but instead a property of the underlying symbol-level architecture.



2.2.2. Implementing PSCM functions: Architecture or knowledge?
In  creating a system to support the PSCM functions described above, there is a
choice  as  to  whether  a  specific  function  is   implemented   within   the
architecture, and thus fixed for all tasks, or is implemented by task-dependent
knowledge.  In Soar, goal proposal, comparison, selection, and termination  are
all  performed by the architecture and not subject to task-dependent knowledge.
In addition,  the  selection  of  problem  spaces,  states,  and  operators  is
performed  by  a  fixed  decision  procedure  based on knowledge retrieved from
permanent memory.  Even though these functions are fixed in  the  architecture,
they  are still affected by task-dependent knowledge: goals are only created if
the task knowledge leads to  an  impasse,  and  all  selections  are  based  on
knowledge about the various alternatives.  However, the method for carrying out
these functions is not subject to modification.

Task-dependent knowledge can either be input to PSCM  functions  fixed  in  the
architecture,  such  as selection, or can implement PSCM functions directly, as
with proposing and comparing objects and applying operators.   This  functional
split  provides  a basis for classifying how knowledge can be used in Soar.  In
this classification, refinement does not appear as a separate function, but  is
grouped  with  the  functions  that  make  use  of the refining knowledge.  Our
classification has two types: task-implementation knowledge and  search-control
knowledge.

   1. Task-implementation  knowledge  is the knowledge required to perform
      the task.  It includes the knowledge to propose the  problem  space,
      initial  state,  and  operator; knowledge to apply the operator, and
      knowledge to detect the goal.

   2. Search-control knowledge guides the  selection  of  problem  spaces,
      states,  and  operators through comparing proposed alternatives.  It
      contributes to solving the problem by improving  the  efficiency  of
      the  problem  solving.    If  search-control knowledge is missing or
      incorrect, the goal  can  still  be  achieved,  although  additional
      search  may  be  required.  Therefore, search-control knowledge does
      not affect the correctness of problem solving, since the  goal  test
      together  with  the definition of the problem space should determine
      whether the solution is valid.  However, search control does  affect
      the  efficiency  of  the  search  through  the  problem  space.   In
      contrast, if  task-implementation  or  goal-detection  knowledge  is
      missing  or  incorrect,  the  system  may not be able to perform the
      task.

2.3. Encoding a task
A specific task can be encoded in the PSCM by creating an operator in an active
problem  space  to  perform  the  task.  This requires knowledge to propose the
operator as well as knowledge to detect when the operator, and thus  the  task,
is complete.  Once the task operator is selected, an impasse will invariably be
generated and a goal will be selected to apply the operator, the operator  will
be applied, and the task will be completed.

Once  a  goal  has  been  created,  at the very minimum, the system must have a
complete set of task implementation knowledge. This knowledge may  be  directly
available,  or  it  may  be accessible only through problem solving in subgoals
(with associated task-implementation knowledge).  The minimal set will  include
knowledge that performs the following PSCM functions:

   1. knowledge to propose the operator to perform the task;

   2. knowledge  to  terminate  the operator when it has been successfully
      completed;

   3. knowledge to propose a problem space for the task;

   4. knowledge to propose a initial state for the task;

   5. knowledge to propose an operator to transform a state in the problem
      space; and

   6. knowledge  of  how  to  apply  an operator to transform one state to
      another in the problem space.

Additional search-control knowledge might include:

   1. knowledge to compare problem spaces;

   2. knowledge to compare operators; and

   3. task-implementation and search-control knowledge for  subgoals  that
      arise for selection.



2.3.1. An example task: The Blocks World
The  task we will use is from a Blocks World where the blocks actually exist in
an external environment.  In this task, there is  a  table  and  three  blocks,
labeled  A,  B,  and  C; each block is the same size.  A block is either on the
table or centered on top of another block.  Figure 2-5 shows  two  examples  of
legal configurations of blocks. (The exact locations of the blocks on the table
are irrelevant.) The task is to move the blocks,  one  at  a  time,  from  some
initial  configuration  to  some desired configuration (such as shown in Figure
2-5) where the blocks on the table must be in a tower with block A  on  top  of
block  B,  which is on top of block C, which is on the table. The blocks can be
moved one at a time from the table to the top of a clear block, from on top  of
a  block to the table, or from on top of a block to a clear block.  We will use
the initial configuration where block A is on block B, and blocks B and  C  are
on the table.

-------------------------------------------------------------------------------



                  Figure 2-5:  Example Blocks World problem.
-------------------------------------------------------------------------------



2.3.2. Blocks World knowledge
Below is the task implementation knowledge for the Blocks World.  Each piece of
task knowledge is labeled with TK# for later reference.

   1. Knowledge to propose the operator to perform the task.

      TK1: For the top problem space, we need to propose  an  operator  to
      perform  a specific task such as taking the current configuration of
      blocks on the table and achieving a desired state that has  a  tower
      with  block A on top of block B and B on top of C. We will call that
      operator build-tower.

      TK2: The operator for performing the task can be terminated when the
      current  state matches the desired state of the operator (the blocks
      are correctly stacked).

   2. Knowledge to propose the initial problem space.

      TK3: The problem space delimits the operators that should be used at
      the  current  stage of working on the task. For the Blocks World, we
      need only a single problem space: blocks-world.

   3. Knowledge to propose the initial state.

      TK4: The states are configurations of blocks on the table.  Inasmuch
      as  the  task  is  to be implemented by actually moving blocks in an
      external environment, the initial state will contain the objects  of
      the  current  state  of the top-level goal.  That state contains the
      system's  perception  of  the  external  environment  including  the
      configuration of blocks.

   4. Knowledge to propose an operator to transform a state.

      TK5:  In  the  Blocks  World,  there is only one legal operator: the
      operator that moves a block from some location to the top of a block
      or to the table. This operator, move-block, is instantiated once for
      each clear block that can be moved and each location to which it can
      be moved.

      In  this example, only operators that can apply to the current state
      are proposed.   There  is  no  restriction  in  Soar  that  prevents
      creating  other operators.  For example, to use means-ends analysis,
      it is useful to generate  operators  based  on  the  goal,  such  as
      operators to move block B on top of block C.

   5. Knowledge of how to apply an operator to transform a state.

      TK6:  The operator that moves a block changes two characteristics of
      the state. The block that was moved is  no  longer  on  top  of  the
      object  that was supporting it (namely, another block or the table),
      and it is  now  on  top  of  either  another  block  or  the  table.
      Refinement  may  create new knowledge of the transformed state, such
      as the inference that the block from which  a  block  was  moved  is
      clear.

Below  are  four  possible search control heuristics for selecting operators in
the Blocks World.

   1. SK1: Prefer an operator that moves a block into its desired position
      over  an  operator  that  does  not  move  a  block into its desired
      position.

   2. SK2: If there are two operators that move blocks into their  desired
      position  in  the same tower, prefer the operator whose block in the
      desired state is lower in the tower.

   3. SK3: Avoid moving a block on top of another block if that is not its
      desired location.

   4. SK4:  If there are two operators that move blocks into their desired
      position in different towers, select between them indifferently.



2.3.3. PSCM trace of Blocks World
Below is a trace of the PSCM level behavior of the system using  the  knowledge
presented  above.   Each numbered item in the trace below represents a decision
so that the PSCM-level trace can be  compared  with  the  SLCM-level  trace  in
Section  3.10  on  page  43.   Notice that except for operator application, the
general operation of the system is to propose objects, compare  them  and  then
select the best object.


0   The initial goal is generated and selected.

1   The initial problem space, top-ps, is proposed and selected.

2   The initial state is proposed and selected.

    TK1 proposes the build-tower operator that performs the Blocks World task.

3   build-tower is selected as the operator to apply.

4   A subgoal arises because build-tower cannot be performed directly, but must
    be achieved by operators in another problem space.

    TK3 proposes the blocks-world problem space for the new subgoal.

5   blocks-world is selected as the problem space for the subgoal.

    TK4 proposes the initial state, which is the state of  the  original  goal.
    We  will  assume  that block A is on block B, and blocks B and C are on the
    table.

6   The initial state is selected for the subgoal.

    TK5 proposes all of the legal instantiations  of  the  move-block  operator
    (the  first  argument  is  the  block  to  be  moved  to  a  new location):
    move-block(A,C), move-block(C,A), move-block(A,Table).

    SK3 avoids using either move-block(A,C) or move-block(C,A), because neither
    of these moves a block on top of its desired block.

7   move-block(A,Table) is selected as the operator for the subgoal.

    TK6 applies the operator by modifying the state.

    TK5  proposes  all  of  the  new  legal  instantiations  of  the move-block
    operator:      move-block(A,C),      move-block(C,A),      move-block(A,B),
    move-block(B,A), move-block(C,B), and move-block(B,C).

    SK1   prefers   move-block(A,B)   over   move-block(B,A),  move-block(C,B),
    move-block(A,C), and move-block(C,A).

    SK1  prefers   move-block(B,C)   over   move-block(B,A),   move-block(C,B),
    move-block(A,C), and move-block(C,A).

    SK2 prefers move-block(B,C) over move-block(A,B).

    SK3   avoids   using   move-block(A,C),  move-block(C,A),  move-block(C,B),
    move-block(B,A).

8   move-block(B,C) is selected as the operator for the subgoal.

    TK6 applies the operator by modifying the state.

    TK5 proposes  all  of  the  new  legal  instantiations  of  the  move-block
    operator: move-block(A,B), move-block(B,A), move-block(B,Table)

    SK1 prefers move-block(A,B) over move-block(B,A) and move-block(B,table).

    SK3 avoids move-block(B,A).

9   move-block(A,B) is selected as the operator for the subgoal.

    TK6 applies the operator by modifying the state.

    TK2 detects that the build-tower operator is completed.


In  this  example,  there  was sufficient knowledge to perform each of the PSCM
functions in the subgoal so that no additional impasses arose.  If any  of  the
knowledge  used in the subgoal had been missing, a subgoal would have been used
to provide the missing knowledge.  For example,  if  there  had  not  been  any
search  control  knowledge  for  selecting  the  operator (SK1 and SK2 had been
missing), a subgoal would have been generated to select  between  the  proposed
instantiations  of move-block.  One strategy that might be useful is to perform
a lookahead search to determine which of these operators will lead  toward  the
goal.
3. Semantics of the Symbol Level

3.1. Overview
The  PSCM  level  of  description  for  Soar is not directly implementable on a
computer.  It is defined solely by the functions to be performed in support  of
search  in  a problem space to achieve a goal.  To define Soar, we must go to a
lower level that specifies how symbol structures are stored and processed.  The
purpose  of  this lower level is to flexibly support the PSCM.  In this chapter
we give an abstract characterization of the  Symbol-Level  Computational  Model
(SLCM)  of  Soar.  This abstracts away from the specific syntax used in Soar as
well as many of the  implementation  details,  which  are  presented  in  later
chapters.  This  chapter ends by returning to the PSCM functions defined in the
previous chapters and demonstrating how the abstract SLCM supports  them  using
the Blocks World problem presented earlier.

Seven  design  decisions  have  been  made  in  Soar's  SLCM, all of which have
significant implications for realizing the PSCM functions in a flexible manner.

   1. Knowledge is stored  in  a  permanent  recognitional  memory  and  a
      temporary  working  memory.    Knowledge  can  be added to permanent
      memory, but it can not be changed or removed.   Permanent  knowledge
      may be relevant to many different situations, but is not necessarily
      relevant to the current goals  being  attempted.    The  memory  for
      permanent  knowledge  is  recognitional in that it continually tests
      the working memory.  Whenever permanent knowledge  is  found  to  be
      relevant  to  the contents of working memory, it proposes changes to
      working memory.

      In contrast to permanent memory,  the  contents  of  working  memory
      persist only as long as they are relevant to the current goals.  The
      contents of working memory  act  as  retrieval  cues  for  permanent
      memory  and are the basis of all decisions made by the architecture.

   2. That permanent  memory  only  proposes  changes  to  working  memory
      through  preferences,  and  does  not actually deliver such changes.
      These preferences are held  in  preference  memory  and  changes  to
      working  memory  are made based on a synthesis of the preferences in
      preference memory.

   3. All goals, problem spaces,  states,  and  operators  are  explicitly
      represented  by  symbols  in  working  memory  once  they  have been
      proposed.  This does not mean that the complete description of these
      objects  is  available, only that they are symbolized.  For example,
      an operator's preconditions and  actions  may  never  be  explicitly
      represented;   rather,  only  a  symbol  may  represent  a  proposed
      operator.

   4. For each goal, there is at most  a  single  current  problem  space,
      state, and operator.  This eliminates parallelism at the PSCM level.

   5. For each goal, there is only one state available in working  memory.
      This  is the single state principle and distinguishes Soar version 5
      from its predecessors.

   6. The selections of the current problem space, state and operators are
      explicitly  represented by a goal context in working memory.  A goal
      context consists of a goal, together with the current problem space,
      state,  and  operator.      The  explicit representation of the goal
      context makes the current selections  available  as  retrieval  cues
      from memory.

   7. There  is  no  a  priori  control scheme that restricts the order in
      which PSCM functions  are  performed.  For  example,  it  should  be
      possible  to  change  the problem space in the middle of applying an
      operator, if new data suggests the current problem space  should  be
      terminated and a new one selected.

These  assumptions  lead  to  an  SLCM  where  the PSCM functions for selecting
problem spaces, states, and operator are implemented by deciding on the current
values  for  the  goal  context.    These  decisions are based on the knowledge
retrieved from  permanent  memory  using  the  PSCM  functions  for  proposing,
comparing, and adding refinements to the problem spaces, states, and operators.
Operator application is performed by modifying the representation of the  state
in  working  memory,  while  all  PSCM  functions  for  manipulating  goals are
performed directly by the architecture.
The  PSCM  functions  can  be  partitioned  into  the  following   symbol-level
operations:
    PSCM Functions                        Supporting SLCM operation

    Proposing, selecting, and terminating goals

    Proposing, comparing, and refining objects
                                          permanent memory

    Selecting objects                     Decisions for the values of a goal co

    Operator application                  Modifications to the state


To  realize  the PSCM functions, the Soar architecture must support a permanent
memory with recognitional capabilities, a scheme for deciding on the values  of
the  goal  context,  a  process  for  modifying  states,  and  a  mechanism for
processing goals. Sections 3.2, 3.3, and 3.4 describe Soar's memory  structures
(working memory, permanent recognition memory, and preference memory).  Section
3.5 describes how preferences  are  processed  to  determine  the  contents  of
working  memory.    This  preference-processing scheme supports the creation of
working memory elements, the selection of problem spaces, states and  operator,
and  the  application  of  operators.  Section 3.6 presents impasses, which are
responsible for goal processing.  Section 3.7 gives an  overview  of  learning,
and  Section 3.8 describes input and output.  Section 3.9 describes the default
knowledge that rests on top of the SLCM.  This knowledge is available  for  all
tasks,  and  acts  as  a default response to the impasses that can arise during
problem solving.  The final section illustrates how the Blocks  World  task  is
encoded  in  the  SLCM,  emphasizing how the abstract SLCM supports each of the
PSCM functions.

Figure 3-1 shows the abstract structure of the memory and processing components
and  how  they  interact.  The rectangles are memories, while the triangles are
processes that take as their input the memories to  which  they  are  attached.
Starting  from  the  top-left,  the  preference  memory receives input from the
external environment through perception modules.  Preference  memory  does  not
directly  cue  the  retrieval  of  data from recognitional memory, but is first
processed by the decision procedure, which computes changes to  working  memory
based on the contents of preference memory.

Recognition  memory  contains  the  permanent  knowledge  that  is  encoded  as
productions. Productions are simple ``if-then'' rules whose conditions test the
contents  of  working memory and whose actions create preferences.  Productions
in recognition memory are matched against working memory and if successful, add
preferences  to  preference  memory.  All productions, except those involved in
operator  creation,  instantiation,  and   application,   also   remove   their
preferences from working memory when they no longer match.

Preferences  that  propose  new  context  objects  (problem spaces, states, and
operators) are also added to working memory so that they can serve as retrieval
cues for additional preferences that will determine which object is selected to
be current.

The main flow of information is shown by the dark arrows where  match  computes
changes  to  preference memory and decision computes changes to working memory,
which in turn leads to changes in match.

The working memory is also processed by action, which sends motor  commands  to
the system's effectors.  As productions are matched and fired, the instantiated
production traces are sent to trace memory which is then processed by chunking.
The  output  of  chunking  is  new  productions  which are added to recognition
memory.

-------------------------------------------------------------------------------



          Figure 3-1:  The structure of the SLCM components of Soar.
-------------------------------------------------------------------------------

3.2. Working memory
Working memory contains the data representing Soar's current progress on all of
its  goals.   It contains the current goals, problem spaces, states, operators,
and their substructure.

The data in working memory is organized into entities  called  objects.      An
object  consists  of  a symbol, called its identifier, and augmentations, which
are attribute-value pairs.  Augmentations are  the  primitive  representational
unit  out  of  which  all other representations are built and will sometimes be
referred to as working memory elements.

An identifier is a unique symbol that is created when the object is first added
to  working  memory.    A constant is any atom that is not the identifier of an
object. In semantic net terms, an identifier is a node and an  attribute  is  a
link  to  a value. If a value is a constant, then it is a terminal node with no
links.

-------------------------------------------------------------------------------



    Figure 3-2:  Graphical depiction of the contents of working memory.
                 Circles    represent   identifiers,   arcs   represent
                 attributes, and squares represent constants.
-------------------------------------------------------------------------------

An  augmentation  contains  the  identifier  of  the  object  it  augments,  an
attribute,  and  a  value.    Attributes  and values can be either constants or
identifier of other objects.  An object can have  multiple  augmentations  with
the  same attribute and different values, creating a simple set representation.
However, working memory itself is a set, so there cannot be  two  augmentations
with the same identifier, attribute, and value.

There is no predefined relationship between objects in working memory and "real
objects" in the outside world.  Objects in working memory  may  refer  to  real
objects,  such  as  BLOCK  A;  a feature of an object, such as the color RED; a
relation between objects, such as ONTOP; classes of objects,  such  as  BLOCKS;
etc.

Working  memory supports the PSCM selection functions by maintaining a stack of
goal contexts,called the context stack.    Each  goal  context  is  represented
simply  by augmentations of a goal object for the current problem space, state,
and operator. These three augmentations are called context slots and the values
of  the context slots are called context objects. A goal can have any number of
augmentations, but the problem space, state,  and  operator  augmentations  are
determined slightly differently than other augmentations in working memory.

Figure  3-2  provides  a graphical depiction of a context for the Blocks World.
The circles denote identifiers, the arrows denote  attributes,  and  the  boxes
denote  constant  values.    The  goal  is  the  left-most  circle,  and it has
augmentations for the three context slots: problem-space, state, and  operator.
The   values   of  each  of  these  slots  is  an  identifier  with  additional
augmentations.    For   example,   the   operator   has   three   augmentations
(moving-block, destination, and name), two of which have values that are shared
by augmentations of the state.

An augmentation is directional and provides an access link from the  identifier
to  the  value.    The  objects that are linked to an identifier are called its
substructure. Thus, the state in Figure 3-2 is linked  to  the  goal,  and  the
block  with  name A and color Red is linked to both the state and the operator,
and is thus linked indirectly to the goal.  All  data  in  working  memory  are
linked directly or indirectly to the context stack.

3.3. Recognition memory
The  recognition memory contains productions, simple if-then rules that consist
of conditions (the if part of the rule) and  actions  (the  then  part  of  the
rule).    The  conditions of productions are continually matched against all of
the contents of working memory.  Conditions can contain variables,  so  that  a
single  condition  can  match  against  different data in working memory.   The
action of a production is to create preferences for changes to working  memory.
Thus, a production does not change working memory directly, but instead creates
preferences that are later combined by a decision procedure  to  determine  the
contents of working memory.

If  all of the conditions of a production are matched with consistent bindings,
the production is said to be instantiated with the working memory elements that
matched  the  conditions.    The preferences in the actions of the instantiated
productions are  then  added  to  preference  memory.    In  contrast  to  most
production  systems,  Soar  fires  all  matched  production  instantiations  in
parallel, without any conflict resolution.  This parallel firing of productions
is called an elaboration cycle. Parallel firing is possible because the actions
of  the  productions  create  preferences  without  modifying  working   memory
directly.    Therefore  there are no race conditions or inconsistencies between
actions.    Inconsistencies  will  show  up  during  the  processing   of   the
preferences, where they can be handled explicitly.

Just  as  the elements of working memory must be linked, so must a production's
conditions.  That is, all conditions must either test a goal  augmentation,  or
they  must  test  an  augmentation  that is linked through the variable for the
identifier to another augmentation that is a goal augmentation or is linked  to
a goal augmentation.

3.4. Preference memory
The contents of working memory are determined by preferences for augmentations.
Preferences are  retrieved  by  matching  recognition  memory  against  working
memory.   Preferences are statements about the relative or absolute worth of an
augmentation's specific value in working memory. In order for  an  augmentation
to be added to working memory it must have an acceptable or require preference.
The acceptable preference states that the object is a candidate for  the  value
and  will  be  considered  in the decision, while the require preference states
that the object must be selected if the goal is to be achieved.  If there is an
acceptable  preference  for  a value of an augmentation, and there are no other
competing  values,  a  working  memory  element  will  be  created   for   that
augmentation.

If  there  are  acceptable  preferences  for  alternative  values  for the same
identifier and attribute, the contents of working memory will be determined  by
preferences  that  allow for comparisons of values.  For example, one value can
be better than another, and a third can be best.
Soar's preferences fall into five categories:

    Category        Preferences and description

    feasibility     acceptable, reject
                    Feasibility preferences determine the  candidates  for  the
                    value of an augmentation.

    exclusivity     parallel
                    Exclusivity  preferences  determine  if more than one value
                    for an attribute is allowed.

    desirability    best, better, indifferent, worse, worst
                    Desirability preferences compare and  rank  the  candidates
                    for a value of an augmentation.

    necessity       require, prohibit
                    Necessity preferences determine if a selection must or must
                    not be made in order to achieve the goal.

    termination     reconsider
                    Termination preferences signal that the current object  can
                    be  displaced  and a new decision can be made for the value
                    of the augmentation.  This preference is only relevant  for
                    context slots.

The  details  of  the preference semantics are described in Section 3.4 on page
28.

-------------------------------------------------------------------------------



    Figure 3-3:  An abstract depiction of computing values for the same
                 slot.    Values  A,  B,  and  C  all  have  acceptable
                 preferences, denoted by "+".   A  is  better  than  B,
                 denoted by "A > B".  C is best, denoted by "C >".
-------------------------------------------------------------------------------

Preferences  are  held in a separate preference memory that cannot be used as a
cue for the productions in recognition memory.    The  one  exception  is  that
acceptable  preferences  for  context  slot  objects  are  available in working
memory.  This is necessary because the preference  scheme  is  used  to  select
problem  spaces,  states,  and operators.  By making the acceptable preferences
for these objects available in working memory, the candidates can  be  compared
before they are selected.  Thus, deliberative selection, where alternatives can
be examined before selected, is possible for PSCM objects.

Just as all working memory elements must be linked to the goal context, so must
the  preferences.   If the linkage is ever broken, so that an identifier is not
the value of another acceptable preference (or require preference)  or  working
memory element, then all preferences containing that identifier will be removed
from the preference memory.  The removal of these preferences can then lead  to
changes in the contents of working memory.

The retrieval of preferences from production memory supports the PSCM functions
for proposing, comparing, and refining problem spaces, states,  and  operators,
as  well  as  the termination of an operator application. Problem space, state,
and operator proposals are performed by the creation of acceptable  preferences
for  the  appropriate  context  slot.   Similarly, comparisons are performed by
creating desirability preferences for potential context objects.  Refinement is
done  by  creating  preferences  for  new  augmentations  of  context  objects.
Termination occurs  when  a  reconsider  preference  is  available  during  the
decision for a context slot.

Once  a  preference  has  been  retrieved by firing a production, it should not
remain available indefinitely.  A preference must be removed whenever it is  no
longer  relevant  to  the  current  situation.  As the problem solving unfolds,
states will change through operator application.  The top state will change  as
the  sensors  detect  changes  in  the environment over which the system has no
control.  For example, if a production creates an acceptable preference for  an
operator  to  pick up a block based on augmentations of the current state, that
operator will not be appropriate if the block is  later  covered  by  a  second
block, either by the system or by an outside agent.

Preferences  for  the  PSCM  functions  mentioned  above are held in preference
memory as long as the production  instantiation  that  created  them  is  still
valid,   unless   the  augmentation  is  explicitly  rejected  during  operator
application (see below).    The  maintenance  of  such  preferences  is  called
instantiation  support or just I-support.   A preference can have more than one
source of I-support if more than one active production  instantiation  has  the
preference  as  its action.  A preference loses I-support from an instantiation
if the instantiation no longer  matches  working  memory,  either  through  the
removal  of  a  working  memory element matched by a positive condition, or the
addition of a working memory element that matches a negated condition.

If a preference loses all I-support (and does not have other support as defined
below),  Soar  retracts  the  preference.    Retraction  simply  means that the
preference is removed from preference memory and is  no  longer  considered  in
determining  the  contents  of  working  memory.    Just  as  the  addition  of
preferences can change working memory,  so  can  retraction,  because  removing
preferences can change decisions.  Through instantiation and retraction, Soar's
production memory implements a justification-based Truth-Maintenance System.

Operator application differs from other PSCM functions in that the changes made
to  working  memory  should  persist,  even after the conditions for making the
changes are no longer satisfied.  For example, in placing a block on another, a
condition  is  that  the second block be clear.  However, the action of placing
the first block removes the fact  that  the  second  block  is  clear,  so  the
condition  will  no longer be satisfied.  Such operator application productions
do not retract their actions, even if they  no  longer  match  working  memory.
Preferences  that  participate  in  the application of operators are maintained
throughout the existence of the goal in which the operator is applied.  This is
called operator support or just O-support.   If a preference receives O-support
from a production instantiation, it does not also have I-support from the  same
instantiation  (although  it  could  receive  I-support from another production
instantiation).

The determination of whether or  not  a  preference  is  part  of  an  operator
application,  and  thus  should receive O-support, is based on the structure of
the  production  instantiation  that  created  the  preference.    An  operator
application  involves  testing the current operator of a goal and modifying the
state.  Thus, a preference receives O-support  if  the  preference  is  for  an
augmentation  of  the  current  state  or  substructure  of  the state, and the
conditions of the instantiation that created it test the current operator.   It
may not be possible to make the determination of O-support until the production
is instantiated if only the state's substructure is modified.

O-support is also given to preferences that instantiate an  operator  from  the
state  because that operator substructure must be maintained while the state is
changing during operator application.  For example, if an operator is to move a
block 20 inches from its current position, X, a production can fire and augment
the operator with the desired position: X + 20.  If retraction is allowed, this
value  will  be  removed  as  soon  as  the block is moved a small amount, thus
leading to confusion during operator application. Therefore, a  preference  for
an  augmentation  of  an  acceptable  operator or substructure of an acceptable
operator receives O-support if the conditions of the  production  instantiation
that  created  it  test  the current state or part of its substructure.  In the
case that an operator is  proposed  (through  the  creation  of  an  acceptable
preference  for  the  operator)  and  augmented  within the actions of a single
production, those augmentations will receive O-support if they are dependent on
the state or part of its structure.  The acceptable preference for the operator
receives only I-support.

A  preference  loses  O-support  (and  I-support)  if  an  O-supported   reject
preference  is created for the augmentation, in which case, all preferences for
that augmentation created in that goal (including the reject) are removed  from
preference  memory.    An  O-supported  preference  will  also  be removed from
preference memory if it becomes unlinked from the context-stack.  Finally, both
I-support  and  O-support  are  local  to  the  goal  in which a preference was
created.  Thus, a preferences loses O-support when the goal  in  which  it  was
created  terminates  (see  Section 3.6.3 for details on the support for subgoal
results).

All attempts to make persistent  changes  to  working  memory  should  be  made
through  operator  application.   Otherwise, there is a danger that productions
will "loop".  Looping occurs when the effect of a production firing causes  the
production  to  be retracted, possibly by removing an augmentation from working
memory that is tested by the conditions.  When the production is retracted, the
action  is  undone,  and the augmentation is added back to working memory.  The
production fires again, and the cycle continues.   For  example,  a  production
might  move  one  block  onto a second block.  If the production tests that the
second block is clear, then it will retract when the first block is on  top  of
the second, only to fire again if the retraction causes the change to be undone
in working memory.  If the production is part of an operator application,  then
its effects will not be undone upon retraction.

3.5. Preference processing
In  determining  changes  to  working memory, preferences for all augmentations
except context slots are processed as soon as they are  created  by  production
firings  during the preference phase of the elaboration cycle. Figure 3-4 shows
an overview of a complete decision cycle as well as details of the phases of an
elaboration  cycle.    Based  on  the  preferences, changes are made to working
memory in what is called the working memory phase  of  the  elaboration  cycle.
Once  changes are made to working memory, the production memory is tested again
for new instantiations or retractions.  The elaboration cycles  continue  until
quiescence,  that  is, until no more new production instantiations are created,
and no more retract (see Section 6 on page 77 for details of how  I/O  fits  in
with  an  elaboration  cycle).   The total set of elaboration cycles that occur
before quiescence is called Soar's elaboration phase.

Once Soar reaches quiescence, the decisions for context slots are made.    This
process  is  called  the  decision phase. The determination of values for these
context objects differs in five ways from other augmentations:

   1. Decisions for context slots are made only during the decision phase.

   2. Decisions are made only for context slots that do not have a current
      value,  or  for  context  slots  for  which  there  is  a reconsider
      preference for the current value.

   3. A state slot can have a value only if a  problem  space  object  was
      selected  before the current decision phase, and a operator slot can
      have a value only if a state object is selected before  the  current
      decision phase.

   4. If  a  new problem space is selected, the state and operator context
      slots are eliminated because they are no longer relevant to the  new
      problem  space.  Similarly, if a new state is selected, the operator
      context slot is eliminated.

   5. If a change is made to a context slot, all newer contexts (subgoals)
      are eliminated, as they will no longer be relevant.

The elaboration phase together with decision phase completes the basic cycle of
Soar.  The  elaboration  phase  implements  the  PSCM  functions  of  proposal,
comparison,  and  refinement.   The context decisions determine the behavior of
the system and implement the PSCM functions  for  selecting  a  problem  space,
selecting  an  initial  state, selecting an operator, applying an operator, and
terminating an operator.   Context  decisions  lead  directly  to  irreversible
actions  through  changes  in the context, through the application of operators
that modify the external world, or  through  changes  to  the  internal  state.
Because  the  context  decisions  are  delayed  until  quiescence, all relevant
permanent knowledge has been retrieved when these PSCM functions are performed.



3.5.1. Preference semantics
In processing the preferences, the  decision  procedure  assumes  that  only  a
single  value  can  be  selected  for  an augmentation, that is, all values are
mutually exclusive.  Only through  parallel  preferences  can  multiple  values
arise, and then only for non-context slot augmentations.  In addition, there is
no implicit transitivity in the semantics of preferences.  If A is  indifferent
to B, and B is indifferent to C, A and C will not be indifferent to one another
unless there is a preference that A is indifferent to C (or C and  A  are  both
unary indifferent).

The preferences act as a set of generators of candidate selections and a set of
filters that remove candidate objects from consideration.    Reconsider  is  an
exception  in  that  it  is  a  signal to run the decision procedure and has no
influence on the outcome.  Below is  a  list  of  the  preferences  with  brief
descriptions of their semantics.  They are processed in the order in which they
are described: require, accept, reject, prohibit,  better/worse,  best,  worst,
indifferent, and parallel. The processing of a preference is conditional on the
outcome of previous filters, so that if a definite decision can be  made  based
on  an  earlier  filter,  preferences  that occur later in the list will not be
consulted, with the exception that an acceptable value will not be selected  if
it  is also rejected or prohibited. For example, if there is only one candidate
that is  acceptable,  and  not  rejected  or  prohibited,  none  of  the  other
preferences will be consulted.

Reconsider (@)  A  reconsider  preference  states  the  decision  for a context
                augmentation should be reconsidered,  that  is,  it  should  be
                recomputed  with  the  available  preferences at quiescence.  A
                reconsider preference is necessary  for  changing  an  existing
                decision for a context slot, such as terminating an operator or
                selecting a new problem space.  When a reconsider preference is
                created for the current operator, the architecture augments the
                goal with ^applied <o>, where <o>  is  the  identifier  of  the
                operator.    This  augmentation  provides  a  signal  that  the
                operator has been terminated.  Reconsider  is  only  meaningful
                for context slot augmentations.

Require (!)     A  require preference states that the value must be selected if
                the goal is  to  be  achieved.    If  a  value  has  a  require
                preference,  it  will be selected unless there is another value
                with a require  preference,  or  the  same  value  also  has  a
                prohibit   preference.      In   these   latter  two  cases,  a
                constraint-failure impasse arises (see Section 4.3 on page 66).
                None of the remaining preferences (except prohibit) is examined
                if an object has a require preference.  A production creating a
                require  preference  is included in the traces used by chunking
                (see Section 5.2 on page 70).

Acceptable (+)  An acceptable preference states that a value is a candidate for
                selection.   All values, except those with require preferences,
                must have an acceptable preference in order to be selected.  If
                there is only one value with an acceptable preference (and none
                with a require preference), that value will be selected as long
                as it does not also have a reject or a prohibit preference.  If
                there is more than one value with an acceptable preference, and
                no  reject  or  prohibit  preferences, the worse, better, best,
                worse,  parallel,  and  indifferent  preferences  are  used  to
                determine  the  selection.  A production creating an acceptable
                preference is included in the  traces  used  by  chunking  (see
                Section 5.2 on page 70).

Reject (-)      A  reject  preference  states that the value is not a candidate
                for selection.  If a value has a reject preference, it will not
                be  selected unless there is also a require preference for that
                value. A reject preference and an acceptable preference do  not
                cause an impasse; the reject dominates.

Prohibit (~)    A  prohibit preference states that the value cannot be selected
                if the goal is to be achieved.   If  a  value  has  a  prohibit
                preference,  it  will  not  be  selected  for  a  value  of  an
                augmentation, independent of the other preferences.  It differs
                from  reject in two ways: it can not be overridden by a require
                preference, and it will be included in  the  production  traces
                built  up  for chunking (see Section 5.2 on page 70).  If there
                is a prohibit preference and require preference  for  the  same
                value,  a constraint-failure impasse arises (see Section 4.3 on
                page 66).

Better (>),
Worse (<)       A better  or  worse  preference  states,  for  the  two  values
                involved,  that  one  value should not be selected if the other
                value is a candidate.  Better and worse allows for the creation
                of  a  partial  ordering  between candidate values.  Better and
                worse are simple inverses of each other, so that A better  than
                B is the same a B worse than A. A value will not be selected if
                it is worse than another acceptable value  that  has  not  been
                rejected  or  prohibited  (and there are no require preferences
                for the given value).  If such an acceptable  value  is  better
                than  a  second, and the second is better than the first, there
                is  a  conflict  impasse.    The  conflict  can  be  broken  by
                rejecting,  prohibiting or requiring one of the two values.  If
                there is no conflict and there is a single value  that  is  not
                worse  than  some  other  value,  that  value will be selected,
                independent  of  any  best,  worst,  parallel,  or  indifferent
                preferences.

Best (>)        A  best  preference  states  that  the  value is good enough to
                select without further consideration.  If a value is best  (and
                not  rejected,  prohibited,  or worse than another), it will be
                selected over any  other  value  that  is  not  also  best  (or
                required).    If  two  such values are best, then the remaining
                preferences (worst, parallel, indifferent) will be  examine  to
                determine  the  selection.  If a value (that is not rejected or
                prohibited) is better than a best value, the better value  will
                be  selected  because  the  best  preference  would not even be
                examined.

Worst (<)       A worst preference states that the  value  should  be  selected
                only if there are no alternatives.  It allows for a simple type
                of default specification.    If  a  value  is  worst  (and  not
                rejected,  prohibited,  or  worse than another), it will not be
                selected unless  there  are  no  other  similar  non-worst  (or
                required)  values.    If  two such values are worst, then a tie
                impasse will arise.  If a value is both worst and best, it will
                be  selected over all worsts, and if there are other bests that
                are not worst, it will not be selected.

Indifferent (=) An  indifferent  preference  states  that  there  is   positive
                knowledge  that  it  does  not  matter which value is selected.
                Indifferent is only considered after all other preferences have
                been  processed.  If the preference is unary, then the value is
                considered to be indifferent to all other values with  a  unary
                indifferent  preference.   Its effect is to break a tie between
                candidate values that have no other preferences to  distinguish
                between   them.    If  there  are  not  sufficient  indifferent
                preference to break such a tie, then a tie impasse arises.  The
                exact  mechanism  for  selecting  between indifferent values is
                determined by the function user-select (see Section  9.3.11  on
                page 153).

Parallel (&)    A  binary  parallel  preference  states that two values are not
                mutually  exclusive.    Therefore,  if  these  values  are  not
                dominated  by other values through additional preferences, they
                will both become values of  the  augmentation.    This  can  be
                extended  to  any  number  of  values,  as long as they are all
                mutually parallel; however, there is no  implicit  transitivity
                of  parallelism,  so  each  pair of values must be parallel.  A
                unary parallel preference states that a value is  not  mutually
                exclusive   of  any  value  that  also  has  a  unary  parallel
                preference.  Parallel preferences cannot be  used  for  context

-------------------------------------------------------------------------------



                      Figure 3-4:  Soar's decision cycle.
-------------------------------------------------------------------------------
                objects.

3.6. Impasses and subgoals
When   the  decision  procedure  is  applied  to  determine  the  value  of  an
augmentation, it is possible that the  preferences  are  either  incomplete  or
inconsistent.    This  is  true  for deciding on context slots, such as when an
operator is selected, or for individual augmentations, such as determining  the
color of a block.  The preferences may be incomplete in that acceptable objects
are not suggested, or that there are insufficient  preferences  to  distinguish
between acceptable objects.  The preferences may be inconsistent in that object
A is preferred to object B, and object  B  is  preferred  to  object  A.  Since
preferences  are  generated independently, there is no guarantee that they will
be consistent.



3.6.1. Impasses
When the preferences for an augmentation do not lead to a consensus choice,  an
impasse  arises.      Soar's  handling  of  the  impasse depends on the type of
augmentation.  Soar distinguishes two types of impasses.    Attribute  impasses
arise  when  a  decision  can not be made for any augmentation except a context
slot. Context impasses arise when a decision cannot be made for a context slot.

For  an  attribute  impasse,  Soar creates an impasse object that describes the
type of impasse, and any tying or conflicting candidates.  The impasse  objects
can  then  be  tested  by  productions  to  detect that there were insufficient
preferences to select the value of an augmentation.  There  is  no  requirement
that  the  impasse  be  resolved  as  it  is often possible to continue problem
solving with some limited uncertainty.  Impasses are resolved when a  consensus
choice can be made, usually through the addition of new preferences.  Resolving
an attribute impasse can be a bit tricky because as soon as a new preference is
created  by  a production to resolve the impasse, the impasse object is removed
from working memory.  If the production that created the preference tested  the
impasse object, it could be retracted, leading to another attribute impasse and
indefinite looping.  To avoid the retraction, the  preference  to  resolve  the
impasse should be created by an operator application production.

If  an  impasse  arises  for a context slot then it signifies that knowledge to
perform a PSCM function is lacking.  In response to this  type  of  impasse,  a
subgoal  is  created  in  which the full power of Soar's problem solving can be
used to retrieve or generate additional knowledge, ultimately  leading  to  the
creation  of  preferences that resolve the impasse.  Once a subgoal is created,
productions fire to propose problem spaces, and then initial  states,  followed
by operators, and so on.  The knowledge to resolve the impasse may be retrieved
by any type of problem solving, from searching to discover the implications  of
different  decisions,  to  asking  an  outside agent for advice.  There is no a
priori  restriction  on  the  processing,  except  that  it  involves  applying
operators to states.

Within a subgoal, additional impasses may be encountered, leading to additional
goals, and the creation of a stack of goals and their associated contexts.   As
stated  earlier,  the context stack is contained in working memory.  Because of
the nature of the PSCM functions, and the semantics of  preferences,  only  one
context  impasse is possible at a time for a given goal. If there is an impasse
for a context given augmentation, say the problem space, no decision is made on
lower context slots, in this case the state and operator.

There are four types of impasses that can arise from the preference scheme:

   1. A  tie  impasse  arises  if  the preferences for an attribute do not
      distinguish between two or more values with acceptable  preferences.
      A  tie  impasse  can be resolved by creating preferences that prefer
      one option (better, best, require), eliminate  alternatives  (worse,
      worst,   reject,   prohibit),   or   make  the  objects  indifferent
      (indifferent).  If two values have best or worst  preferences,  they
      will tie unless additional preferences distinguish between them.

   2. A  conflict  impasse  arises if at least two values have conflicting
      better or worse preferences (such as A is better than  B  and  B  is
      better  than  A)  for  an  attribute,  and  neither one is rejected,
      prohibited, or required.  A conflict  impasse  can  be  resolved  by
      creating  preferences  to require one option (require), or eliminate
      the alternatives (reject, prohibit).

   3. A constraint-failure impasse  arises  if  there  is  more  than  one
      required object for an attribute, or if an object has both a require
      and a prohibit preference.  These preferences represent  constraints
      on  the legal selections that can be made for a decision and if they
      conflict, no progress can be made from the current situation and the
      impasse  cannot  be  resolved by creating additional preferences for
      the values.

   4. A no-change impasse arises if none of the context slots change value
      during  the  decision  procedure.  A  no-change  can  be resolved by
      creating a reconsider preference for the last object selected, or by
      creating  acceptable  or require preferences for the next empty slot
      of the context.

A given attribute or context slot can have only one impasse at  a  time.  Given
the  semantics of the preferences, it is possible to have a tie or conflict and
a constraint-failure at the same time.  In these cases, Soar detects  only  the
constraint-failure.



3.6.2. Elimination of impasses
A  context  impasse can be eliminated by changing the preferences available for
the context slot or by changing a higher-level decision in the  context  stack.
Whenever  there is a change in the preferences that are available for a context
slot with an impasse, the architecture attempts to make a decision on that slot
during  the  next  decision  following  quiescence;  if  the  impasse  has been
resolved, the subgoal is terminated.  For example, if a tie impasse arises  for
a context slot, it will terminate when sufficient preferences have been created
so that a single object dominates all  others,  or  all  objects  are  mutually
indifferent.

Any context impasse can also be eliminated by changing a decision higher in the
context stack.  A change higher in the context stack leads to  the  removal  of
all  preferences  for the lower-level identifier and attribute.  The change can
be either selecting a different object for a higher slot or resolving a  higher
impasse.    An  example  of this is rejecting the problem space when there is a
constraint-failure impasse for the state or operator.

Resolving an attribute impasse  is  trickier  because  no  justifications  (see
Section  3.6.3  on  page 38) are built to maintain the preferences that resolve
the impasse.  Justifications cannot be built because the cause of an  attribute
impasse  M multiple alternative values for an attribute M is not represented in
working memory.  The acceptable preferences for non-context  augmentations  are
held only in preference memory, making impossible to create a justification (or
chunk) to support the result.  Therefore, an attribute impasse must be resolved
by  an O-supported preference so that the preference persists after the impasse
object is removed.  If the preference has only I-support, it will be  retracted
as  soon  as  the  impasse  is  resolved because the production that created it
depends on the existence of the impasse.  The impasse will then  be  recreated,
leading to an infinite loop.

Below are four approaches to eliminating an attribute impasse:

   1. If  the  impasse  arises  in  the middle of an operator application,
      include in the operator application productions some that detect and
      eliminate  attribute  impasses.    As  part  of  an  operator, these
      productions create O-supported preferences.

   2. If the impasse arises in the middle of an operator application,  and
      the   impasse  prevents  the  operator  from  terminating,  use  the
      resulting subgoal (arising from an operator  no-change  impasse)  to
      apply  operators that detect and resolve the attribute impasse (and,
      indirectly, the operator  no-change).    An  attribute  impasse  can
      prevent  termination  if  the  attribute  involved  is tested by the
      production that generates the reconsider.  The result of fixing  the
      impasse  in  the  subgoal  is  a chunk that behaves like the special
      productions do in approach (1), above.

   3. When an attribute impasse arises, create an operator to  handle  the
      impasse and prefer it to all others.  One general strategy is to use
      approach (2) above for attribute impasses that lead to  an  operator
      no-change,  and  to  use the current approach for attribute impasses
      that lead to operator ties or conflicts.

   4. If the attribute impasse does not lead to another impasse  (such  as
      an  operator  tie  or  no-change),  then  ignore  it until it causes
      problems.  This "lazy evaluation" approach has a problem in that the
      existence of the attribute impasse could cause different productions
      to fire than  would  otherwise,  leading  to  different  results  in
      problem solving.

Both  context  and attribute impasses can also be resolved by the retraction of
existing preferences. For example, productions can change the  substructure  of
an  object  that provides I-support to a preference, via an instantiation.  For
example, if an instantiation creates a preference that causes an  impasse,  the
objects matched by that instantiation can be altered, causing the instantiation
to  retract  and  possibly  resolving  the  impasse.    However,  there  is  no
representation  in  working  memory of the objects that provide I-support for a
preference, so it is not possible to determine directly which object to  modify
to resolve an impasse this way. Trial and error may be the only approach.



3.6.3. Subgoal results
Because  the working memory serves as a common database for all subgoals, it is
not necessary to have explicit  parameters  or  results  for  subgoals.    Both
parameters  and  results  are  determined  dynamically  by  the  nature  of the
processing in the subgoal.  The parameters to a  subgoal  can  be  anything  in
working  memory  that  is matched by a production during problem solving in the
subgoal.

Figure 3-5 shows an example where there is  a  context  (labeled  supercontext)
with  problem  space  top-ps,  a  state  that  contains  a  description  of the
relationships between the  blocks,  such  as  ontop  and  clear,  and  operator
build-tower.    This operator can not be applied directly, so an impasse arises
and a subgoal is created to perform whatever processing is necessary  to  apply
the  operator.    The circles in the figure are objects (goals, problem spaces,
states, and operators), with the far left object  in  each  context  being  the
goal.  The boxes are constants, such as build-tower and move-block.  The arrows
represent augmentations.  For both contexts, the goals have  augmentations  for
the   current  problem  space,  state,  and  operator.    The  subgoal  has  an
augmentation, created by the architecture, that points to the supergoal.    The
augmentation  is  called  object, because the supergoal is the object for which
the impasse occurred.  Attribute-impasses also have object  augmentations  that
point to the object that has the impassed augmentation.

The  subgoal's  problem space is called blocks-world, and its state is the same
state as in the supercontext.  When the  move-block  operator  is  selected  to
apply  in  the  subgoal, productions fire to modify the state.  One of these is
shown at the right of the Figure 3-5.   This  production  matches  the  problem
space,  state  and operator of the subgoal, as well as some of the substructure
of the state, and then modifies the state by adding that A is on top of  B.  By
changing the state in the subgoal, the state of the supergoal is also modified,
and thus a result of the subgoal is generated.
In  general,  the results of a subgoal are all preferences that were created in

-------------------------------------------------------------------------------



    Figure 3-5:  The creation of a result by a production firing  in  a
                 subgoal and modifying the state shared by the supercontext.
-------------------------------------------------------------------------------

the subgoal, but are linked to a super-context.  A preference  is  said  to  be
created  in  a subgoal if the production that created the preference tested the
goal and this is the lowest (most recent) goal of  the  context-stack  that  is
tested.    Thus,  if  a production tests multiple goals, the preferences in its
actions are considered to be created only in the lowest of those  goals.    The
architecture  automatically detects if a preference in a subgoal is linked to a
super-context.

A preference can become a result directly when it is created and its identifier
is  already  linked  to  a  super-context  as  is  the  case  in Figure 3-5.  A
preference can also become a result indirectly if, after it is created  and  it
is still in preference memory, its identifier becomes linked to a super-context
through some other result.  For example, if the problem solving in a subgoal is
constructing  an  operator  for a super-context, it may wait until the operator
structure is complete before creating an acceptable preference for the operator
in  the  super-context.    The acceptable preference is a result because it was
created in the subgoal and is linked to the goal of  the  super-context.    The
substructures  of  the  operator  then  become  results  because the operator's
identifier is now linked to the super-context.

When a subgoal terminates, it is removed from working memory.  This unlinks all
preferences  and  working  memory  elements created in the subgoal that are not
results, causing them to be removed from preference and working  memory.    The
results  remained  linked,  and  will  have I-support or O-support as described
below.

The type of support received by a result is determined by the PSCM function  it
plays  in the super-context, and not the function (such as operator application
or state refinement) it played in the subgoal.  For example, if  a  result  has
only  I-support  in the subgoal, it must have some additional support after the
subgoal is terminated because many of the working  memory  elements  that  were
tested  in  the production that created the result will be removed from working
memory when the subgoal is terminated.  If the result had O-support when it was
created  in  the  subgoal,  it  might  not  even  be  part  of  a  state  in  a
super-context, or it may be independent of  any  operator  application  in  the
super-context.   For example, in a subgoal to create a problem space, the state
may have a partial description of the problem space.    The  problem  space  is
created  through  operator  application  in the subgoal, but within the goal in
which the problem space will be selected it is created through simple  proposal
and refinement.

In  order for the architecture to determine the PSCM function that a preference
plays, there must be a production instantiation  that  determines  whether  the
preference  should  receive  O-support  or  I-support.   The actual support the
preference received in the subgoal is irrelevant in the super-context.    Thus,
whatever  support  the  preference  had  in  the  subgoal  is  removed  and the
architecture  creates  an  temporary   production   instantiation,   called   a
justification,  that  summarizes  the processing in the subgoal that led to the
result.  The conditions of a justification are those  working  memory  elements
that  were  necessary  for producing the result and were not removed by subgoal
termination.  That is, the working memory elements where matched by productions
that  fired  on  the  path  to  the  creation of the result.  The action of the
justification is the result.

The justification includes any negated conditions that  were  in  the  original
productions that participated in producing the results, and that tested for the
absence of super-context  working  memory  elements.  Negated  conditions  that
tested for the absence of working memory elements that are local to the subgoal
are not included.  This can lead  to  some  cases  of  overgeneralization  (see
Section 5.6 on page 73 for details).

The  structure  of the justification determines the appropriate support for the
result in the goal.   If  the  justification  is  an  operator  application  or
operator   instantiation   production,   the  result  will  receive  O-support.
Otherwise, the result gets I-support from the justification. If a such a result
loses  I-support  from  the  justification, it will be retracted if there is no
other support.  Because support is determined by the conditions and actions  of
the  justification,  support  in the super-context is completely independent of
the type of support received in the subgoal.  For example, a preference created
in  a  subgoal  by  applying  an  operator  may  be computing a refinement of a
superstate, or in contrast, a refinement of a state (containing pointers to the
superstate  and  superoperator)  in  a  subgoal  may  be  part  of  an operator
application for the super-context.



3.6.4. Types of subgoals
All of the traditional types of goals found in  AI  systems  are  generated  by
impasses  in  Soar.    Standard  conjunctive  or deliberate goals arise when an
operator is selected and the knowledge encoded in productions  is  insufficient
to  apply  and  terminate  it  directly.    In these cases, a no-change impasse
arises.  In the subgoal, the  operator  can  be  implemented  piece  by  piece,
possibly  by  breaking  up  a conjunctive goal by creating operators to perform
each individual conjunct.  The state selected in the subgoal can be exactly the
same state as was selected in the goal where the operator arose.  The operators
in the subgoal can transform the state, bit by bit, until the operator with the
impasse is complete and can be terminated.

In  addition  to traditional goals, Soar also generates goals to decide what to
do next.  These are search-control goals, sometimes called  meta-goals,    that
arise  when  there  is  a  tie or a conflict for the selection of the operator.
Instead of having to rely on a fixed policy, conflict resolution  strategy,  or
random choice, Soar can explicitly consider which option it should select.

Of  all  the  PSCM functions, the Soar architecture directly performs only goal
creation and termination.  The remainder of the PSCM functions are carried  out
by  either  direct memory retrieval or deliberate problem solving, depending on
the available knowledge.  For  tasks  where  Soar  has  sufficient,  consistent
knowledge,   the   PSCM   functions  are  based  on  knowledge  retrieved  from
productions.   When  that  knowledge  is  insufficient  or  in  conflict,  Soar
automatically  creates  subgoals.    In  the  subgoal,  the PSCM is recursively
applied to deliberately perform the appropriate PSCM function.  Soar's learning
mechanism, described below, converts the deliberate problem solving of subgoals
into automatic retrieval mechanism by productions.

3.7. Learning
Soar supports a general learning mechanism, called chunking [Laird, Rosenbloom,
and  Newell  86a].    Chunking  occurs  as  a  by-product of problem solving in
subgoals.  Whenever a result is produced in a subgoal, a chunk is created  that
is a variablized version of the justification built for the result.  Therefore,
a chunk is a production composed of the result and the conditions  under  which
the  result  was  generated.    The  conditions  are based on those elements of
working memory that were tested by productions in the  subgoal  and  that  were
linked to a super-context.  When Soar next encounters a similar situation, that
chunk will be used in problem solving to avoid an impasse.  Chunks are  learned
for  any PSCM function that requires a subgoal, such as problem space selection
and proposal, or operator proposal, selection, and application.  See Chapter  5
on page 69 for complete details of chunking.

Chunks  are not learned over attribute impasses (see Section 3.6.2 on page 13).
This is because the conditions that lead to  an  attribute  impasse  cannot  be
detected  until  the impasse actually occurs, that is, until the impasse object
enters working memory.  Context impasses are caused when there are  preferences
for  competing  context  objects in working memory.  The acceptable preferences
for those objects can be detected, and a subgoal result can be created to allow
Soar   to  distinguish  between  them.    This  processing  is  captured  in  a
justification.  With attribute impasses, on the  other  hand,  the  preferences
that  cause  them  are  held only in preference memory, and cannot be detected.
Therefore, no justification can  be  built  that  will  detect  and  prevent  a
situation that will cause an attribute impasse.

3.8. Input and output
Soar  interacts  with  the  outside  world  through  a  set of input and output
modules.    It  receives  sensory  data  and  transmits  motor   commands   via
augmentations  of  the  top  state.    This provides a single locus for testing
changes in the environment as well as performing external  actions.    It  also
prevents  subgoals  from  having  hidden  side-effects by modifying the outside
world independently of higher contexts.  Although it  may  appear  to  restrict
access  in  subgoals, the top state can always be accessed indirectly by making
it an augmentation of a state in a subgoal.

Input from the external environment appears as special augmentations of the top
state.    The attributes of these augmentations are determined by user-provided
input functions.  These functions are called before each elaboration cycle  and
before  quiescence.  Therefore,  there  is  no direct control of input from the
actions of productions, nor does the system ever  "hang"  while  it  waits  for
input.  Any control of input, such as moving a sensor or waiting for new input,
must be performed deliberately through  the  use  of  motor  commands  or  wait
operators.

Output  is  performed by creating special augmentations of the top state.  Just
as with input, the exact attributes and structure of  these  augmentations  are
determined  by user-provided output functions.  The output functions are called
whenever the relevant augmentations are modified in working memory.   Functions
for text input and output are provided; other input and output functions depend
on the application and must be written by the user.  See Chapter 6 on  page  77
for complete details of input and output in Soar.

3.9. Default knowledge
In  addition  to  the  base  architecture,  default  knowledge  is provided for
selecting the top-level problem space and state as well as resolving all of the
classes  of  impasses when no additional knowledge can be found through problem
solving in a subgoal.  Any additional  task-specific  knowledge  about  how  to
resolve  the  impasse  will  dominate the default knowledge and control problem
solving in the subgoal. See Chapter 7 on page 101 for complete details  of  the
default knowledge in Soar.

3.10. Encoding a task
In  this  section  we  return  to  the  Blocks  World  and show how it would be
implemented  using  productions.    This  parallels  the  presentation  of  the
PSCM-level  description of the Blocks World presented in Section 2.3 on page 7.
Chapter 8 on page 115  returns  to  this  task  using  syntactically  bona-fide
productions.

In  this  example,  the productions are abstractions of actual productions that
illustrate the  various  forms  of  knowledge  required  to  perform  the  PSCM
functions  for  the  Blocks  World.    The  productions  are  interspersed with
commentary and a trace of the decision to indicate how Soar uses the knowledge.
To  simplify  the  productions, the conditions assume that all of the mentioned
context objects, such as problem spaces, states, and  operators,  are  selected
for  the  same  goal.   The actual Soar productions explicitly test the goal of
each selected object.  In addition, the descriptions  of  the  actions  of  the
productions  gloss  over the preferences for individual augmentations except in
the case of context slots.  That is, we  will  pretend  that  actions  actually
modify working memory rather than generating preferences for the changes.
3.10.1. Initialization
When  Soar  starts up, it generates and selects the first goal.  Soar's default
knowledge then proposes a top-level problem space and state where the top level
state  contains  input from the outside environment.  For this example, we will
assume that the top state contains the current configuration of blocks  in  the
environment.    In this example, block A is on top of B, and blocks B and C are
on the table (see Figure 2-5 on page 7).  The traces of  problem  solving  show
the  number  of the decision on the left, followed by G:, P:, S:, or O:.  These
signify which context slot has a  new  value  on  this  decision.    These  are
followed  by  a  symbol which is the identifier of the object selected for that
slot.  Following the object identifier is a simplified  representation  of  the
substructure  of  the  object,  usually including its name (such as top-state).
For example, the initial trace looks as follows, showing that goal  G1  is  the
current  goal  at  decision  0  followed by selections of the top-level problem
space and state.

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 (top-state) ((ontop A B) (ontop B table) (ontop C table))



3.10.2. Proposal of the operator to perform the task
After the state has been selected, the operator to  perform  the  task  can  be
proposed.  The operator includes a desired state, in which block A is on top of
block B, block B is on top of block C, and block C is on the table (see  Figure
2-5  on  page  7).    The  following  production  creates  the  operator and an
acceptable preference for it.  In general, additional conditions would exist so
that this operator is proposed only when the blocks must be stacked.

    IF   the goal is the top goal, and
         the state has three blocks, A, B, and C that are not stacked,
    THEN create an operator named build-tower with a desired state in which
            block A is on top of block B, B is on top of block C,
            and block C is on the table, and
         create an acceptable preference for this operator for the top-goal.

Following  the selection of the operator created by this production, an impasse
would arise because the operator cannot be  applied  directly  in  productions.
The cumulative trace looks as follows:

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 ((ontop A B) (ontop B table) (ontop C table))
    3   O: O15 (build-tower ((ontop A B) (ontop B C) (ontop C table)))
    4   ==> G: G21 (operator no-change)



3.10.3. Proposal of the initial problem space
After  a  goal  has  been  created to resolve the operator no-change impasse, a
problem space can be proposed.  The problem space  determines  which  operators
are  acceptable  for  applying  to the states that will be generated during the
search.  The following production names the goal, generates and names a problem
space  (blocks-world),  and  creates  an acceptable preference for that problem
space.  The name of the problem  space  will  be  tested  by  productions  that
propose  operators so that only operators that are appropriate for this problem
space will be suggested.

    IF   the goal is to resolve an operator no-change impasse, and
         the superoperator is build-tower with a desired state,
    THEN name the goal build-tower and
            augment the goal with the superoperator's desired state, and
         create a problem space named blocks-world, and
         create an acceptable preference for that problem space.

After this production fires and the next decision is made, the cumulative trace
is as follows:

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 ((ontop A B) (ontop B table) (ontop C table))
    3   O: O15 (build-tower ((ontop A B) (ontop B C) (ontop C table)))
    4   ==> G: G21 (operator no-change)
    5       P: P22 (blocks-world)



3.10.4. Proposal of the initial state
Once  the  problem  space  is  selected,  an initial state must be proposed and
selected.  For this task, the initial state can  be  the  original  state  (S4)
which has all of the necessary information.  For many subtasks, it is necessary
to maintain local state information that is relevant only to the subtask.    In
these  cases  it  is  appropriate  to create a new state symbol that indirectly
references the original state, or that has structures from the original  state.
All  local  state  information  can  then  be  attached to the new state symbol
without modifying the original state.  For  this  problem,  there  will  be  no
additional local state information, so the original state can be used directly.

    IF   the goal is named build-tower, and
         the problem space is named blocks-world
    THEN create an acceptable preference for the superstate
            for the build-tower goal.

After this production fires, the cumulative trace is:

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 ((ontop A B) (ontop B table) (ontop C table))
    3   O: O15 (build-tower ((ontop A B) (ontop B C) (ontop C table)))
    4   ==> G: G21 (operator no-change)
    5       P: P22 (blocks-world)
    6       S: S4 ((ontop A B) (ontop B table) (ontop C table))



3.10.5. Operator proposal
At this point, the task has been completely formulated in that there is a goal,
a problem space and an initial state.  From here, Soar must  select  and  apply
operators  that are part of the selected problem space so that it can transform
the current state into a desired state.  For  the  Blocks  World,  the  problem
space  can  have  only  a  single  operator:  move a block from one location to
another.

In Soar there is a distinction between an operator and its  instantiations;  as
with  productions  and  production  instantiations,  this  distinction is often
blurred.  In the remainder of this chapter, the term operator will refer  to  a
single instantiated operator.

The  next  production proposes the move-block operator.  In creates an operator
instantiation for every clear block, and every clear location (either  a  block
or the table).

    IF   the problem space is named blocks-world, and
         the state has a block that is clear, and
         there is another place that is clear
    THEN create an operator named move-block to move the first block
             to the place, and
         create an acceptable preference for that operator.

This  production  fires  once  the  problem space and state have been selected.
However, unlike the previous productions, this production  will  have  multiple
instantiations and create multiple instances of the move-block operator.  There
are two clear blocks (A and C) so there will be operators for  moving  each  on
top  of  each other as well as for moving block A to the table.  All production
instantiations fire simultaneously so  that  all  operator  instantiations  are
created in parallel.



3.10.6. Operator comparison
Following  the  creation  of  the  acceptable  preferences,  there are multiple
operators proposed for the current state.  If there is no additional  knowledge
to  decide  between  them,  a  tie  impasse  will arise because several equally
eligible operators are competing for the same slot.

The user might find it expedient to  provide  Soar  with  additional  knowledge
about  preferring  some  operators  over  others.    For example, the following
production expresses the search control knowledge SK2  from  Section  2.3.2  on
page 7, which prefers an operator that moves a block into its final position.

    IF   the goal is named build-tower, and
         the problem space is named blocks-world, and
         there is an acceptable preference for an
             operator that will move a block into
             its position in the desired state of the goal, and
         there is an acceptable preference for an operator that
             does not move a block into its desired position,
    THEN create a better preference for the first operator over the second.

In  our  example, this production will not fire because the two blocks that can
be moved, A and C, are already in their desired positions.  Only B,  for  which
no operator was generated, is out of place.

Another  general  heuristic (SK3) is to avoid moving a block onto another block
that is not the first block's desired location:

    IF   the goal is named build-tower, and
         the problem space is named blocks-world, and
         there is an acceptable preference for an
             operator that will move a block onto a second block, and
             that is not the first block's position in the desired
             state of the goal,
    THEN create a worst preference for the operator.

In our example, this production will fire twice, creating worst preferences for
moving  A  onto  C  and  for  moving  C onto A. Moving A onto the table will be
acceptable and not worst, and will be selected as the current operator  in  the
subgoal.

After the operator is selected, the cumulative trace is:

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 ((ontop A B) (ontop B table) (ontop C table))
    3   O: O15 (build-tower ((ontop A B) (ontop B C) (ontop C table)))
    4   ==> G: G21 (operator no-change)
    5       P: P22 (blocks-world)
    6       S: S4 ((ontop A B) (ontop B table) (ontop C table))
    7       O: O22 (move-block A table)



3.10.7. Operator application: External
At  this point, an operator has been selected, but it has not yet been applied.
If the task is to be performed using real blocks in an external environment, it
is  not  sufficient  to merely change the internal representation of the state.
Instead, a command must be issued to  the  motor  system.    In  Soar  this  is
performed  by  creating  a special augmentation of the top-level state with the
command as the value (See Section 6.3.3 on page 96).    In  this  example,  the
change  is  to  be  made  to  state S4, which is the selected state in both the
top-level goal and the subgoal.  This demonstrates why the top-level state must
be  accessible  in  the  subgoal if the operators in the subgoal are to perform
actions in the external environment.   The  following  production  creates  the
necessary augmentation.

    IF   the selected operator is to move a block to a destination,
    THEN augment the state with a command to move the block to its
            destination.

The  motor  system will execute the command and then the perceptual system will
deliver the changes to the state (see Section 6.3.2 on page 91).  The  feedback
from  the  perceptual system may take multiple elaboration cycles, and possibly
multiple decision cycles depending on the delay in  the  motor  and  perceptual
systems.  This delay can be handled by falling into a no-change impasse subgoal
and continually selecting an operator (such as "wait") that  does  nothing  but
immediately  terminate.  When perception delivers the appropriate feedback, the
externally-applied operator will be  reconsidered,  and  the  impasse  will  be
resolved and its subgoal terminated.

This  type of operator application corresponds to a closed-loop control system,
where feedback is used to determine the internal state and also whether or  not
an  action  is completed.  External operators can also be implemented where the
changes to  the  internal  state  are  made  directly  by  productions  without
feedback.    Although, this is necessary for internal operator application (see
Section 3.10.10)  it  leads  to  an  open-loop  control  system  in  which  the
internally maintained state may not correspond to the external environment.



3.10.8. Operator termination
Once  an operator has been selected for a given context, the decision procedure
will not be run on the operator slot until a reconsider preference is  created.
The  selected  operator  will  not be displaced by another operator, even if it
loses all of its preferences and other  operators  are  made  better  than  it,
unless  a  reconsider preference is created.  The operator is maintained in its
slot, independent of the changes to the preferences, because the purpose of the
operator is to modify the state.  As the state changes, the preferences for the
operator may be retracted, but the operator will  stay  selected  until  it  is
explicitly terminated.

To  mark  the  point at which an operator terminates, there must be a test that
the  operator  has  successfully  modified  the  state.    In  Soar,   operator
termination  occurs  as a side-effect of making a new decision for the operator
slot.  Once an operator is selected, a new decision for  the  operator  is  not
made until a reconsider preference is created.  Therefore, reconsider acts as a
signal of operator termination.

At quiescence, the reconsider preference causes the  selected  operator  to  be
displaced and the decision procedure is rerun to select an operator to apply to
the new state. In parallel  with  the  application  of  the  operator  and  the
creation  of  the  reconsider preference, other productions will have fired (or
retracted) so that there will  be  a  new  set  of  preferences  for  selecting
operators.    Since  reconsider  only has an effect at quiescence, all of these
preferences were created based on the newly  modified  state.    Therefore  the
application of an operator, the termination of an operator, and the proposal of
new operators for the resulting state can all occur with a  single  elaboration
phase.    The  following  production  detects  that  the operator was correctly
applied and creates a reconsider preference for it.

    IF   the selected state has a block above another object, and
         the selected operator was to move that block above that object
    THEN create a reconsider preference for the operator.

Because of  the  changes  to  the  state,  the  original  preferences  for  the
previously  selected  operator will often be retracted and removed from working
memory.  In the Blocks World example, the production that created the  operator
tested  that the block was not already on the table.  Inasmuch as the result of
the operator is to move the  block  to  the  table,  the  preferences  for  the
operator are retracted.

As  mentioned above, at the same time as the production fires to reconsider the
operator, other productions fire to propose operators for the  modified  state.
This will be followed by productions that create better preferences between the
proposed operators.  In our example, the operator to move A onto the  table  is
reconsidered;  the  next decision will be between operators to move B onto C, B
onto A, C onto B, C onto A, A onto B, and A onto C. Two of these operators will
be  better  than  the others: the operator to move B onto C and the operator to
move A onto B, but there are  no  preferences  to  make  either  one  of  these
operators  better  than  the  other. Additional search-control knowledge may be
helpful here, such as to avoid moving the same block twice, or better  yet,  to
prefer  moving  a block into its desired position over moving a block that will
be above it in  the  desired  state.  Without  this  additional  search-control
knowledge,  a  tie impasse will result; this is described in section 3.10.11 on
page 50. If this additional search-control knowledge is available, however, the
trace will look like the following:

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 ((ontop A B) (ontop B table) (ontop C table))
    3   O: O15 (build-tower ((ontop A B) (ontop B C) (ontop C table)))
    4   ==> G: G21 (operator no-change)
    5       P: P22 (blocks-world)
    6       S: S4 ((ontop A B) (ontop B table) (ontop C table))
    7       O: O22 (move-block A table)
    8       O: O28 (move-block B C)

By  separating  the performance of an external action from the detection of its
completion, the system can detect when the external action has  been  completed
independent  of  how  this  came  about.    When  dealing with operators in the
external environment this approach forces the system to wait until the operator
has  actually  completed.    It  also  allows  the  system to take advantage of
serendipitous changes in the environment that independently achieve the results
of an operator.



3.10.9. Termination of task operator
The  build-tower  operator  should be terminated when the current state matches
the operator's  desired  state.    The  following  production  reconsiders  the
operator  if  the  state  matches the operator's desired state.  The reconsider
will allow a new decision to  be  made  to  select  the  appropriate  top-level
operator.

    IF   the goal is the top goal, and
         the operator is build-tower, and
         the operator's desired state matches the current state
    THEN create a reconsider preference for the operator.

Once  this  production  fires and reconsiders the original task operator (O15),
that operator will not be selected because  the  production  that  created  its
acceptable  preference will no longer match (it tested that the blocks were not
stacked) and the acceptable preference will be retracted.  Thus, if there is an
acceptable  preference for some other operator, that operator will be selected.
In the trace below, we have skipped to the selection of the wait operator,  O5.
The  wait operator is proposed, with acceptable and worst preferences, whenever
problem space top-ps is selected.  When build-tower  was  originally  proposed,
wait  was not selected, but once build-tower was terminated and retracted, wait
is selected.

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 ((ontop A B) (ontop B table) (ontop C table))
    3   O: O15 (build-tower ((ontop A B) (ontop B C) (ontop C table)))
    4   ==> G: G21 (operator no-change)
    5       P: P22 (blocks-world)
    6       S: S4 ((ontop A B) (ontop B table) (ontop C table))
    7       O: O22 (move-block A table)
    8       O: O28 (move-block B C)
    9       O: O26 (move-block A B)
    10  O: O5 (wait)



3.10.10. Operator application: Internal
When an operator is applied internally,  say  to  simulate  the  action  in  an
internal  lookahead  search, there must be productions that directly modify the
state.  In this case, the application of an  operator  transforms  the  current
state  by changing the values of augmentations.  More than one production would
be necessary to make all of the necessary changes to the state  because  moving
blocks  off of the table and onto the table require special handling; the table
is always clear.  Below are three productions that encode the  information  for
modifying  the  state  when  moving a block. (Note that it has to be decomposed
into multiple productions because it is  not  possible  to  encode  disjunctive
actions in a single production.)

    IF   the selected state has block on top of a second block, and
         the selected operator is to move the first block to a third block
    THEN modify the location of the first block to be on top of the third
            block, and
         modify the second block so it is clear, and
         modify the third block so it is not clear.

    IF   the selected state has block on top of a second block, and
         the selected operator is to move the first block to the table
    THEN modify the location of the first block to be on top of the
            table, and
         modify the second block so it is clear.

    IF   the selected state has block on top of the table, and
         the selected operator is to move the first block to a second block
    THEN modify the location of the first block to be on top of the second
            block, and
         modify the second block so it is not clear.

Even  with  internal  operators,  it is suggested that a separate production be
used  to  create  the  appropriate  reconsider  preference  and  terminate  the
operator.    By  using  a  separate  production,  termination  can  be detected
independently of how the operator is applied.  The same production can be  used
to  detect  the  completion  of  external action or an internal simulation.  In
addition, if the operator is initially implemented through problem solving in a
subgoal,  a  separate  termination  production  can  detect  completion  of the
operator both before and after chunking.  When the operator is implemented in a
subgoal,  the  production  that  creates the reconsider preferences acts as the
goal test for the subgoal, detecting when the operator  has  been  successfully
implemented.    Later,  it  fires  directly after the chunks that implement the
operator, terminating the operator immediately.



3.10.11. Subgoaling and default productions
As mentioned previously, there are multiple move-block operators  proposed  for
each  state. Without the search-control productions that create preferences for
the operators, Soar would have  insufficient  knowledge  to  select  among  the
operators.  If we assume that the search control productions do not exist, then
a tie impasse arises.

In response to the tie impasse, Soar creates a  subgoal.  There  exist  default
productions  that  are  sensitive to the tie impasse and they propose a problem
space, called the selection problem space (see Chapter 7 on page 101).   If  no
other  competing  problem  spaces  are proposed, the selection problem space is
chosen.  The operators  of  the  selection  problem  space  evaluate  the  tied
alternatives,  thereby  allowing  preferences  to  be  created  for them.  Once
sufficient preferences are available to distinguish a single  choice,  the  tie
will be broken, and problem solving can continue.

Below is a partial trace of the tie impasse and selection problem space.

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 ((ontop A B) (ontop B table) (ontop C table))
    3   O: O15 (build-tower ((ontop A B) (ontop B C) (ontop C table)))
    4   ==> G: G21 (operator no-change)
    5       P: P22 (blocks-world)
    6       S: S4 ((ontop A B) (ontop B table) (ontop C table))
    7       ==> G: G26 (operator tie)
    8           P: P27 (selection)
    9           S: S28

To  compute an evaluation, an evaluate-object operator is created for each tied
operator.  If no knowledge is available in productions to directly  compute  an
evaluation,  another  no-change impasse will arise to apply the evaluate-object
operator. In  the  associated  subgoal,  called  the  evaluation  subgoal,  the
operator being evaluated can be "tried-out" in a simulation of the task to gain
more knowledge about it.  Conceptually, Soar is looking  ahead  to  investigate
the  effects  of the operator, but is not actually applying the operator to the
top-level state.  Therefore, a copy of the  original  state  is  used  in  this
subgoal,  and  the operator being evaluated is selected and applied with one of
the following results:

   1. Another operator is selected.

      The new state does not match the desired state, and  there  is  only
      one  operator  (or  there  are  multiple  operators, but preferences
      indicate that one of these is superior to the others). This operator
      will be applied to the current state without additional subgoaling.

   2. An impasse occurs.

      The  new state does not match the desired state, and there are again
      multiple acceptable operators from which to select. This is  also  a
      tie impasse, and will result in additional levels of subgoaling.

   3. An evaluation is computed.

      The new state does not match the desired state, but an evaluation is
      available for the state.  The evaluation could be symbolic, such  as
      success  or  failure,  or numeric, such as a specific number on some
      scale.  Task specific knowledge, possibly  encoded  in  Soar  as  an
      operator,  creates  an  augmentation  of  the state of the selection
      space as the  result  of  the  evaluate-object  operator.    Default
      knowledge  is  sensitive  to  the  creation  of  this evaluation and
      terminates  the  specific  instantiation  of   the   evaluate-object
      operator.    This  leads to the selection of another evaluate-object
      operator.  Later, when sufficient evaluations have been computed  so
      that  the  tied  operators  can  be compared, default knowledge will
      create desirability preferences for the operators, breaking the tie.
      Of course, if success is detected, a best preference will be created
      and the tie impasse will be immediately  resolved,  eliminating  the
      need to apply the remaining evaluate-object operators.

In order to perform a lookahead search, additional productions must be created.
Below is a list of the two basic types of knowledge  that  must  be  added  for
lookahead, including examples from the Blocks World.

   1. Lookahead state creation
      The state used for lookahead can not be the exact same state as  the
      one  that  led  to  the  tie  because  the lookahead will modify it.
      Therefore, an internal copy of the state must be created that can be
      modified  during  the lookahead.  Soar contains default knowledge to
      create copies of states for lookahead.  The default  knowledge  must
      be  able  to  detect  that  a  copy  should be made as well as which
      aspects of the state need to be  copied  (see  Section  7.3.2.1  for
      details).    This information is kept on the problem space.  For the
      Blocks World, the following production would be sufficient.

    IF   the goal is to build a tower subgoal, and
         the problem space is named blocks-world,
    THEN augment the problem space to signify that
            the dynamic information in the state
            should be copied in lookahead.

   2. State evaluation
      There  must be some way to evaluate the states of the lookahead.  At
      the least, it must be possible to detect  when  the  goal  has  been
      achieved.    It  may  also  be  possible to compute numeric or other
      symbolic evaluations (such as failure).  See Section 7.3.3  on  page
      110  for  more  details.    For the blocks world, this production is
      necessary because the original  production  that  detects  that  the
      Blocks  World  problem  is  complete only terminates the operator to
      build a tower.    It  does  not  make  the  achievement  of  success
      explicit.

    IF   the goal is an evaluation subgoal, and
         the problem space is named blocks-world, and
         the state is the desired state,
    THEN create an evaluation of that operator with a symbolic
            value of success.

   3. Search control
      If additional knowledge is available to control the  search  in  the
      lookahead,  the  evaluation  will  be computed much faster.  For the
      almost all tasks, a lookahead should avoid unnecessary steps.    For
      the  Blocks  World, it is not desirable to move the same block twice
      in a row because it could always be moved directly in a single step.
      We  can encode this knowledge by adding a production that rejects an
      operator if it will move a block that has just been moved.

    IF   the goal is to build a tower subgoal, and
         the problem space is named blocks-world, and
         there is an acceptable operator that will
             move the block just moved,
    THEN create a reject preference for that operator.

   4. Additional productions might be added  to  avoid  duplicate  states;
      however,  this  requires  remembering,  either  in working memory or
      production  memory,  the  previous  states  encountered  during  the
      lookahead.

Below  is a partial trace of the problem solving using lookahead.  Comments are
included in the trace following semi-colons (;).

    0   G: G1
    1   P: P2 (TOP-PS)
    2   S: S4 (TOP-STATE)
      ;; Initial state has A on B and B and C on the table.
      ;; The goal is to get A on B on C on the table.

    3   O: O15 (BUILD-TOWER)
    4   ==>G: G21 (OPERATOR NO-CHANGE)
    5      P: P22 (BLOCKS-WORLD)
    6      S: S4 (TOP-STATE)
    7      ==>G: G26 (OPERATOR TIE)
    8         P: P27 (SELECTION)
    9         S: S28
    10        O: O33  EVALUATE-OBJECT(MOVE-BLOCK(A TABLE))
      ;; The operator to move A to the table is selected for evaluation.
      ;; The selection was made because all evaluate-object
      ;;     operators are indifferent.

    11        ==>G: G39 (OPERATOR NO-CHANGE)
    12           P: P22 (BLOCKS-WORLD)
    13           S: D41
    14           O: O23 MOVE-BLOCK(A TABLE)
      ;; Operator O23 applies to a copy of the original state.
      ;; Block A is moved to the table.

    15           ==>G: G53 (OPERATOR TIE)
      ;; A Tie-impasse arises between operators to move blocks B and C.
      ;; All operators to move block A have been rejected.

    16              P: P54 (SELECTION)
    17              S: S55
    18              O: O60  EVALUATE-OBJECT(MOVE-BLOCK(B A))
      ;; The operator to move B onto A is selected for evaluation.

    19              ==>G: G69 (OPERATOR NO-CHANGE)
    20                 P: P22 (BLOCKS-WORLD)
    21                 S: D71
      ;; A copy of the original lookahead state is created.

    22                 O: O51 MOVE-BLOCK(B A)
      ;; Move B onto A is selected and applied.
      ;; The only operator that is acceptable and not rejected is moving
      ;;    C on B.

    23                 O: O81 MOVE-BLOCK(C B)
    24                 ==>G: G84 (STATE NO-CHANGE)
    25                    ==>G: G85 (GOAL NO-CHANGE)
      ;; Operator O51 (MOVE-BLOCK) evaluates to FAILURE because
      ;;    there are no operators available once C is on B.  There is no
      ;;    progress that can be made, so default productions create the
      ;;    FAILURE evaluation.

    27              O: O62 EVALUATE-OBJECT(MOVE-BLOCK(C B))
      ;; Operator O60 is terminated and an new evaluate-object operator is
      ;;    selected.

    28              ==>G: G90 (OPERATOR NO-CHANGE)
    29                 P: P22 (BLOCKS-WORLD)
    30                 S: D92
    31                 O: O52 MOVE-BLOCK(C B)
    32                 O: O98 MOVE-BLOCK(A C)
    33                 ==>G: G105 (STATE NO-CHANGE)
    34                    ==>G: G106 (GOAL NO-CHANGE)
      ;; Another dead-end is encountered, leading to failure.

    36              O: O58 EVALUATE-OBJECT(MOVE-BLOCK(B C))
    37              ==>G: G111 (OPERATOR NO-CHANGE)
    38                 P: P22 (BLOCKS-WORLD)
    39                 S: D113
    40                 O: O50 MOVE-BLOCK(B C)
    41                 O: O118 MOVE-BLOCK (A B)
      ;; Operator O50 is found to lead to success and gets a best preference.
      ;; One chunk (P109) is built for this result.

      ;; The success for O50 is passed up as best preference for O23.
      ;; One chunk is built for this result (P110).

    42     O: O23  MOVE-BLOCK(A TABLE)
    43     O: O131 MOVE-BLOCK(B C)
      ;; Chunk P109 fired to select moving B on to C.

    44     O: O129 MOVE-BLOCK(A B)
    45  O: O6 (WAIT)
      ;; BUILD-TOWER is terminated, allowing WAIT to be selected.



3.10.12. Chunking
When chunking is used, the termination of a subgoal due to the  creation  of  a
result  is  an  opportunity for Soar to learn a new production, called a chunk.
For each result generated in the subgoal, a new production will be  created  by
the  architecture.  Chapter  5  on page 69 has more details on chunking. In the
Blocks World, these chunks will contain knowledge  about  the  preferences  for
selecting operators.

Below  is  a sample chunk (P109) that was learned during the lookahead and used
during the final execution:

    IF   the goal is named build-tower, and
         the problem space is named blocks-world, and
         the current state and the desired state have three blocks
            with one of them in its
            desired position and clear, and
         there is an operator that moves a block into its
            desired position on top of the first block,
    THEN create a best preference for that operator.

This chunk correctly suggests moving the second block (B) into place  when  the
bottom block (C) is in place.

Once  created,  the chunk is added to the production memory, and is thenceforth
equal in status to all other productions,  i.e.,  it  will  fire  whenever  its
conditions  are  met.  As  Soar  gains experience in the domain, chunks will be
created.  With enough experience, Soar  will  have  learned  enough  about  the
Blocks  World  to  avoid  the need for the evaluation subgoal and the selection
problem space.  This illustrates that Soar is able  to  learn  its  own  search
control rules when these are not provided by the user.
4. Syntax of the Symbol Level
This  chapter  describes  the  syntax  of  the symbol level computational model
supported by Soar.  It should serve as a reference manual for the syntax of the
Soar  architecture,  except for chunking and I/O which are described separately
in the following chapters.  This chapter starts  with  the  representation  and
access  of  the  memory  structures,  followed by a description of impasses and
subgoals.

All long-term knowledge in Soar is encoded  as  productions  and  stored  in  a
production  memory,  also known as recognition memory.  Productions are similar
to if-then statements in conventional programming languages: the "if" part of a
production  is  called  the  condition  side, and the "then" part is called the
action side. All short-term knowledge in Soar is stored in  a  working  memory.
The  working  memory  holds  all  of the data describing the current situation,
either retrieved from  productions,  or  acquired  from  sensors.    Production
conditions  are  matched against the contents of working memory to determine if
the knowledge contained in their actions is relevant.    These  conditions  are
patterns  that  test for the presence or absence of elements in working memory.
The actions of productions create preferences for changes to  the  contents  of
working memory.

Production  systems,  also  known  as  rule-based  systems,  are often used for
applications in the areas  of  artificial  intelligence,  expert  systems,  and
cognitive psychology.  However, Soar's use of productions differs significantly
from these traditional approaches.  In most of these  applications,  the  basic
act  of  the  system is to choose a single production to fire next.  In systems
like OPS5, the successful match of more than  one  production  against  working
memory  results  in  only  a  single production instantiation being selected to
fire, by a process called conflict resolution.  This makes production selection
the  locus  for  control.    In Soar, all matched productions fire in parallel,
creating preferences for objects  such  as  operators;  these  preferences  are
evaluated  to  determine  the  actual contents of working memory.  The locus of
control is the selection of an operator, not the  selection  of  a  production.
Additional  differences,  such  as  the  retraction  of  actions and the use of
preferences to indirectly modify working memory, further distinguish Soar  from
traditional production and rule-based systems.

4.1. Working memory
Working memory contains all of the temporary knowledge available for cueing the
retrieval of long-term knowledge from production memory and initiating  actions
in the external environment.  Working memory is organized into objects, each of
which has a unique symbol called its identifier.  An object consists of  a  set
of  augmentations  and  preferences for those augmentations.  Augmentations and
acceptable preferences for context augmentations are working  memory  elements,
because they are in working memory and can be matched by productions.



4.1.1. Objects and augmentations
An  augmentation  is a list consisting of four symbols: a class, an identifier,
an attribute, and a value, where the attribute is preceded by an up-arrow (^).

    (class identifier ^attribute value)

Soar distinguishes between two types of symbols: identifiers and constants.  An
identifier is a symbol that appears in the identifier field of an augmentation.
All augmentations of the same object have  the  same  identifier.    The  exact
symbol  used  as  an  identifier  is  arbitrary,  and  can  not be matched in a
production except by a variable.  When an object is created, the identifier  is
generated automatically.  The format of an identifier is a letter followed by a
number.  For example, "g1" has the correct identifier format and  would  be  an
identifier if it was generated as the identifier of a new augmentation.

A  constant  is  any  symbol,  number,  or  string  that  is not an identifier.
Therefore blue, 545, and "Good morning" will always be  constants.    A  symbol
such  as  s11,  can  be  used  as  a constant or as an identifier, depending on
whether or not it appears in the identifier field of an augmentation.

Within an augmentation, the class must be a constant.   The  identifier  is  an
identifier.    The  attribute and value can be either identifiers or constants.
One restriction is that  neither  the  attribute  nor  the  value  can  be  the
identifier of a goal.  Below is an example of five augmentations that share the
same identifier.

    (thing o43 ^color red)
    (thing o43 ^inside o53)
    (thing o43 ^isa apple)
    (thing o43 ^size small)
    (thing o43 ^x44 200)

An object consists of all the augmentations (and  the  associated  preferences)
that  share  a  common  identifier.   Augmentations that share identifiers must
share the same class.  The augmentations (and preferences) for  an  object  can
also  be  represented  in a single list that consists of a class, an identifier
followed by an un-ordered set of attribute-value pairs, one pair  for  each  of
the  augmentations.   To distinguish attributes from values, all attributes are
preceded by an up-arrow (^). A single attribute may  be  followed  by  multiple
values, each of which correspond to a separate augmentation.  An attribute with
multiple  values  is  called  a  multi-attribute.        These  two  styles  of
representation,   individual   augmentations   and   an   object   followed  by
attribute-value pairs, are equivalent.  Below is a template  of  an  object  as
well  as  four  example objects. The first example object is the same as object
o43 shown above.

    (class identifier ^attribute1 value1 ^attribute2 value2 value3
           ^attribute2 value4...)

    (thing o43 ^isa apple ^color red ^inside o53 ^size small ^x44 200)
    (measure x44 ^unit grams ^property mass)
    (thing o87 ^isa ball  ^color red ^inside o53 ^size big)
    (thing o53 ^isa box  ^size large ^color orange ^contains o43 o87)

When the value or attribute of an augmentation is the identifier of an  object,
the identifier creates a one-way link from the object with the augmentation, to
the object with the identifier. For example, object x44 is linked to object o43
through  (thing  o43  ^x44 200), and object o43 is linked to object o53 through
(thing o53 ^contains o43).  Links are transitive so that x44 is linked to  o53.
However, objects o43 and o87 are not linked together even though they both have
o53 as a value.  Links must involve an augmentation that shares its  identifier
with  the  attribute or value on another object. All elements of working memory
must be linked directly (through a single augmentation) or indirectly  (through
multiple augmentations) to the context stack.



4.1.2. Goal contexts
Problem  solving  in  Soar is controlled by goal contexts.  A goal context is a
particular goal, problem space, state, and operator that defines Soar's current
position in problem solving for the goal.  Subgoals and subcontexts are created
when there is an impasse in the problem solving of a goal (see Section 3.6.1 on
page  13).    The subgoal itself can have impasses, leading to a context stack.
If there are multiple contexts in the context stack, none is  distinguished  as
being  the  current  context.  Progress can be made in any context if knowledge
becomes available.

In working memory, each goal context is represented by three  augmentations  of
the  goal  identifier  for  each  of  the  following: problem space, state, and
operator.    These augmentations define context  slots  in  which  the  current
problem  space,  state,  or  operator  of  the  goal  can  be  selected.  These
augmentations are of class goal.  If an object has not yet been selected for  a
slot,  no  augmentation  for  that  slot  will be in working memory.  A goal is
connected to other goals through the  ^object  attribute  whose  value  is  the
identifier of the supergoal.

Below  is  an  example of the augmentations that define a goal context where an
operator has not yet been selected, and a subgoal in which all of  the  context
slots are filled:

    (goal g12             ^problem-space p14 ^state s17)
    (goal g21 ^object g12 ^problem-space p34 ^state s47 ^operator o48)



4.1.3. Preferences
Preferences  determine the contents of working memory.  Preferences are created
by productions and assert the relative or absolute worth of  a  specific  value
for  an  augmentation. The preferences for a given identifier and attribute are
analyzed to determine the value (or values) for  the  augmentation  in  working
memory.  The details of the semantics of preferences and how they are processed
are described in Section 3.4 on page 10.

A preference is a list, where the first four elements correspond to the  class,
identifier, attribute and value of an augmentation.  In a preference, the value
is followed by a fifth symbol which  is  called  the  preference  type.      It
provides  a  relative  or  absolute  rating  of the worth of the value for that
augmentation.  If the preference type is a relative rating comparing the  value
to  some other object, the identifier of that object is the sixth symbol in the
preference.   Below is an example preference that object o5 is better  than  o4
as the operator for goal g1.

    (goal g1 ^operator o5 > o4)

For non-context augmentations, the preferences that will be used most often are
acceptable, reject, and parallel.  An acceptable preference is used to  suggest
and  create  an  augmentation  (assuming  no  other  preferences);  a  parallel
preference is used to  specify  that  multiple  values  for  an  attribute  are
allowed; and a reject preference is used to remove existing values.

4.2. Production memory
Syntactically,  each  production  has  three  required  components:  a  name, a
condition-side, and an action-side. An optional string of text can be  included
following  the  name  as  a  comment.  Expanded, each production consists of an
opening parenthesis; the symbol sp; the production's name; an optional  comment
string;  the production's conditions; the symbol -->; the production's actions;
and a closing parenthesis.  Below is a template for a Soar production.

    (sp name
        "Comment string"
           CONDITIONS
    -->
           ACTIONS)

Soar productions can either be loaded in by a user or be produced by the system
itself (i.e., chunks from chunking).



4.2.1. The semantics of productions
Preferences  created by the actions of productions are maintained in preference
memory as long as they receive support.  Soar distinguishes two different roles
for  its long-term knowledge, each of which provides different types of support
for preferences.

One role for long-term knowledge is to retrieve data relevant  to  the  current
situation.    For example, productions that propose or control the selection of
problem spaces, initial states, and  operators  all  retrieve  structures  from
long-term  memory  that  are  relevant  to the current context.  If the current
context changes such that a  production  no  longer  matches,  the  preferences
created  by  the  production will not be relevant.  Similarly, productions that
refine the current problem space, state, or operator and their sub-objects fall
into  this  category.    Production  instantiations  representing  this type of
knowledge provide I-support for the preferences in their actions as long as the
conditions of the productions are satisfied.  The I-support is removed when the
production no longer matches.    If  a  preference  has  no  remaining  support
following a retraction, it will be removed from preference memory.

The  other  role for long-term knowledge is to retrieve the changes that should
be made to the current situation based  on  the  current  operator  and  state.
Operator  application and operator instantiation through refinement are the two
PSCM operations carried out  by  these  productions.    The  actions  of  these
productions  make changes to the context that persist even after the production
is no longer satisfied  by  providing  O-support  for  their  actions.    These
productions  are  syntactically  distinguished  by  the fact that they test the
operator and the state in their  conditions  and  they  create  preferences  to
modify  either  the operator or the state in their actions.  A preference keeps
its O-support until its value is rejected, it becomes unlinked from the context
stack,  or  the  subgoal in which it was created terminates. See Section 3.3 on
page 10 and Section 3.6.3 on page 13 for complete details  of  the  support  of
preferences.



4.2.2. The condition side
Conditions  are  the patterns that are matched against working memory elements.
A single condition is a template for matching an object in working memory.    A
condition  is  a  list, beginning with a class name, and followed by a variable
for the identifier and a set of attribute-value pairs.    The  class  name  and
attributes  are  typically  constants  but  may be variables.  The value can be
either constant or variable.  A production can test  the  augmentations  of  an
object  by  having  a  set  of  conditions  where  each  condition  tests  each
augmentation independently, a single condition that tests all augmentations  as
a  set  of  attribute-value  pairs,  or some combination.  The semantics of the
tests are the same in all cases.

A production is satisfied when  all  of  its  conditions  are  matched  against
elements in working memory so that there is a consistent binding for all of the
variables that appear in the production.  A single production can be  satisfied
with more than one consistent binding of its variables, giving rise to multiple
production instantiations.  Below  is  a  partial  example  of  a  production's
conditions.

    (sp blocks*example-production-conditions
      (goal <g> ^problem-space <p> ^state <s> ^operator <o>)
      (problem-space <p> ^name blocks-world)
      (state <s> ^table <t1>)
      (table <t1> ^color << red blue >> )
      ...
      -->
      ...
    )


4.2.2.1. Linked conditions
One  important constraint on productions is that the conditions must be linked,
via augmentations, from one of the goals  or  impasse  objects  tested  in  the
production.  Augmentations are one-way links, from an augmentation's identifier
to its value.  If all conditions are not linked, a warning will be printed when
the  production  is  loaded.    In  the  production  above,  the  problem space
blocks-world is linked to the context because <p> is the value of  the  problem
space  augmentation  of  the  goal.    The  table  <t1>  is  linked to the goal
indirectly through the state.


4.2.2.2. Acceptable preferences
Only acceptable preferences for the context  slots  exist  in  working  memory.
That  is, most preferences cannot be examined by matching them with conditions.
Acceptable preferences for problem spaces, states, and operators can be matched
in  a  condition  by  testing  for  a  "+"  following the value.  This allows a
production to test the properties of a object, and possibly create a preference
for  it,  before  it  is  selected  for  a  context slot. In the example below,
^operator <o> + matches the acceptable preference for the operator augmentation
of  the  goal,  while  ^state <s> tests that state <s> has been selected as the
current state for the goal.

    (sp blocks*example-production-conditions
      (goal <g> ^problem-space <p> ^state <s> ^operator <o> +)
      (problem-space <p> ^name blocks-world)
      (state <s> ^table <t1> ^ontop <c1> { <> <c1> <c2> })
      (table <t1> ^color << red blue >> )
      (operator <o> ^name move-block)
      ...
      -->
      ...
    )


4.2.2.3. Variables
A variable is a symbol that begins with a left angle-bracket  (i.e.,  <),  ends
with  a  right  angle-bracket (i.e., >), and contains at least one alphanumeric
symbol in between.  For a production to be satisfied, all  occurrences  of  the
same  variable  must match the same symbol or number.  In the previous example,
<p> must match the same  value  in  the  first  and  second  conditions.    Two
different  variables can match the same symbol unless there is an explicit test
that they are not equal (using <>).  In the example, <p> and  <s>  could  match
the  same  symbol, although it is unlikely.  In contrast, <c2> cannot match the
same symbol as <c1>. Below are legal variables in Soar.
    Legal variables                         Illegal variables
    <p>                                     <>
    <1>                                    <1
    <variable1>                            variable>
    <abc1>                                 <a b>


4.2.2.4. Disjunctions of constants
If a set of symbols are contained within double angle brackets  (i.e.,  <<  and
>>),  the  condition  will  match  a working memory element that has any one of
those symbols.  Variables cannot occur within a disjunction.    There  must  be
spaces separating the brackets from the symbols in between them.  For instance,
in the previous example, the state's color attribute must have blue or  red  as
the value for the production to match.
    Legal disjunctions                      Illegal disjunctions
    << A B C 45 I17 >>                      << <A> A >>
    << Good-morning Good-evening >>        <<A B C >>


4.2.2.5. Predicates
There  are  six predicates that can precede constants or variables: <>, <=>, <,
<=, >=, >.  (For example: <> <a>.)

    <>          Not  equal.    Matches  anything  except  the  constant  or
                variable   immediately  following  it.    In  the  previous
                production example, it is used to  force  <c2>  to  be  not
                equal to <c1>.

    <=>         Same  type.    Matches  any  symbol  that  is the same type
                (numeric  or  symbolic)  as  the   constant   or   variable
                immediately following it.

    <           Numerically less than.

    <=          Numerically less than or equal to.

    >=          Numerically greater than or equal to.

    >           Numerically greater than.

In  general,  the  use  of such predicates is strongly discouraged in Soar.  An
assumption in Soar is that all relationships should be  represented  explicitly
in  working memory by augmentations.  Thus, inequality, and even equality tests
between two values of  independent  augmentations  should  be  avoided.    This
assumption  is  explicit  in chunking, which does not examine the conditions of
the productions it chunks over.  Therefore, all of the predicate tests are lost
in  the  chunk,  and  only  the  exact  value is included.  If the predicate is
explicitly represented as a relation between two  objects  in  working  memory,
chunking will capture that abstract relationship and create a much more general
chunk.
    Legal predicates                        Illegal predicates
    > <valuex>                             > > <valuey>
    < 1                                    1 >


4.2.2.6. Conjunctive conditions
To signify conjunctive combinations of tests for a single field, the tests  are
contained within curly braces (i.e., { and }).  For a match to occur, all tests
within the braces must succeed.  This is used in the example to match  <c2>  at
the same time the test is made that the value is not <c1>.
    Legal conjunctions                      Illegal conjunctions
    { <x> > <y> }                          { > > <b> }
    { <> <x> <y> }                         { - <yx> }
    { << A B C >> <x> }
    { <=> <x> > <y> << 1 2 3 4 >> <z> }


4.2.2.7. Negated conditions
In  addition  to  the positive tests for elements in working memory, conditions
can also test for the absence of patterns.  A  condition  preceded  by  a  dash
(i.e.,  -)  is  called  a negated condition and will be satisfied only if there
does not exist a working memory element consistent with its tests and  variable
bindings.    A  negation  can precede only a single augmentation, not an object
with multiple augmentations.  A negation can be used within a object with  many
attribute-value  pairs  by  having it precede an attribute.  Negated conditions
cannot include a disjunction, such as << a b c >>.

The first negated condition in the following example tests for the absence of a
desired state on the goal.  The second tests for the absence of blocks-world as
the problem space.  The production will match only if there is a goal that  has
neither a desired state nor a problem space named blocks-world.

    (sp blocks*propose-operator*move-block
      (goal <g> ^problem-space <p> ^state <s> -^desired)
     -(problem-space <p> ^name blocks-world)
      -->
      ...
    )


4.2.2.8. Negated conjunctions of conditions
Conditions  can  be  grouped  into  conjunctive  sets by surrounding the set of
conditions with { and }.  The production compiler  groups  the  test  in  these
conditions  together.   This grouping allows for negated tests of more than one
working memory element at a time.  In the example below, the state is tested to
ensure  that  it  does  not  have  an  object  on  the table.  If only the last
condition, (thing <bo> ^type table) were negated, the  production  would  match
against  any  object  that was not of type table, instead of matching only when
the state has no ontop relation with a table on the bottom.

    (sp blocks*negated-conjunction-example
      (goal <g> ^problem-space <p> ^state <s>)
      (problem-space <p> ^name blocks-world)
    -{(state <s> ^ontop <on>)
      (ontop <on> ^bottom-object <bo>)
      (thing <bo> ^type table)}
      -->
      ...
    )



4.2.3. The action side
If a production's entire condition side is satisfied by working memory elements
with  consistent  variable  bindings,  the  production will fire, once for each
instantiation.  Firing the production involves performing the actions using the
variable  bindings  obtained from the matched conditions.  The action side of a
production can contain  either  preferences  for  working  memory  elements  or
production  actions.    The processing of preferences is discussed in detail in
Section 3.4 on page 10.


4.2.3.1. Creating preferences
Below are the 13 types of preferences as they can appear in the  actions  of  a
production (<id>, <value1>, and <value2> are variables):

    (class <id> ^att <value1>)             acceptable
    (class <id> ^att <value1> +)           acceptable

    (class <id> ^att <value1> !)           require
    (class <id> ^att <value1> ~)           prohibit
    (class <id> ^att <value1> -)           reject
    (class <id> ^att <value1> > <value2>)  better
    (class <id> ^att <value1> < <value2>)  worse
    (class <id> ^att <value1> >)           best
    (class <id> ^att <value1> <)           worst
    (class <id> ^att <value1> =)           unary indifferent
    (class <id> ^att <value1> = <value2>)  binary indifferent
    (class <id> ^att <value1> &)           unary parallel
    (class <id> ^att <value1> & <value2>)  binary parallel

    (class <id> ^att <value1> @)           reconsider

The  action  side can have more than one value and associated preference for an
attribute at a time.  Ambiguity can arise when using a preference that  can  be
either  binary or unary:  > < = & +.  The default assumption is that if a value
follows the preference, then it is binary.  It will be unary if an up-arrow,  a
closing parenthesis, or a comma follows it.  To allow for more concise actions,
multiple preferences types that are for the same value can be listed  following
the  value,  separated  by  commas.  Below are four examples of legal, although
unrealistic, actions that have the same effect.

    (state <s> ^ontop <on1>, <on2> +, &, <on2> < <on1>, <on3> =, <on4>)
    (state <s> ^ontop <on1> + <on2> + <on2> &,
                <on2> < <on1> <on3> =, <on4> +)
    (state <s> ^ontop <on1> <on2> <on2> &, <on2> < <on1>, <on4>,
            <on3> =)
    (state <s> ^ontop <on1> ^ontop <on2> <on2> &
               ^ontop <on2> < <on1> ^ontop <on4> <on3> =)

As shown in the following example, productions create preferences.   Logically,
all  creations  in  a  single  production  occur  in parallel and all satisfied
production instantiations fire in parallel, with the changes to working  memory
made after all preferences from the productions have been collected.

    (sp blocks*propose*operator*move-block*destination
      (goal <g> ^problem-space <p> ^state <s>)
      (problem-space <p> ^name blocks-world)
      (state <s> ^object-dynamic <blockA-dyn>
                  { <> <blockA-dyn> <blockB-dyn>})
      (object-dynamic <blockA-dyn> ^object-static <blocka> ^clear yes
                      -^ontop <blockb>)
      (object-static <blocka> ^type block)
      (object-dynamic <blockB-dyn> ^object-static <blockb> ^clear yes)
      -->
      (operator <o> ^name move-block
                    ^moving-block <blocka> ^destination <blockb>)
      (goal <g> ^operator <o> +))

All  of  the  identifiers  used  in  preferences  created in the a production's
actions must be linked directly or indirectly  to  a  goal  context.    In  the
example,  <o>  is  linked  via  the  acceptable  preference  for  the  operator
augmentation, and all of its substructure, such as ^moving block  <blocka>,  is
linked via augmentations of <o>.  If identifiers of the actions are not linked,
a warning is printed when the production is compiled.

A  variable  that  appears  only  in  the  action  side,  such  as  <o>,   will
automatically  be  bound to a new, "gensymed" symbol that begins with the first
letter of that variable (e.g., <o> might be bound to o234).    This  symbol  is
guaranteed to be unique and it will be used for all occurrences of the variable
in the action side.

One important issue in generating new symbols is determining whether  a  symbol
is  an identifier or a constant.  During chunking, identifiers will be replaced
by variables in the conditions and actions of the chunk, while a constant  will
remain  unchanged.    The  new symbol will be treated as an identifier if it is
used in the identifier position in any of the actions (or later actions).    It
will  be treated as a constant if it only appears as an attribute or value, but
not as an identifier.


4.2.3.2. Production actions
In addition to creating preferences, a Soar production can have a small set  of
actions.    The only ordering of actions is between multiple writes and accepts
within a single production.  Although write1 and write2 are provided as actions
in  Soar,  they  should  be used for only simple monitoring or debugging.  Text
input and output, as described in Chapter 6 on page 77, should be used for  all
other interaction using text.

bind arg1 arg2  Binds  the  value  for arg2 to arg1.  The first argument (arg1)
                must be an unbound variable.    The  second  (arg2)  can  be  a
                previously  bound  variable, a constant, or an action function,
                such as compute or accept.

                (bind <input> (accept))

call2 F *       Applies function F to the other arguments.   F  and  any  other
                arguments can be variables, bound to appropriate values.

                This  function is provided to help a production control some of
                the top-level  user  functions,  such  as  watch,  user-select,
                decide-trace, and learn.

                (call2 watch 2)

halt            Stops Soar's execution.

                (halt)

tabstop arg1    Binds  the  current  tabstop being used by write1 and write2 to
                the variable, arg1.

                (tabstop <tab>)
                (write1 (tabto <tab>) <o> |x|)

                If  <tab> is bound to 3 and <o> is bound to 4, the result would
                be:

                   4 x

write1 *        Writes each of its arguments followed by a space:

                (write1  <o> |x|)

                The result would be:

                4 x

write2 *        Performs the same function as write1, except  that  spaces  are
                not automatically inserted between atoms, so that character-by-
                character output may be performed.

                (write2 <o> |x|)

                The result is:

                4x


Within a Soar action, the following functions can be used.

accept          Suspends  Soar's  execution  and  waits for the user to type an
                atom.  The result of accept is  that  atom.  In  general,  text
                input should be used instead of accept.

                (state ^input (accept))

compute         Evaluates  arithmetic  expressions  using the five operators: +
                (addition), - (subtraction), * (multiplication), /  (division),
                and  \\  (modulus).    Processes  both integers and reals. Only
                numbers and Soar variables bound to  numbers  can  be  used  in
                expressions.    The  expressions  are  evaluated using standard
                infix notation, but there  is  no  operator  precedence.    The
                operators  are  evaluated right to left, except when overridden
                by parentheses.

                (state ^sum (compute <x> + <y>)
                       ^product-sum (compute (<v> + <w>) * (<x> + <y>)))

crlf            Short for "carriage return, line feed", this  function  can  be
                called  within  write1  or  write2. It forces a new line at its
                position in the write action.

                (write1 <x> (crlf) <y>)

tabto           This function can be called within write1 or write2.  It  takes
                one  argument  that  is  a column number.  The column number is
                either a constant, such as 5, or a Soar  variable  bound  to  a
                number.    It  modifies the write so that it begins printing at
                the column given as  its  argument,  with  the  first  printing
                column being column 1.



4.2.4. Efficiency issues
The  performance  of  Soar  is greatly influenced by its ability to efficiently
match productions.  This section  describes  the  sources  of  inefficiency  in
Soar's  production  system  and methods for coping with these sources. For more
details, see [Tambe and Newell 88a, Tambe and Rosenbloom 89].

The match cost of a production is determined by the number of tokens or partial
instantiations generated in matching it.  The most expensive productions can be
identified using the memories command (described in Section 9.17.2 on page 178)
which  prints  out  a  list of productions with the most tokens for the current
working memory. The number of tokens required to match  a  specific  production
for  the current working memory can be determined by using the smatches command
(described in Section 9.9.7 on page 169).    Productions  with  more  than  200
tokens can slow down the system and warrant correction if possible.

Another  method  of  detecting  expensive productions is to use the print-stats
function (described in section 9.10.1 on page 170) at the end of  a  run.    In
terms  of  efficiency,  print-stats  provides  a  useful  measure:  changes per
action.  A large number of changes per action  may  indicate  the  presence  of
expensive chunks.

There  are  three  factors that contribute to the cost of matching a production
against working memory:

   1. Multi-attributes:  Multi-attributes  in  a  condition  can  cause  a
      combinatorial  explosion  of  tokens in the match because the set of
      values tested can match  in  many  permutations  of  working  memory
      elements.

   2. Bad  condition ordering: The order of the conditions in a production
      influences the number of tokens. A sub-optimal ordering can cause an
      increase in the number of tokens required for matching a production.
      Soar automatically orders conditions in order to minimize the number
      of tokens.

   3. Number  of  conditions:  This factor can only compound the impact of
      the other factors listed above.  We will therefore not focus on this
      particular factor.

To  reduce  the  combinatorics  caused  by  multi-attributes, objects should be
represented so that multi-attributes are  used  as  infrequently  as  possible.
Typically,  multi-attributes are used to represent unstructured sets in working
memory, and therefore it may not be immediately obvious as to  how  to  replace
them.   One method is to use structured objects, such as linked lists or trees,
instead of the sets.

If multi-attributes must be used, their effect can  be  minimized  by  ordering
conditions  so  that  they  are  tested only after other conditions.  Condition
ordering is done by Soar's reorderer  and  the  user  can  provide  information
concerning  the  multi-attributes  used  in  the  representations.  To tell the
reorderer about multi-attributes, use the multi-attributes function.    In  the
Blocks  World  example  used later, ^object-dynamic is a multi-attribute of the
state and desired state.

    (multi-attributes  '((state object-dynamic) (desired object-dynamic)))

Finally, if a program creates many tokens, and sufficient memory is  available,
the  global  variable  *mem-array-size*  (see Section 9.1.5 on page 150) can be
increased, immediately following a  call  to  the  function  restart-soar  (see
Section  9.2.2  on  page  151).    This  variable controls the amount of memory
available for hashing partial instantiations (the  alternative  to  hashing  is
linear  search,  which is much slower).  The value of the variable is initially
10.  Note that the value can be decreased if memory constraints are a  limiting
factor, rather than number of tokens.

4.3. Impasses and subgoals
Impasses  can  arise  for all augmentations.  There are four types of impasses.
Three of these can arise for any augmentation when  the  available  preferences
for  an  attribute  either  are insufficient or conflicting (tie, conflict, and
constraint failure).  The remaining impasse, no-change, arises only  when  none
of  the  context slots are changed during the decision procedure.  This impasse
arises from the inability to make progress with any  of  the  contexts  in  the
context stack.  Below is a short description of the four types of impasses.

   1. tie:  when  there  is  a  collection  of  equally  eligible  objects
      competing for a particular context slot;

   2. conflict: when two or more objects are better than each  other,  and
      they are not dominated by a third object;

   3. constraint-failure:    when    there   are   conflicting   necessity
      preferences.

   4. no-change: when the elaboration phase  runs  to  quiescence  without
      suggesting any change to the context;

An  impasse  is  resolved whenever a decision can be made for the corresponding
attribute.  For example, if there is a tie impasse  between  two  objects,  the
impasse  will be resolved when a new preference is added to working memory that
prohibits one of the choices, rejects one of the choices, requires one  of  the
choices,  makes  one  a best choice, makes one better than another, makes one a
worst choice, or makes them both indifferent.  If there is a tie between  three
objects,  the  tie  will  be  broken  when  one  of  the  objects  (or a set of
indifferent objects) dominates the others.  So the impasse will be resolved  if
a  best  or require preference is created for one of the objects, if one object
is made better than the other two, and so on.



4.3.1. Goal and impasse object augmentations
When Soar detects an impasse for a context slot, it responds by creating a  new
goal  (see  Section  3.6 on page 13 for more details on subgoals, impasses, and
the results of subgoals).  When Soar  detects  an  impasse  for  a  non-context
augmentation,  it  responds  by creating an impasse object.  These two types of
impasses are distinguished by the  class  of  the  objects  created  (goal  and
impasse).    They  are also distinguished by the fact that the goal becomes the
basis for a new context, where problem spaces, states,  and  operators  can  be
selected  following  quiescence.    The  impasse  object is just like any other
object, except that it is not linked to the context.

In spite of these differences, both a goal and an impasse  object  are  created
with  the  same  augmentations  that describe the impasse responsible for their
creation.  The list below gives the six  augmentations  that  the  architecture
creates,   and   the  values  that  each  augmentation  can  contain(Additional
augmentations may be created by productions.).

impasse         Contains the type of  impasse:  tie,  conflict,  no-change,  or
                constraint-failure.

choices         Contains  multiple  (for  tie and conflict impasses), none (for
                no-change impasses),  or  constraint-failure  (for  constraint-
                failure impasses).

object          Contains  the  identifier  of  the  augmentation  for which the
                impasse arose.   For  a  context  impasse,  this  will  be  the
                supergoal.

attribute       For multi-choice and constraint-failure impasses, this contains
                the attribute for which  the  values  were  competing.    In  a
                context   impasse,  this  would  be  problem-space,  state,  or
                operator.  For no-change impasses, this contains the  attribute
                of  the  last  context  slot with a value (goal, problem-space,
                state, or operator).

item            For multi-choice and constraint-failure impasses, this contains
                all  values  involved  in  the  tie,  conflict,  or constraint-
                failure.  If the set of items  that  tie  or  conflict  changes
                during  the  impasse,  the  architecture  removes  or  adds the
                appropriate item augmentations without terminating the existing
                impasse.

quiescence      quiescence  t  is  added  only  to  goals and it is an explicit
                statement that quiescence (exhaustion of the elaboration cycle)
                was  reached  in  the  supergoal.    If  problem solving in the
                subgoal is contingent on quiescence having  been  reached,  the
                subgoal  should  test  this  flag.   The side-effect is that no
                chunk will be built if it depended on that test.   See  Section
                5.1 on page 69 for details.


The following is an example of a goal context that is created for a tie between
three operators:

    (goal g12 ^impasse tie ^choices multiple ^attribute operator
              ^object g3
              ^item o9 o10 o11 ^quiescence t)

The following is an example of a goal context that is created for  a  no-change
impasse to apply an operator as well as part of the super-context:

    (goal g12 ^impasse no-change ^choices none ^attribute operator
              ^object g3 ^quiescence t)
    (goal g3 ^operator o2)

The  following  is an example of an attribute impasse that is created for a tie
between two values of the color augmentation:

    (impasse i12 ^impasse tie ^choices multiple ^attribute color
                 ^object g3
          ^item o9 o10 ^quiescence t)
5. Learning
Chunking is Soar's sole learning  mechanism.    Chunking  creates  productions,
called chunks, that summarize the processing required to produce the results of
subgoals.  Chunks are continuously built as results are  created  in  subgoals.
When  a  chunk  is  built,  it is added to recognition memory, where it will be
matched in similar situations, avoiding the need for the subgoal.

In order for the chunk to apply at the appropriate time,  its  conditions  must
test  exactly  those working memory elements that were necessary to produce the
results of the subgoal.  Soar  computes  a  chunk's  conditions  based  on  the
productions  that  fired during the subgoal.  Chunking begins with the results,
and then backtraces through the productions that  created  the  preference  for
each  result.    It  then  recursively  backtraces  through  the working memory
elements that matched the conditions of the productions, finding the acceptable
preferences  that  led to their creation, etc., until conditions are found that
test elements that are linked to a supergoal.

This chapter begins with a discussion of when chunks are built (Section 5.1  on
this  page), followed by a detailed discussion of how Soar determines a chunk's
conditions and actions (Section 5.2 on page 70).  Sections 5.3 through  5.4  on
page  72  examine the construction of chunks in further detail.  Section 5.5 on
page 72 explains how and why chunks are refracted.   Section  5.6  on  page  73
reviews the problem of overgeneral chunks.

5.1. Chunk creation
Several factors govern when chunks are built.  Soar chunks the results of every
subgoal, unless one of the following conditions is true:

   1. Learning is off.  (See Section 9.15.3 on page  175  for  details  of
      learn.)

      Learning can be on or off.  When learn is on chunks are built.  When
      learn is off, chunks are not built.

   2. Learning is set to bottom-up (using learn as  described  in  Section
      9.15.3  on page 175) and a chunk has been built for a subgoal of the
      goal that generated the results.

      With bottom-up learning, chunks are learned only  in  subgoals  that
      have  not  as  yet  had  other  subgoals.   In this mode, chunks are
      learned only for the ``bottom'' of the subgoal hierarchy and not the
      intermediate  levels.    With experience, the subgoals at the bottom
      will be replaced by the chunks, allowing higher level subgoals to be
      chunked.

   3. The chunk syntactically duplicates a chunk that was previously built
      during the current elaboration cycle.

      Soar detects chunk duplication at the syntactic level, so duplicates
      of   syntactically  distinct  (such  as  with  different  names  for
      variables), but semantically equivalent chunks can be built.

   4. The augmentation, ^quiescence t, of the subgoal  that  produced  the
      result is backtraced through.

      This mechanism is motivated by the chunking from exhaustion problem,
      where the results of a subgoal are dependent on  the  exhaustion  of
      alternatives  (see  Section  5.6  on  page  73).    If  this subgoal
      augmentation is encountered when determining  the  conditions  of  a
      chunk,  then  no  chunk  will  be built for the currently considered
      action.  This recurs, so that if an un-chunked result is relevant to
      a second result, no chunk will be built for the second result.  This
      does not  prevent  the  creation  of  a  chunk  that  would  include
      ^quiescence t as a condition.

   5. The  problem  space  of  the  subgoal  being  chunked  is  listed in
      *chunk-free-problem-spaces*.  The variable is initially NIL.

      This capability is provided for debugging  and  system  development,
      and it is not part of the theory of Soar.

If  a  result  is to be chunked, Soar builds the chunk as soon as the result is
created, rather than waiting until subgoal termination.

5.2. Determining conditions and actions
Chunking is an experience-based learning mechanism that summarizes the  problem
solving  that  occurs  within a subgoal as productions.  In order to maintain a
history of the processing that can be used for chunking, Soar builds a trace of
the  productions  that  fired  in the subgoals.  This chapter describes how the
actions are determined, how information is stored in a trace, and finally,  how
the trace and the actions together determine the conditions.



5.2.1. Determining a chunk's actions
A  chunk's  actions  are  built from the results of a subgoal.  A result is any
preference created in the subgoal that is linked to a supergoal.  A  preference
is  linked  if its identifier is the value of a supercontext preference, or the
value of a preference for an object that is linked to a supercontext.

The results produced by a single production firing are the basis  for  creating
the  actions  of  a chunk.  A new result can lead to other results by linking a
supercontext to a preference in the subgoal. This preference may in  turn  link
other  preferences  in  the  subgoal  to the supercontext, making them results.
Therefore, the creation of a single preference that is linked to a supercontext
can  lead  to  the  creation  of  a  large number of results.  All of the newly
created results become the basis of the chunk's actions.



5.2.2. Tracing the creation and reference of working memory elements
Soar automatically maintains information on the creation of each preference and
working  memory element in every goal.  When a production fires, a trace of the
production is saved with the appropriate goal.   A  trace  is  a  list  of  the
working  memory  elements  matched  by  the  production's  conditions,  and the
preferences created by the production's actions.  The appropriate goal  is  the
most  recently  created  goal  (i.e., the goal lowest in the subgoal hierarchy)
that occurs in the production's matched working memory elements.

Chunking is complicated by the fact that the ^item augmentation of the  subgoal
is  created  by  the  architecture  and not by productions.  Backtracing cannot
determine the cause of these subgoal augmentations in the  same  way  as  other
working  memory elements.  To overcome this, Soar maps these augmentations onto
the acceptable preferences for the objects in the ^item augmentations.

Negated conditions are included in  a  trace  in  the  following  way:  when  a
production  fires,  its  negated  conditions  are  fully  instantiated with its
variables' appropriate values.  This instantiation  is  based  on  the  working
memory  elements  that  matched  the  production's positive conditions.  If the
variable is not used in any positive  conditions,  such  as  in  a  conjunctive
negation,  a  dummy  variable  is  used  that will later become a variable in a
chunk.

If the identifier used to instantiate a negated condition's identifier field is
linked to the supercontext, then the instantiated negated condition is added to
the trace as a negated condition.  In all other cases, the negated condition is
ignored  because  the  system cannot determine why a working memory element was
not produced in the subgoal and thus allowed the production to fire.   Ignoring
these   negations   of   conditions   internal  to  the  subgoal  may  lead  to
overgeneralization in chunking (see Section 5.6 on page 73).



5.2.3. Determining a chunk's conditions
The conditions of a chunk are determined by a dependency analysis of production
traces  -- a process called backtracing.  For each instantiated production that
creates  a  subgoal  result,  backtracing  examines  the  production  trace  to
determine  which  working  memory  elements were matched.  If a matched working
memory element is linked to a supercontext,  it  is  included  in  the  chunk's
conditions.    If  it  is  not  linked  to  a  supercontext,  then  backtracing
recursively examines the trace of  the  production  that  created  the  working
memory  element.    Thus,  backtracing  begins  with  a  subgoal result, traces
backwards through all working memory elements that were used  to  produce  that
result,  and  collects  all of the working memory elements that are linked to a
supercontext.  This method  ignores  when  the  working  memory  elements  were
created,  thus  allowing  the  conditions of one chunk to test the results of a
chunk learned earlier in the subgoal.  The user  can  observe  the  backtracing
process  by  setting  (learn  full-trace).    This  prints  out  a trace of the
conditions as they are collected (see Section 9.15.3 on page 175 for  details).

Certain productions do not participate in backtracing.  If a production creates
only a desirability or reject preference, then neither the preference  nor  the
objects  that led to its creation will be included in the chunk. (The exception
to this is that if the desirability or reject  preference  is  a  result  of  a
subgoal,  it  will  be  in  the  chunk's  actions.)    Desirability  and reject
preferences should be used only as search control for  choosing  between  legal
alternatives and should not be used to guarantee the correctness of the problem
solving.  The  argument  is  that  such  preferences  should  affect  only  the
efficiency  and  not  the correctness of problem solving, and therefore are not
necessary to produce the results.  Necessity preferences (require or  prohibit)
should  be  used to enforce the correctness of problem solving; the productions
that create these preferences will be included in backtracing.

Given that results can be created at any point during a subgoal, it is possible
for  one  result  to  be  relevant to another result.  Whether or not the first
result is included in the chunk for the second result depends on the links that
were  used to match the first result in the subgoal. If the elements are linked
to the supercontext, they are included as conditions.  If the elements are  not
linked  to the supercontext, then the result is traced through.  In some cases,
there may be more than one set of links, so it is possible for a result  to  be
both backtraced through, and included as a condition.

5.3. Variablizing identifiers
Chunks  are  constructed  by  examining  actual  working  memory  elements  and
preferences.  To achieve any useful transfer of chunks, identifiers  of  actual
objects  must  be replaced by variables when the chunk is created.  A symbol is
considered an identifier if it occurs as the identifier in  a  preference.    A
constant  value  is never variablized; the actual value appears directly in the
chunk.

When a chunk is built, all occurrences of the same identifier are replaced with
the  same variable.  This can lead to an overspecific chunk, when two variables
are forced to be the same in the chunk, even though distinct variables  in  the
original productions just happened to match the same identifier.

A  chunk's  conditions are also constrained so that in general, no two distinct
variables can match the same identifier.  The enforcement of this constraint is
not  complete  because  of  the  added  expense  to the matcher required if all
distinct variables must match distinct identifiers.  The architecture  attempts
to  cover  the  most likely cases.  For instance, in the following example, the
variables <g> and <o> are  not  constrained  to  match  different  identifiers,
because  goal  and  operator  objects never share identifiers; however, the two
augmentations of the operator are  forced  to  be  distinct  because  the  same
working memory element could match both of them.

    (sp p145 elaborate
      (goal <g> ^operator <o>)
      (operator <o> ^params <p1> { <> <p1> <p2> })
     -->
    ) ...

Adding  these  constraints  may  also  produce  overspecific  chunks, if it was
correct for distinct variables to match the  same  identifier  in  one  of  the
backtraced  productions.    However, this measure prevents some semantic errors
that might arise if the original conditions forced the identifiers  to  be  not
equal.

5.4. Ordering conditions
Since the efficiency of the matcher (a Rete network) [Forgy 81] depends heavily
upon the order of a production's conditions, the chunking mechanism attempts to
write  the  chunk's conditions in the most favorable order.  At each stage, the
condition-ordering algorithm tries to determine which  eligible  condition,  if
placed  next, will lead to the fewest number of partial instantiations when the
chunk is matched. (The details  of  the  reordering  algorithm  are  in  Scales
(1986).) A condition that matches an object with a multi-attribute will lead to
multiple partial instantiations, so it is generally  more  efficient  to  place
these  conditions  later  in  the  ordering.    The  user can contribute to the
efficiency  of  the  ordering  algorithm  by  providing  information  on  which
attributes  of objects are likely to be multi-attributes (see Section 9.17.1 on
page 178).

5.5. Refractory inhibition of chunks
When a chunk is built, it may be able to match immediately with  those  working
memory elements that participated in its creation.  If the production's actions
include preferences for new objects, the production would immediately fire  and
create  a preference for a new object, which duplicates the preference that was
the original result of the subgoal.  To avoid this,  each  production  that  is
built during chunking is refracted so that it will not fire on the exact set of
working memory elements used to create it.   This  does  not  prevent  a  newly
learned  production  from  matching  other  working  memory  elements  that are
present.

5.6. Overgeneralization
One of the greatest weaknesses of Soar is that chunking can create  overgeneral
productions  that apply in inappropriate situations.  Overgeneralization arises
because chunking is unable to completely summarize the processing that  led  to
the  creation  of  a  result.    Below  is  a  list of the four known causes of
overgeneralization in chunking.

   1. Local negated conditions
      Overgeneral  chunks  can be created when negated conditions test for
      the absence of a working memory element that, if it  existed,  would
      be  local  to  the subgoal.  Chunking does not determine why a given
      working memory element does not exist, and  thus  a  condition  that
      occurred  in  a  production  in  the  subgoal is not included in the
      chunk.  For example, if a production tests  for  the  absence  of  a
      local  flag,  and  that  flag  is  copied down to the subgoal from a
      supercontext, then the chunk should include a test that the flag  in
      the   supercontext   does   not   exist.      Unfortunately,  it  is
      computationally expensive to determine why a  given  working  memory
      element  does  not  exist.   Chunking only includes negated tests if
      they test for the absence of super-context working memory  elements.
      To avoid using negated conditions for local data, the local data can
      be made a result  by  attaching  it  to  the  super-context.    This
      increases  the number of chunks learned, but a negated condition for
      the super-context can be used that leads to correct chunks.

   2. Search control determines correctness
      Overgeneral  chunks can be created if a result of problem solving in
      a subgoal is dependent on search-control  knowledge.    Recall  that
      desirability  preferences, such as better than, best, and worst, are
      not included in the traces  of  problem  solving  used  in  chunking
      (Section  5.2  on  page  23).    In theory, these preferences do not
      affect the validity of search.   In  practice,  however,  a  problem
      space  can  be  implemented  so  that search control does affect the
      correctness of search.  Here are two examples:

         a. Some of the test for correctness of a result  is  included  in
            productions  that  prefer  operators that will produce correct
            results.  The system  will  work  correctly  only  when  those
            productions are loaded.

         b. An  operator  is  given a worst preference, indicating that it
            should  be  used  only  when  all  other  options  have   been
            exhausted.    Because of the semantics of worst, this operator
            will be selected after all other operators; however,  if  this
            operator  then  produces  a  result  that  is dependent on the
            operator occurring after all others, this  fact  will  not  be
            captured in the conditions of the chunk.

      In  both  of these cases, part of the test for producing a result is
      implicit in search  control  productions.    This  move  allows  the
      explicit goal test to be simpler because any state to which the test
      is applied is guaranteed to satisfy some  of  the  requirements  for
      success.    However,  chunks created in such a problem space will be
      overgeneral because the implicit parts  of  the  goal  test  do  not
      appear  as conditions.  To avoid this problem, necessity preferences
      (require and prohibit) should be used whenever a control decision is
      being  made  that  also incorporates goal-attainment knowledge.  The
      necessity preferences are included in  the  backtrace  by  chunking,
      thereby avoiding overgenerality.

   3. Test for subgoal
      Overgeneral chunks can be created  if  a  result  of  a  subgoal  is
      dependent  on  the  creation  of an impasse within the subgoal.  For
      example,  processing  in  a  subgoal  may  consist  of  exhaustively
      applying  all  the  operators  in  the problem space.  If so, then a
      convenient way to recognize that  all  operators  have  applied  and
      processing  is  complete is to wait for a state no-change impasse to
      occur.  When the impasse occurs,  a  production  can  test  for  the
      resulting  subgoal  and  create  a  result for the original subgoal.
      This  form  of  goal  test  builds  overgeneral  chunks  because  no
      pre-existing structure is relevant to the result that terminates the
      subgoal. The result is  dependent  only  on  the  existence  of  the
      subgoal within a subgoal.

      The current solution to this problem is to allow the problem solving
      to signal the architecture that the test  for  a  subgoal  is  being
      made.    The  signal  used  by  Soar is a test for the ^quiescence t
      augmentation of the subgoal.  The chunking mechanism recognizes this
      test and does not build a chunk when it is found in a backtrace of a
      subgoal.  The history of this test is maintained,  so  that  if  the
      result  of the subgoal is then used to produce further results for a
      super-context, no higher chunks will be  built.    However,  if  the
      result  is used as search control (it is a desirability preference),
      then it does not prevent the creation of chunks because the original
      result is not included in the backtrace.  If the ^quiescence t being
      tested is connected to a supergoal, it will not inhibit chunking and
      it will be included in the conditions of the chunk.

   4. Testing multiple values over time
      Overgeneral chunks can be created if the results of  a  subgoal  are
      dependent on multiple values of a single super-context augmentation.
      Consider a simple example of where the ticks of a clock are  counted
      in  the  subgoal  and  the result of the subgoal is to create "bong"
      when sixty ticks have gone by.  The ticks are  created  by  removing
      and  recreating  a  tick  object  in  the  top context, while in the
      subgoal a count of the ticks is maintained.   The  final  result  is
      dependent  on  sixty  different  ticks,  which  each  occurred  at a
      different time.  The chunk that is built will test for sixty  ticks,
      all occurring at once.  The problem is that the relationship between
      the sixty ticks  is  not  represented  explicitly,  but  is  instead
      implicit  in  the  rematching  of the production that increments the
      tick counter.  This particular problem could be solved by explicitly
      representing  the  after  relationship  of  a  tick  to the one that
      occurred before it, creating a linked list of ticks.    The  subgoal
      can  then  test  that  a new tick has occurred after the last one it
      counted, and bump its count. Unfortunately, this requires explicitly
      representing  all  sixty  ticks  at  the top level and the resulting
      chunk will test for a linked list of sixty ticks.  Another  solution
      is  to  make the intermediate count a result of the subgoal and save
      only the two most recent ticks in working memory.  The  intermediate
      count  could have a pointer to the tick used to increment it.  Then,
      sixty chunks will be learned, one for each addition.
6. Input and Output
Soar provides two means of interaction with  the  external  world.    Text  I/O
provides  specifically  for  input  and  output of text, such as words typed in
while Soar is running, or strings printed by  a  Soar  program.    General  I/O
provides an interface that allows user-defined Lisp functions to access working
memory, for example, to send commands to a robot and receive data from a vision
system.

Novice  Soar  users may want to avoid the use of Soar I/O, using functions such
as accept and write1 instead of text I/O (see Section 4.2.3.2 on page 21),  and
completely  foregoing  the use of general I/O.  However, more experienced users
will want to make use of  the  increased  functionality  provided  by  the  I/O
mechanisms.   The use of general I/O requires a good working knowledge of Lisp;
the use of text I/O does not.

6.1. Overview
Input and output should be viewed from Soar's perspective.  An  input  function
adds, alters, or deletes augmentations of the top-level state and provides Soar
with information about some occurrence external to  Soar.  An  output  function
responds  to  a top-level state augmentation produced by production firings and
causes some occurrence external to Soar. Input and  output  occur  through  the
top-level state exclusively.

-------------------------------------------------------------------------------



    Figure 6-1:  Details  of the elaboration phase of a decision cycle.
                 Input functions are called before  the  match  set  is
                 determined  for the preference phase. Output functions
                 are called  after  the  working  memory  phase.  Input
                 functions are also called before quiescence.

-------------------------------------------------------------------------------

As  shown  in  Figure 6-1, input functions are called before the start of every
elaboration cycle.  The preferences created by input  functions  are  processed
immediately  and  change  working memory before the elaboration cycle, possibly
altering the set of productions that match  for  a  particular  cycle.    Input
functions  are  always  called before quiescence, so that new input can trigger
further production firings and forestall quiescence.

An output function is called only if a working-memory element is  created  that
is  an  output structure for that output function.  Output functions are called
after the working-memory phase of every elaboration cycle when  an  appropriate
output structure is created.  Although the output structure may persist through
several elaboration cycles, it will trigger the output function only at the end
of the cycle in which it is created in working memory.

6.2. Text I/O
Although  text I/O is more complicated to use than functions such as accept and
write1, there are three main reasons to use it. First, accept  suspends  Soar's
operation  and  explicitly  waits  while  the  user  types  in information.  In
contrast, text input allows the user to type in data at anytime  and  does  not
interfere  with  the  execution  of  Soar.   Second, when text I/O is used, the
components of the input or output string appear in working memory, which allows
Soar  to  include  the  text  augmentations  in  chunks. For example, a natural
language application might require access  to  individual  words  of  an  input
sentence  in  order  to  interpret  the sentence, and might construct an output
sentence from individual lexical items.

When text output is used only for debugging purposes, write1 and write2 may  be
more appropriate (see Section 4.2.3.2 on page 21).



6.2.1. Text structures
The  top-level  state may have two special augmentations, called the text-input
link  and  the  text-output  link.  The  attributes   associated   with   these
augmentations  are  ^text-input  and  ^text-output  respectively;  the value of
^text-input or ^text-output is the identifier  of  an  object  of  class  text,
called  a  text  object. There will never be more than one text-input link, but
text-output may be a multiattribute.

The collection of augmentations connected to  the  top-level  state  through  a
text-input  link  or  text-output  link  is  called a text structure, and has a
specific form. The text  object  directly  connected  to  the  top-level  state
represents  the  first  item  in  a  line of input or output text. If there are
multiple items in the input or output, they  are  linked  together  with  ^next
augmentations  (see  Section 6.2.4 on page 81); only the first of these will be
directly attached to the top-level state. See Figure 6-2 for an illustration of
a text-input structure.

-------------------------------------------------------------------------------


                  Figure 6-2:  A sample text-input structure.
-------------------------------------------------------------------------------

Text-input  and  text-output  structures  are  similar,  but  there  are  a few
fundamental differences between them. If text input is on, a text-input link is
created  when the first line of text arrives; this one link will be updated and
reused as long as the top-level state doesn't change and text input remains on.
However,  text-output  links  are created through production firings, and a new
text-output link must  be  created  for  every  line  of  text  to  be  output.
Furthermore,  ^text-output  may  be  a multiattribute, so there may be multiple
text-output links at any given time.

The names of the attributes used by text I/O  are  pre-defined  and  cannot  be
changed  by  the user, but the text objects in a text-output structure may have
additional attributes not used by text I/O. For example, an attribute ^previous
may be added to a text-output object to serve as a pointer to the previous word
in an output string. This augmentation would be recognized by Soar productions,
but would be ignored by text output.



6.2.2. The text I/O environment in working wemory
The   top-level   state   has   an   attribute   text-environment,  called  the
text-environment link, that is used to inspect the current text  I/O  settings.
These  settings  determine  the behavior of text I/O, for example, whether text
input is on or off and which stream is used for text input.  A single object of
class  status  is connected to the top-level state through the text-environment
link;  the  attributes  of   this   object   are   ^text-input,   ^text-output,
^text-input-stream,  ^text-output-stream,  ^char-mode,  ^carriage-control,  and
^tab-settings.

The following is an example of the text-environment structure that  is  created
by default (the identifiers may differ):

    (state s3 ^text-environment t14)
    (status t14 ^text-input nil)
    (status t14 ^text-output nil)
    (status t14 ^text-input-stream *standard-input*)
    (status t14 ^text-output-stream *standard-output*)
    (status t14 ^char-mode nil)
    (status t14 ^carriage-control nil)
    (status t14 ^tab-settings nil)

The  top-level  state  may  also  have  an  attribute  text-command, called the
text-command link, that is created via production firings to  change  the  text
I/O settings. A single object of class status is connected to each text-command
link;  this  object  will  contain  a  subset  of   the   attributes   in   the
text-environment.  The attributes changed in the text-command structure will be
reflected in the text-environment structure,  and  will  remain  until  changed
again by the user.

For  example,  a  Soar  production could change all the environment settings by
adding the following to working memory:

    (state <tls> ^text-command <tc>)
    (status <tc> ^text-input t)
    (status <tc> ^text-output t)
    (status <tc> ^text-input-stream *my-input-stream*)
    (status <tc> ^text-output-stream *my-output-stream*)
    (status <tc> ^char-mode t)
    (status <tc> ^carriage-control t)
    (status <tc> ^tab-settings 5 10 15 20)

At the end of the cycle in which these augmentations were produced, the changes
would  take  place,  and are immediately reflected in working memory. Using the
example above, the text-environment structure will now look like:

    (state s3 ^text-environment t14)
    (status t14 ^text-input t)
    (status t14 ^text-output t)
    (status t14 ^text-input-stream *my-input-stream*)
    (status t14 ^text-output-stream *my-output-stream*)
    (status t14 ^char-mode t)
    (status t14 ^carriage-control t)
    (status t14 ^tab-settings 5 10 15 20)

A new text-command link  is  recognized  in  the  output  cycle  following  the
elaboration  cycle  in  which it is created, and will be ignored by text I/O in
all future output  cycles.  To  change  the  settings  a  second  time,  a  new
text-command  link must be created. If more than one text-command link is added
in the same elaboration  cycle  (using  parallel  preferences),  each  will  be
processed   individually,  and  in  an  arbitrary  order.  Thus,  if  two  such
text-command links contain conflicting information, whichever one happens to be
processed last will be the one to have a lasting effect.

If  both  a  text-command  link  and a text-output link are created in the same
elaboration cycle, the text-command link is processed first, and the text  will
be  output in a text environment that reflects the new settings. If text output
and general output are both used, the general output  functions  are  processed
before text output.

The  text  environment options will be discussed in full in following sections.
For most applications, the text environment can be established  by  Lisp  macro
calls  in  the  user's  init-task or run-task function, and will not need to be
changed in the middle of a run. For example,

    (defun init-task ()
      (init-soar)
      (user-select nil)
      (watch 0)
      (set-text-input t)
      (set-text-output t)
      (set-io-stream-name *my-input-stream* input-stream-1)
      (set-text-input-stream *my-input-stream*)
      (set-io-stream-name *my-output-stream* output-stream-1)
      (set-text-output-stream *my-output-stream*)
      (set-char-mode t)
      (set-carriage-control t)
      (set-tab-settings 5 10 15 20))

A call to init-task or run-task resets all text  I/O  environment  settings  to
their  default  values.  For  this  reason, environment-setting text I/O macros
should be after the call to init-soar.
There are two additional text macros, set-break-char  and  set-macro-character,
that  do not cause augmentations to be added to the text-environment structure,
and cannot be set via the text-command structure.



6.2.3. Activating text I/O
Text input and text output are off by default.  To turn them on, use the  macro
calls:

    (set-text-input t)
    (set-text-output t)

Calling  these  macros  with  the  argument nil will return text input and text
output to the default off setting. Text input and output can also be turned  on
and  off  via  the text-input and text-output augmentations of the text-command
link.



6.2.4. Text input
When text input is on, text typed during a Soar run appears as a text structure
linked  to the top-level state by the text-input link[Text typed in response to
user-select and accept will not appear in working  memory.].  A  line  of  text
input  is  not  sent  to  Soar  until a carriage return [crlf] is entered; this
carriage return will not appear as part of the text-input structure.

For example, entering

    The <crlf>

results in the following structure in working memory:

    (state s9 ^text-input t11)
    (text t11 ^item the)

A line of text appears in working memory as a list of text  objects  linked  by
^next augmentations. For example,

    The time has come, the walrus said.   <crlf>

appears in working memory as:

    (state s9 ^text-input t11)
    (text t11 ^item the    ^next t12)
    (text t12 ^item time   ^next t13)
    (text t13 ^item has    ^next t14)
    (text t14 ^item come   ^next t15)
    (text t15 ^item ,      ^next t16)
    (text t16 ^item the    ^next t17)
    (text t17 ^item walrus ^next t18)
    (text t18 ^item said   ^next t19)
    (text t19 ^item .)

Note  that  all  characters are converted to the same case that Soar prints in,
that crlf does not appear as a text object,  and  that  punctuation  marks  are
identified as separate text objects.


6.2.4.1. Character mode and carriage-control mode
The  default  treatment  of  text  and whitespace input can be changed with two
calls:

(set-char-mode t) - Soar will read the input  one  character  at  a  time,  and
create a separate text object for each. This is called character mode.

(set-carriage-control  t)  -  Soar  will  include whitespace characters as text
objects. This is called carriage-control mode.

(Set-char-mode nil) will restore the default of reading  one  atom  at  a  time
(called  atom  mode), while (set-carriage-control nil) will restore the default
of ignoring whitespace characters.

In character mode, the carriage-control  setting  is  ignored.  All  whitespace
characters will be read in as separate characters, and appear in working memory
as text objects.

In character mode and carriage-control mode, a type attribute is added to  each
text  object,  to distinguish carriage-control objects from other text objects.
For example, the preceding input would appear in working memory as follows:

    (state s9 ^text-input t11)
    (text t11 ^item the   ^type atom ^next t12)
    (text t12 ^item space ^type cc   ^next t13)
    (text t13 ^item time  ^type atom ^next t14)
    (text t14 ^item space ^type cc   ^next t15)
    (text t15 ^item has   ^type atom ^next t16)
               .                         .
               .                         .
               .                         .
    (text t28 ^item .     ^type atom ^next t29)
    (text t29 ^item crlf  ^type cc)


6.2.4.2. Saving text input
When new input arrives, the old line  of  text  is  lost  unless  it  has  been
previously  saved  to  another augmentation. The text-input link is reused from
one text-input structure to the next, and so, the identifier of the first  text
object is also reused.

Saving  a  line  of  text,  therefore,  requires  the  creation  of a new state
augmentation and a new text object, which will be the first object in the saved
line  of text. The ^next attribute of this new first object should point to the
second object of the line to be saved. The rest of the text structure  will  be
saved automatically.

Since  the  actions  of  a production are retracted when the conditions of that
production  are  no   longer   satisfied,   unless   the   production   is   an
operator-application  production,  the  new augmentations should be created via
operator-application productions.

Assuming the operator save-text had already been instantiated and selected, the
following production saves text input on the last-text augmentation:

    (sp text-input*save-old-text-item
      (goal <g> ^problem-space <p> ^state <s> ^operator <o>)
      (problem-space <p> ^name read-text)
      (operator <o> ^name save-text)
      (state <s> ^text-input <t>)
      (text <t> ^item <item> ^next <next>)
      -->
      (state <s> ^last-text <l-t> +)
      (text <l-t> ^item <item> + ^next <next> +))

When  this  production  fires, it produces in working memory a structure of the
form:

    (state s9 ^text-input t11 ^last-input t34)
    (text t11 ^item the ^next t12)
    (text t34 ^item the ^next t12)
    (text t12 ...)

Saving text is illustrated in Figure 6-3.

-------------------------------------------------------------------------------


                     Figure 6-3:  Saving a text structure.
-------------------------------------------------------------------------------


6.2.4.3. The readtable
When text input is on and in atom mode, Soar redefines the  Lisp  readtable  so
that  characters  are not parsed according to their usual Lisp semantics.  This
alternate readtable can be customized, although typical text input applications
will not require this feature.

The  default  Soar readtable causes all punctuation characters to be treated as
terminating characters when Soar is  in  atom  mode.    For  example,  familiar
Lisp-like  names  such-as  *variable*  or  first-item will be split up into the
components * variable * and first - item.

The Lisp function set-macro-character changes  a  terminating  character  to  a
non-terminating  character  or back again. For example, the following Lisp code
causes asterisks and hyphens to be read as non-terminating characters:

    (set-macro-character #\*  #'read-asterisk t *alternate-readtable*)
    (set-macro-character #\-  #'read-hyphen-minus t *alternate-readtable*)

The first argument to this function represents the character to be changed; the
second argument represents the Soar readtable function that corresponds to that
character;  and  the  third  argument  is   either   t   or   nil,   signifying
non-terminating  or  terminating, respectively. The correspondence between Soar
readtable functions and specific terminating characters is given in Figure 6-4.

-------------------------------------------------------------------------------


    Figure 6-4:  The Soar alternate readtable functions.    Each  entry
                 includes a terminating character and its corresponding
                 Soar readtable function.  Any of these characters  may
                 be   changed   to   non-terminating   by   using   the
                 set-macro-character function.
-------------------------------------------------------------------------------

In text-input atom mode, characters  in  the  input  stream  are  read  by  the
readtable  functions  (punctuation  characters  are  read by the Soar readtable
functions and  other  characters  are  read  by  the  standard  Lisp  readtable
functions), and translated into the characters that make up the text input.  By
default, each function returns the character it reads.

To substitute characters, or create custom input types, the readtable functions
can  be  redefined. To redefine a punctuation character, the user must refer to
the appropriate function name  as  given  in  Figure  6-4.  To  redefine  other
characters,  the  user  should  establish  a new function name. In either case,
set-macro-character must be called after each redefinition.

For example, the Soar readtable function for reading a hyphen is:

    (defun read-hyphen-minus (stream char)
      (declare (ignore stream char))
      #\-)

The following redefinition substitutes the underscore character for a hyphen:

    (defun read-hyphen-minus (stream char)
      (declare (ignore stream char))
      #\_)

The following redefinition creates the custom type my-type:

    (defun read-hyphen-minus (stream char)
      (declare (ignore stream char))
      '(my-type #\-))

After this second redefinition, followed by the call

    (set-macro-character #\-  #'read-hyphen-minus t *alternate-readtable*)


a hyphen causes the following object to appear in working memory:

    (text-input t9 ^type my-type ^item -)

Recall that set-macro-character must  be  called  after  a  function  has  been
redefined,  or the new readtable function will not be called.  Also, changing a
terminating character to non-terminating will have no effect when  Soar  is  in
character mode, since all characters are read in as separate text objects.

The  alternate  readtable  characters  do  not  appear  in the text-environment
structure and cannot be changed via text-command augmentations.


6.2.4.4. Breaking a Soar run
A Soar run can be suspended by entering the break character.  The  default  can
be  changed with set-break-char (see Section 9.16.1 on page 176).  For example,
the first call below changes the break character to be a space, and the  second
call restores the default of crlf:

    (set-break-char #\space)
    (set-break-char #\newline)

Space and newline are non-printing characters; consult a Lisp reference for the
names used to refer to such characters.  A printing  character  is  denoted  by
"#\"  followed  by  the  character itself (for example, "#\s" for the character
"s").

Note that even when the break character is redefined, it must  be  followed  by
crlf  in  order  to  send the character to Soar.  The break character cannot be
changed  via  a  text-command  augmentation,  and  will  not  appear   in   the
text-environment structure.

When  text  input  is  off, the break character is crlf (or any series of input
characters followed by crlf), and cannot be changed.



6.2.5. Text output
With text output on, text connected to the top-level state by  the  text-output
link  will  go  to the output stream.  The text objects in the output structure
may be linked together by ^next attributes, as with text input.  Also, all text
objects  to be output must have a type augmentation, which must be atom, cc, or
tabto.  )

For example, productions might add the following  structure  to  the  top-level
state:

    (state <tls> ^text-output <t1>, <t1> &)
    (text <t1> ^item "The time has come, the walrus said."
               ^type atom ^next <t2>)
    (text <t2> ^item crlf  ^type cc)

Alternatively, productions can construct the same output in the following form:

    (state <tls> ^text-output <t1>, <t1> &)
    (text <t1>  ^item "The"  ^type atom ^next <t2>)
    (text <t2>  ^item space  ^type cc   ^next <t3>)
    (text <t3>  ^item "time" ^type atom ^next <t4>)
    (text <t4>  ^item space  ^type cc   ^next <t5>)
    (text <t5>  ^item "has"  ^type atom ^next <t6>)
              .                            .
              .                            .
              .                            .
    (text <t13> ^item "."  ^type atom ^next <t14>)
    (text <t14> ^item crlf  ^type cc)

Both forms above cause the following to be output:

    The time has come, the walrus said.   <crlf>

It is generally a good idea to add text-output links with parallel preferences,
since multiple production firings may result in  multiple  candidates  for  the
text-output slot. If parallel preferences are not provided, Soar will create an
attribute impasse for the slot, and no text-output link will be  added  to  the
state.  A  text-output link will remain until the production that created it is
retracted or until a new preference (such as a reject) is created to change the
decision for the slot.

Two  types of value for the item augmentation are worth noting.  First, a value
surrounded by  double  quotes  is  actually  a  string,  which  preserves  case
information.    Second,  the  value  can  be  a  variable  that is bound on the
condition side of a production.  The second form is  useful  for  printing  the
values  of  ^name  augmentations  of  operators and other Soar objects. This is
illustrated in the example in Section 6.2.5.3 on page 88.

The symbols text-output, text, item, type, next,  atom,  and  cc  have  special
significance  to  the text output system. They may be used anywhere within Soar
applications, but they must be used as described above when they are  contained
in text-output objects.

An  output  structure  must  be built in its entirety before the output link is
created (or during the same elaboration cycle).  This is necessary because Soar
outputs  a  particular  output  structure immediately following the elaboration
cycle in which it is attached to  the  top-level  state.  Text  output  may  be
repeated  by  reattaching it to the top-level state with a new output link that
points to the old structure.

Note that text output format is the same as the text input  format  (when  text
input  is  in character mode or carriage-control mode).  This allows text input
to be turned into output by transferring it  to  an  output  augmentation.  The
process  is  similar to saving text input, described in Section 6.2.4.2 on page
27. When this is done, text input should be in carriage-control  mode  so  that
the type augmentations will appear on the text objects.

Finally, note that the text-input environment has no effect on text output, and
vice versa.


6.2.5.1. Carriage-control text objects
Four special text objects can be used to format the text  that  appears  in  an
output structure.

crlf            Causes a carriage return and a linefeed.
                (text <t14> ^item crlf ^type cc).

space           Causes a space to appear between successive text objects.
                (text <t3> ^item space ^type cc ^next <t4>).

tab             Causes  the  cursor  to tab to the next tab position.  If there
                are no tab settings, a space is substituted for the  tab.    If
                the  cursor  is  to  the  right  of  the  last setting, crlf is
                executed and then tab is executed.
                (text <t3> ^item tab ^type cc ^next <t4>)

tabto           Causes  the  cursor to be positioned at an absolute column.  If
                the cursor is to the right of the column, a  crlf  is  executed
                and  then  the  tab is executed.  The following example tabs to
                the ninth column:

                (text <t3> ^item 9 ^type tabto ^next <t4>).


6.2.5.2. Setting tabs
By default, there are no tab settings for text output; if a tab is  present  in
the  output  structure,  it  will  be  output  as a space.  Tab settings can be
specified through a macro call. For instance:

    (set-tab-settings 5 10 15 20)

will set four tab stops, and

    (set-tab-settings nil)

will eliminate all tabs. A call to set-tab-settings replaces all  previous  tab
settings  with  the  new  values.  Tab settings can also be changed through the
tab-settings augmentation of the text-command output link.


6.2.5.3. Write expansion functions
Soar provides the functions write1+ and write2+ so that the user does not  have
to  explicitly  create  the  text  structure  used by text output.  Write1+ and
write2+ can be used similarly to the way write1 and write2 are used (the latter
functions  are described in Section 4.2.3.2 on page 21). By using the expansion
functions, the user can gain the benefits of I/O with minimal effort.

Soar rewrites productions containing write1+ and  write2+  at  load  time;  the
modified productions refer to a text-output structure. The expansion will occur
when the production is loaded, regardless of the on/off status of text  output.
However, text output must be on when the production fires, or the text will not
be written to the output stream.  A parallel  preference  is  created  for  the
text-output   structure  in  order  to  avoid  an  attribute  impasse  for  the
text-output slot.

The following skeleton production illustrates use of write1+:

    (sp textio*sample-production*eight-puzzle
      (goal ...)
      ...
      (state <s> ^tile <t1> <t2> <t3> <t4> <t5> <t6> <t7> <t8> <t9>)
      (tile <t1> ^name <n1>)
      ...
      -->
      (write1+ (crlf) "state" <s> (crlf))
      (write1+ " +---+---+---+" (crlf))
      (write1+ " |" <n1> "|" <n2> "|" <n3> "|" (crlf))
      (write1+ " +---+---+---+" (crlf))
      (write1+ " |" <n4> "|" <n5> "|" <n6> "|" (crlf))
      (write1+ " +---+---+---+" (crlf))
      (write1+ " |" <n7> "|" <n8> "|" <n9> "|" (crlf))
      (write1+ " +---+---+---+" (crlf)))

Soar expands the above production to:

    (sp textio*sample-production
      (goal ...)
      ...
      (state <s> ^tile <t1> <t2> <t3> <t4> <t5> <t6> <t7> <t8> <t9>)
      (tile <t1> ^name <n1>)
      ...
      -->
      (state <s> ^text-output <t10> <t10> & )
      (text <t10> ^type cc ^item crlf ^next <t11>)
      (text <t11> ^type atom ^item state ^next <t12>)
      (text <t12> ^type atom ^item <s> ^next <t13>)
      (text <t13> ^type cc ^item crlf ^next <t14>)
      (text <t14> ^type cc ^item space ^next <t15>)
      (text <t15> ^type atom ^item +---+---+---+ ^next <t16>)
      ... )



6.2.6. Redirecting text I/O
The default text  input  and  text  output  streams  are  *standard-input*  and
*standard-output*,  respectively (these are Lisp-defined streams).  In order to
read or write input from a file, the standard input and output streams  can  be
redirected.  The following calls cause input to be read from input-stream-1 and
output to go to output-stream-1:

    (set-text-input-stream input-stream-1)
    (set-text-output-stream output-stream-1)

Note that input-stream-1 and output-stream-1 must be symbols, whose values  are
stream  objects  of  the  appropriate  direction  (input  or output). Consult a
reference on your particular Lisp implementation for details.

The following calls restore the default streams:

    (set-text-input-stream *standard-input*)
    (set-text-output-stream *standard-output*)

In a window environment (such as X), a useful application of stream redirection
is  to  set  up  an  independent  window  for  text I/O to separate it from the
production trace.

6.3. General I/O
The purpose of  the  general  I/O  interface  is  to  allow  Soar  programs  to
communicate with Lisp functions.  Unlike text I/O, there is no default behavior
of general I/O. The user has  full  responsibility  and  freedom  to  establish
top-level  state  attributes  for  use  with general I/O, and to write the Lisp
functions  (called  user-defined  I/O  functions)  that  will   utilize   these
attributes.    User-defined functions use the functions provided by the general
I/O interface to create and access input and output augmentations.

I/O can be used in many ways, depending on the needs of the application and the
ambitions  of  the  programmer.  Some Soar programs make use only of input, for
example, to add a top-level state augmentation that  holds  the  current  time.
Some  Soar programs simulate an external environment, using output functions to
update global variables and input functions to reflect these changes in working
memory.  Other  Soar  programs are used for applications such as robotics, with
output used to send motor commands and input used to add the most recent sensor
readings to working memory.

Unlike  text I/O, general I/O is always available in Soar, and is not turned on
and off.



6.3.1. Input and output structures
Each input function acts on an input structure, which is an augmentation of the
top-level state and any augmentations linked (either directly or indirectly) to
that augmentation. The top-level state augmentation is called  an  input  link;
the  input link and all other augmentations in the input structure are referred
to as input augmentations. There are no restrictions on the class or  attribute
names that may appear in an input structure.

Each  input  structure  has  an  owner,  which  is a label that identifies each
augmentation  as  belonging  to  a  particular  input  structure.  There  is  a
one-to-one  correspondence  between  owners  and input structures; an owner can
manipulate only those input augmentations that it has created. The owner allows
a  distinction  between  input links that are multi-attributes of the top-level
state.  Since each input augmentation has an owner, the same augmentation  will
never appear in two different input structures.

When  multi-attributes  are  not  used  with  input links, the owner might be a
variation on the name of the input-link  attribute,  the  input-link  attribute
itself, or the name of the function that created the structure. However, if the
top-level state has a multi-attribute of  input  links,  each  of  these  input
structures must have a distinct owner.

Similar  to  input  functions,  each  output  function  responds  to  an output
structure,  which  is  an  augmentation  of  the  top-level   state   and   any
augmentations  connected  (either directly or indirectly) to that augmentation.
This top-level state augmentation is called an output link; the output link and
all  other  augmentations  in  the  output  structure are referred to as output
augmentations.

There is no need for output structures to have owners, since  output  functions
react to working memory elements, but do not manipulate them. However, there is
a restriction on output structures that does not exist  for  input  structures:
there  can  be  no  cycles  in  an  output  structure. Any cycles in the output
structure will cause Soar to fall into an infinite loop.

For example, the following output structure contains a cycle, and should not be
used:

    (state s9 ^command-link c45)
    (command c45 ^name move-tile ^from-cell c9 ^to-cell c10)
    (cell c9 ^name 12 ^cell c8 c10 c12)
    (cell c10 ^name 13 ^cell c9 c13)

An  input  or  output structure may contain a single augmentation (the input or
output link itself), or may be arbitrarily large. In other words, the value  of
an  input-link augmentation (or output-link augmentation) can be data or it can
be an identifier.



6.3.2. General input
User-defined input  functions  (or  input  functions)  create  or  alter  input
structures,  which appear in working memory and can be acted on by productions.
Typically, the first call to  the  function  will  create  the  original  input
structure,  while  subsequent  calls  may alter or replace the input structure.
Typically, an input structure represents a sensory input, such as vision.

The user-defined input functions are called automatically by Soar  before  each
elaboration  cycle.  Since  these  functions may alter working memory, they may
change the conflict set of productions for the  elaboration  cycle.  The  input
functions  are  also  called again once quiescence is reached so that new input
may cause further production firings.

The input functions create and retract preferences for the input augmentations.
At  the  end  of  the input cycle, Soar runs a mini decision cycle on the input
preferences to determine which augmentations enter and  leave  working  memory.
Both   acceptable   and   parallel   preferences  are  created  for  new  input
augmentations to allow for multi-attributes.


6.3.2.1. Using input functions
Access to working memory is provided by a set of input interface functions.  To
integrate input functions with Soar, the user must supply three things:

   1. A declaration of the input functions.

   2. The  input  functions  themselves,  which  make use of the interface
      functions.

   3. Soar productions that wait for and act upon the augmentations in the
      input structures.

Section  6.3.2.2  discusses  the  declaration  and  use  of  user-defined input
functions. Section 6.3.2.3 describes the input interface functions.


6.3.2.2. User-defined input functions
An input function declaration establishes the set  of  input  functions  to  be
called by Soar at the beginning of each elaboration cycle.  The input functions
are declared with the macro set-input-functions, whose  single  argument  is  a
list of input functions.

The syntax of the call to set-input-functions is:

    (set-input-functions (input-function-1 input-function-2 ...))

The order of the functions listed in the call to set-input-functions determines
the order in which these functions will be called. Furthermore, it is  possible
to  have  an input function called multiple times for each elaboration cycle by
listing the function more than once in the call to set-input-functions.

An input function manipulates augmentations in an input  structure,  using  the
input  interface  functions  to  create,  access,  and  delete augmentations. A
user-defined input function takes no arguments; values passed to the  interface
functions are established within the user-defined function itself, or are taken
from global variables.

It is possible to have one input function manipulate several input  structures,
as  long as each structure has a distinct owner. For example, a single function
might  compute  the  positions  of  a  robot's   hand,   arm,   and   base   in
three-dimensional  space,  and  add  these  as  separate  augmentations  of the
top-level state. It is also possible to have multiple  functions  manipulate  a
single input structure, so long as the owner for that structure is known to all
these functions.


6.3.2.3. Input interface functions
The input interface functions create, delete, and access  input  augmentations,
and  are  provided for use within user-defined input functions.  Most interface
functions take the argument owner, which is described in Section 6.3.1 on  page
90.

The  following  list  describes the interface functions and gives their calling
sequences.

NEW-INPUT-LINK owner input-link-attribute [input-link-value]

                Adds a new input link to working memory, and  returns  the  new
                input  link.  If owner already owns an input link, the new link
                replaces  it.    The  attribute  of  the  new  input  link   is
                input-link-attribute.   If  the  optional  input-link-value  is
                provided,  this  will  be  the  value   of   the   input   link
                augmentation,  and the input structure will consist of only one
                object, the input link itself.
                When   a   more   complex   input   structure    is    desired,
                input-link-value  should  be  omitted,  and  the  link  will be
                created with a value that is a new Soar symbol.  This value can
                be  retrieved  from  the  input  link  by  using  the interface
                function wme-value, and can then be used as an identifier.

CURRENT-INPUT-LINK owner

                Returns the input link associated with  owner  if  a  link  for
                owner exists, otherwise returns nil.

GET-INPUT-LINK owner input-link-attribute

                If  an  input  link  for  owner  exists, this link is returned.
                Otherwise,  a  new   input   link   is   created,   using   the
                input-link-attribute,  and  the  new link is returned. If a new
                input link is created, this augmentation will have as its value
                a  new  Soar symbol. This value can be retrieved from the input
                link by using the interface function wme-value, and used as  an
                identifier.

ADD-INPUT owner class id attribute [value]

                Creates  a new input augmentation if the augmentation specified
                does not already exist, otherwise does nothing.    Returns  the
                new augmentation in the first case, and nil in the second case.
                If value is omitted, a new augmentation is created with a value
                that  is  a  new Soar symbol that can be used as an identifier.
                This value can be retrieved by using  the  function  wme-value,
                described below.

DELETE-INPUT owner class id attribute value

                If  the  specified  augmentation  exists,  it  is  removed from
                working memory and returned as the result of the function call.
                Otherwise, nil is returned.

MATCH-INPUT &key owner class id attribute value [tolerance]

                Returns  a  list  of augmentations that match the specification
                given by the  parameters.    The  optional  keyword  :tolerance
                specifies  a  tolerance  for  the  :value keyword, if the value
                specified is a number.  The tolerance defaults to 0.

                For example, (match-input :owner 'my-function) returns  a  list
                of all augmentations in the structure owned by my-function, and
                (match-input :owner 'my-function :class 'sample-class)  returns
                a  list  of all augmentations that are owned by my-function and
                are of class sample-class.

                The tolerance has an affect only when the  value  parameter  is
                used,  and  only  when the value specified is a number. In this
                case, a non-zero tolerance may allow  match-input  to  retrieve
                more  augmentations, namely, those with values within the range
                of value plus-or-minus the tolerance.

                Note that tolerance allows the filtering out of  value  changes
                due  to  noise,  which  helps to reduce working memory traffic.
                For example, in a vision system without  such  a  filter,  Soar
                would have to reinfer object/feature identities for each change
                less than the tolerance.

CHANGE-INPUT-VALUE owner class id attribute value &key [tolerance]

                Changes the current value  of  the  augmentation  specified  by
                owner,  class,  id,  and  attribute,  when the current value is
                different from the  value  given  as  argument.  If  the  value
                specified is the same as the current value, nil is returned; if
                the  value  specified  differs  from  the  current  value,  the
                existing  augmentation  is  deleted,  a  new  one is created to
                reflect the new value, and the new  augmentation  is  returned.
                If  there is no augmentation in working memory that matches the
                owner, class, id, and attribute, a  new  augmentation  will  be
                created and returned.

                When  a  tolerance  is  specified  and  value  is  numeric, the
                existing augmentation will be deleted and  a  new  one  created
                only if the current value and the new value differ by more than
                the tolerance.

                Using change-input-value will reduce  working  memory  traffic,
                adding  a  new  working  memory element only when the value has
                changed. However, for some applications, it  is  preferable  to
                use  delete-input  and  add-input  even  when the current value
                matches the new value, since this will  create  a  new  working
                memory element that may allow a production to fire.

CHANGE-INPUT-VALUE-AND-OLD owner class id new-attribute old-attribute new-value
                &key [tolerance]

                This function is similar to change-input-value:  it  looks  for
                the   augmentation   specified   by   owner,   class,  id,  and
                new-attribute.  If  found,  it  compares  the  value  of   this
                augmentation  against  new-value;  if these match, no action is
                taken, and nil is returned. If the values differ,  the  current
                value  will be saved in a new augmentation (specified by owner,
                class, id, old-attribute, current-value), and this augmentation
                will  be  returned.    The  new-value  will  be  saved in a new
                augmentation specified  by  owner,  class,  id,  new-attribute,
                new-value.

                With  a  specified tolerance, this action will be taken only if
                the values used are numeric, and the new value differs from the
                current value by more than the tolerance.

                This  function allows the user to keep track of the current and
                previous values of an input item. Like  change-input-value,  it
                will  reduce  working  memory  traffic,  but  its  use  is  not
                appropriate to all applications.

TOP-STATE

                Returns the identifier of the top-level state.


WME-CLASS wme

WME-ID wme

WME-ATTRIBUTE wme

WME-VALUE wme

                These functions return the class,  id,  attribute,  and  value,
                respectively of wme, which can be any augmentation.  Typically,
                wme is an input-link or one of any of the augmentations in  the
                input  structure;  this may be the return value from one of the
                other interface functions.


6.3.2.4. Simple examples of general input
The following example augments the top-level state with  an  input  link  whose
value is the identifier of an augmentation that holds the current time.  First,
time-function is declared.  Comments (in Lisp format) appear within  the  code.
[There  are  many  versions  of  time-function  that will create the same input
structure. This version is provided because it illustrates the use of  many  of
the input interface functions.]


    (set-input-functions (time-function))
              ;; "time-function" is the only input function

    (defun time-function ()
      (let ((time-link nil)
             ;; this will be the input-link augmentation
            (time-id nil)
             ;; this will be the identifier of the input-link augmentation
            (old-time nil))
             ;; this will be the old time value

        (setf time-link (get-input-link 'time-owner 'time-i-link))
             ;; 'time-owner is the OWNER of the input structure
             ;; 'time-i-link is the ATTRIBUTE of the input-link augmentation
             ;; if a time-link already exists, retrieve it,
             ;;     otherwise, make a new time-link

        (setf time-id (wme-value time-link))
             ;; 'time-id is now the IDENTIFIER of the input-link
             ;;     augmentation, and will be the identifier of
             ;;     the TIME-ITEM object to be created

        (setf old-time
              (wme-value (first (match-input :owner     'time-owner
                                             :class     'time-item
                                             :id        time-id
                                             :attribute 'time))))
             ;; 'time-item is the CLASS of the input augmentation
             ;; get the value of the current TIME-ITEM augmentation,
             ;;     if it exists, otherwise, old-time will be nil

        (if old-time
            (delete-input 'time-owner 'time-item time-id 'time old-time))
             ;; get rid of the current TIME-ITEM augmentation,
             ;;    if there was one

        (add-input 'time-owner 'time-item time-id 'time
                                                  (get-universal-time))))
             ;; the VALUE of the input augmentation is provided by the
             ;;   (get-universal-time) function
             ;; add the new augmentation

This will create and maintain an input structure of the form:

    (state s9 ^time-i-link t48)
    (time-item t48 ^time 2813165927)

In  this example, the top-level state augmentation is created only once, and is
never removed. But the existing time-item augmentation is deleted and a new one
is  created  every  elaboration  cycle and at quiescence. This new augmentation
will be created even if the new time is equal to the old time.

A much simpler  input  structure  could  be  built  to  hold  the  time  in  an
augmentation  of  the  top-level  state  and  avoid  the  additional  level  of
indirection.

    (defun time-function ()
      (new-input-link 'time-owner
                      'time-i-link
                      (get-universal-time)))

This will create and maintain an input structure that consists  solely  of  the
input-link augmentation:

    (state s9 ^time-i-link 2813165927)

In  this  second  example, the current input-link will be deleted and a new one
created every elaboration cycle and at quiescence, but only  if  the  new  time
value differs from the current value.

When  writing  the productions that react to new input data, it is important to
keep in mind how often the input value can be expected to change. For  example,
with  the  time-function illustrated above, a production that responds to a new
time value would delay quiescence considerably. In this  case,  the  time  will
change  every  second,  so  the  production will have a new instantiation every
second.  Thus, Soar may repeatedly  enter  the  input  cycle  followed  by  the
elaboration  cycle,  stopping  only  when  *max-elaborations* has been reached.
With an input value that changes rapidly, such as the time,  tolerances  should
be incorporated into the input function or into the productions that respond to
new input.

The version of  time-function  below  illustrates  the  use  of  the  interface
functions  change-input-value  and  top-state.  However, the input-link will be
deleted and a new one created only on those input cycles in which the new  time
(returned  by  get-universal-time) differs from the current time by more than 5
seconds. This will reduce working-memory traffic considerably.

    (defun time-function ()
      (change-input-value 'time-owner                 ; owner
                          'state                      ; class
                          (top-state)                 ; id
                          'time-i-link                ; attribute
                          (get-universal-time)        ; value
                          :tolerance 5))              ; tolerance

Like the second example, this will create and maintain an  input  structure  of
the form:

    (state s9 ^time-i-link t48)
    (time-item t48 ^time 2813165927)



6.3.3. General output
User-defined   output   functions  (or  output  functions)  respond  to  output
structures in working memory, and may cause some  change  to  be  made  to  the
external  environment.  For example, an output function might cause a robot arm
to grasp an object.  Just as input  functions  can  access  only  the  part  of
working  memory  connected  to  the top-level state as input structures, output
functions can access only those augmentations connected to the top-level  state
as output structures. But unlike input functions, output functions do not alter
working memory.

The output cycle occurs at the end of every elaboration cycle, but there may be
no  output  functions called during a given output cycle.  Each output function
corresponds  to  a  top-level  state   attribute;   Soar   productions   create
augmentations,  called output links, that have this special attribute.  Working
memory may contain zero, one, or multiple output links for  a  given  top-level
state  attribute. A particular output function will be called at the end of any
elaboration cycle  during  which  a  new  output  link  (corresponding  to  the
function)  has  been  created.  If  multiple output links are created during an
elaboration cycle, the output function will be called once for each new  output
link;  no expectations should be made as to the order in which the output links
will be processed. Output links that persist  for  more  than  one  elaboration
cycle are ignored by the output functions.


6.3.3.1. Using output functions
To integrate an output function with Soar, the user must supply three things:

   1. Output  mappings,  which  establish pairings between top-level state
      attributes and the output  functions  that  will  respond  to  these
      output links.

   2. The   output   functions   themselves,  which  are  responsible  for
      interpreting output augmentations, and which make use of the  output
      interface functions.

   3. Soar productions that produce output structures.

Output  structures  and the restrictions on their form are described in Section
6.3.1 on page 29.


6.3.3.2. Output mappings
An output mapping defines how  output  functions  and  Soar  will  interact  by
mapping each output function onto an augmentation of the top-level state.

Output  mappings  are  created with the macro set-output-mappings, whose single
argument is a list of output mappings.  Each  output  mapping  takes  the  form
(output-function  output-link-attribute);  Soar productions are responsible for
producing new output links.  Output-function is called after every  elaboration
cycle in which a new output link is created for output-link-attribute.

The syntax of the call to set-output-mappings is:

    (set-output-mappings ((output-function-1 output-link-attribute-1)
                          (output-function-2 output-link-attribute-2)
                          ...))

An  output function can appear twice in the call to set-output-mappings as long
as each occurrence of that function corresponds to a different output link.  If
an   output-link   attribute   appears   more   than   once   in  the  call  to
set-output-mappings, only one of the functions bound  to  that  attribute  will
actually be called.


6.3.3.3. User-defined output functions
Each  output  function  must take one argument.  The parameter passed with each
call to an output function is outputs, an unordered list of  all  augmentations
in  the  output structure (including the output link).  This list is created by
Soar for use with the output function.


6.3.3.4. Output interface functions
Two functions, get-output-values  and  get-output-augmentations,  comprise  the
output interface.  The calling sequence and description of these functions are:

GET-OUTPUT-VALUES attribute wme-list

                Given an attribute and a list of  working  memory  elements,  a
                list  of  all  values  associated  with the named attribute are
                returned. Wme-list  could  be  either  the  return  value  from
                get-output-augmentations below, or outputs passed to the output
                function by the  architecture.  If  none  of  the  elements  of
                wme-list have the named attribute, nil is returned.

GET-OUTPUT-AUGMENTATIONS id wme-list

                Returns  the  subset  of  wme-list  that  have  the  identifier
                specified by id. Wme-list is a list of working memory elements,
                typically, the same as outputs passed to the output function by
                Soar, or the return value from get-output-values.


6.3.3.5. A simple example of general output
The  following code is used to send commands to a robot that has the ability to
move its base and its arm various amounts at various speeds, and to talk.   The
output mappings are established and output functions are defined to extract the
appropriate   values   from   the   output   structures.        The    function
send-command-to-robot uses a Lisp stream to send commands to the robot.

    (set-output-mappings ((robot-base-movement base-o-link)
                          (robot-arm-movement arm-o-link)
                          (robot-speech-output speech-o-link)))

    (defun robot-base-movement (outputs)
      (send-command-to-robot "BASE"
                             (first (get-output-value 'inches outputs))
                             (first (get-output-value 'speed outputs))))

    (defun robot-arm-movement (outputs)
      (send-command-to-robot "ARM"
                             (first (get-output-value 'degrees outputs))
                             (first (get-output-value 'speed outputs))))

    (defun robot-speech-output (outputs)
      (send-command-to-robot "SAY"
                             (first (get-output-value 'speech-o-link
                                                      outputs))))


Soar  productions  will  add the output structures base-o-link, arm-o-link, and
speech-o-link, resulting in output structures similar to the following:

    (state s9 ^base-o-link o54 ^arm-o-link o55 ^speech-o-link "hello")
    (output o54 ^inches 5 ^speed 4)
    (output o55 ^degrees 90 ^speed 7)

In the output cycle following the creation  of  these  output  structures,  the
robot  will  receive the commands to move its base forward 5 inches at speed 4,
to move its arm to a 90-degree angle at speed 7, and to say hello.

Note that the value of outputs passed to each  output  function  is  different.
For example, robot-base-movement receives the following unordered list:

    (state s9 base-o-link o54)
    (output o54 speed 4)
    (output o54 inches 5)


6.3.3.6. Using a multi-level output structure
If a multi-level output structure is required for an application, the functions
get-output-values and get-output-augmentations can be used together to  extract
the  appropriate  value.  For example, assume that the robot has two wheels and
can execute a turn by moving one wheel forward and the  other  wheel  backward.
The  following  code  extracts  the appropriate values from the turn-o-link and
sends two commands to the robot:

    (set-output-mappings ((robot-complete-turn turn-o-link)))

    (defun robot-complete-turn (outputs)
      (let* ((command     (first (get-output-values 'command outputs)))
             (motor-id-1  (first (get-output-values 'motors outputs)))
             (motor-id-2  (second (get-output-values 'motors outputs)))
             (motor-aug-1 (get-output-augmentations motor-id-1 outputs))
             (motor-aug-2 (get-output-augmentations motor-id-2 outputs)))
        (send-command-to-robot (first (get-output-values 'name motor-aug-1))
                               (first (get-output-values 'inches
                                                         motor-aug-1)))
        (send-command-to-robot (first (get-output-values 'name motor-aug-2))
                                                         'inches
                               (first (get-output-values motor-aug-2)))))

Soar productions add the turn-o-link output structure,  which  looks  something
like:

    (state s9 ^turn-o-link m54)
    (output m54 ^command turn ^motors m67 m68)
    (motor m67 ^name left ^value 2)
    (motor m68 ^name right ^value -2)

The  value of outputs passed (by Soar) to the output function interpret-command
is an unordered list that includes the following augmentations:

    (state s9 my-output m54)
    (output m54 name turn)
    (output m54 motors m67)
    (output m54 motors m68)
    (motor m67 name left)
    (motor m68 name right)
    (motor m67 value 2)
    (motor m68 value -2)

Care should be taken when using a common attribute such as name  in  an  output
structure,  since get-output-values may return more than one augmentation.  For
example, on the outputs list shown above, the call

    (get-output-values 'name outputs)

would return the list (turn left right). The return value of  get-output-values
may  also  have  more than one item if there are multi-attributes in the output
structure. It is a good idea to add some error checking rather than  to  assume
that get-output-values will always return a list of one item.
7. Default Knowledge
Soar,  without  any  productions loaded into its long-term memory, is unable to
perform a task.  Once task productions have been loaded, Soar may  be  able  to
make   progress;   however,  if  ever  the  task  knowledge  is  incomplete  or
inconsistent, a context impasse will arise.  Without knowledge to respond to an
impasse,  Soar can easily get into an infinite set of impasses.  To avoid these
uncontrolled impasses,  Soar  includes  a  set  of  approximately  one  hundred
productions  that  provide  default  responses  to  all types of impasses.  The
default productions reside in a file (default.soar) and are already  loaded  in
when Soar is first started up.  This chapter describes Soar's default knowledge
at an introductory level.  The defining reference for the  default  productions
are  the  productions  themselves.    The  file  default.soar is documented for
browsing.  (On Unix, the pathname  to  the  file  from  the  Soar  distribution
directory is /lib/default/default.soar)

Soar  does  not  provide  any  default  response  to  impasses  that  arise for
non-context augmentations.  The  assumption  is  that  these  impasses  do  not
represent a lack of progress on the current goal, as do context impasses.  If a
non-context impasse is critical for progress on a goal, it will sooner or later
give  rise  to a context impasse.  However, to make debugging easier, a default
monitoring production prints a warning when a non-context impasse occurs.

Section 7.1 on this page describes the knowledge that establishes a top context
for  Soar  to work in if no other context is provided.  Section 7.2 on page 102
describes Soar's responses to a variety of impasses.  These are simple attempts
at  skipping  over  the  object  that  led  to  the  impasse.  For two types of
impasses, multi-choice and operator no-change,  Soar  provides  more  extensive
knowledge.    Section 7.3 on page 103 describes the selection problem space and
the lookahead strategy for multi-choice impasses.   Section  7.4  on  page  112
describes  operator  subgoaling,  Soar's default response to operator no-change
impasses.  Finally, Section 7.5 on page 113 describes the messages  printed  at
run time by the default monitoring productions.

7.1. The top context
The  default  productions  provide  a  basic  top  context.    If  run  without
domain-dependent knowledge, Soar will select  a  problem  space,  named  simply
top-ps,  and  a  top  state initialized with augmentations for I/O (see Section
6.2.2 on page 26).  Then Soar will select an  operator  named  wait,  which  is
repeatedly  terminated and re-selected until the run is externally halted.  All
three context objects are given  worst  preferences,  so  that  they  will  not
interfere with any domain-dependent objects that are proposed.

The  usual  way  to  pose a task to Soar is to augment the given top state with
domain-dependent information, and propose an operator to carry  out  the  task.
If  Soar  cannot  directly  apply  the  operator, then a no-change impasse will
arise.  The correct problem space for performing the task can then be  proposed
in response to that subgoal (see Section 8.2.2 on page 124 for more details).

7.2. Responding to impasses
Soar's  default  knowledge for impasses provides minimal default processing for
every impasse that can arise.  Default processing falls  into  four  categories
according  to  the  type of the impasse and the object on which it occurs.  The
four  categories  are:  (1)  multi-choice  impasses;  (2)  operator   no-change
impasses;  (3)  goal,  problem  space,  and  state  no-change impasses; and (4)
constraint-failure impasses.



7.2.1. Multi-choice impasses
Multi-choice impasses arise when there is either a tie or conflict between  the
candidate  objects  for a slot.  The default response to a multi-choice impasse
is to select the selectionproblem space, which provides operators that evaluate
the  tied  objects.    The  selection  space  includes productions that compare
evaluations, and automatically translate them into preferences for the  various
choices.    As soon as the selection space has generated sufficient preferences
to select one  object  amongst  the  choices,  Soar  selects  that  object  and
terminates the multi-choice impasse.

The  selection  space  might  be  rejected  because  it  is  not sufficient for
resolving the impasse, or because domain-dependent knowledge decides to abandon
it.   If the selection problem space is rejected for a multi-choice impasse and
no other problem space is selected, the impasse will be  resolved  by  creating
additional preferences for the tied or conflicting objects.  If the impasse was
a tie, indifferent preferences will be created for all items that tied, leading
to  a  random selection.  If the impasse was a conflict, all of the conflicting
items are rejected.

The selection problem space is described in detail in Section 7.3 on page 103.



7.2.2. Operator no-change impasses
If an operator no-change impasse occurs, there are three possible reasons:  (1)
the  pre-conditions  of  the  operator  were not satisfied; (2) the operator is
incompletely specified (i.e., it needs to be  further  instantiated);  and  (3)
there  are  no  productions  that  directly  apply  the operator and it must be
applied in a subgoal in its own problem space.

For case (1), the appropriate response is to use the  same  problem  space  and
search  for  a state where the operator will apply (operator subgoaling).  Case
(2)  requires  operator  instantiation,  and   case   (3)   requires   operator
application.   For both cases (2) and (3), domain-dependent problem spaces must
be  available  to   perform   the   necessary   problem   solving.      Because
domain-dependent  knowledge  is required for the last two cases, the first case
is the default action.  Acceptable and worst preferences  are  created  in  the
subgoal  for the super problem space.  These can be overridden by an acceptable
preference for a different problem space.

The operator subgoaling strategy is described in detail in Section 7.4 on  page
112.



7.2.3. Other no-change impasses
The  default  response  to  a problem space or state no-change impasse is to do
nothing.  If a problem space can be selected in the subgoal, that implies  that
there is domain-dependent knowledge to process the impasse.  However, if one of
these no-change impasses is followed by a goal no-change  impasse,  the  latter
impasse indicates that there is no domain-dependent knowledge for resolving the
original problem space or state no-change.  When there is  no  such  knowledge,
the  default  response is to abandon the current path.  The minimal change that
abandons the current path  is  to  reject  and  reconsider  the  most  recently
selected  context  object,  which  is  the  problem space or state on which the
original no-change impasse  occurred.    For  example,  if  there  is  a  state
no-change followed by a goal no-change, the state will be rejected.



7.2.4. Constraint-failure impasses
Necessity  preferences  (require  and prohibit) encode knowledge that a certain
object must, or must not, be selected if the goal is  to  be  achieved.    When
there  are  conflicting  necessity  preferences  for  a  given  context slot, a
constraint-failure impasse arises.  There is no way  to  override  a  necessity
preference  by  adding  more preferences.  This impasse can be resolved only by
either causing some of the preferences to retract, or by modifying  a  decision
higher in the context.

Because  necessity  preferences  usually arise from domain-dependent knowledge,
the default response can only be to modify the  next  higher  decision  in  the
context  stack.   When a constraint-failure impasse arises, default productions
create reject and reconsider preferences for the context  object  in  the  slot
immediately  above the one with the impasse.  This is the minimal change to the
context that guarantees to end the constraint-failure impasse.  If there  is  a
constraint-failure  impasse  for  the  top problem space, Soar halts because no
further progress is possible.

7.3. The selection space for multi-choice impasses
A multi-choice impasse indicates inadequate knowledge  to  distinguish  between
competing  alternatives.   The default response is to try to acquire additional
information about the alternatives so that a decision can be  made.    This  is
done  in  the  context  of  the selection problem space.  The selection problem
space has operators that  evaluate  the  competing  alternatives.    The  state
consists  of  the  computed  evaluations.    Additional productions compare the
evaluations  and,  based  on  the  comparison,  create  preferences   for   the
alternatives.

Evaluations  can be symbolic (e.g., success or failure) or numeric (e.g., 1, 5,
or 0).  A special value called novalue  can be assigned as either a numeric  or
a symbolic value.  Its properties are discussed in Section 7.3.3.5 on page 112.

The  selection space is proposed with a worst preference so that it will not be
selected if  there  are  better,  domain-dependent  alternatives.    If  it  is
selected, an empty initial state is created, which will come to hold evaluation
objects, one for each alternative.  The selection space  contains  an  operator
called evaluate-object that is instantiated once for each alternative.  When an
evaluate-object operator is selected, domain-dependent knowledge can  apply  it
by  assigning  a  value  to  its  associated evaluation object.  If no value is
assigned, the default response is to enter an evaluation subgoal, in which  the
context of the tie is recreated to try out an object by lookahead search.

For   the  selection  problem  space  to  function  properly,  domain-dependent
productions must augment the goal in which the tie or conflict  arises  with  a
^desired  attribute.    The  value  must be an object with class desired.  This
desired object can contain augmentations (described in Section 7.3.3.2 on  page
110)  that  control  behavior  in the selection space.  It is also a convenient
place to describe the desired state for the goal, if a declarative  description
is necessary.



7.3.1. The evaluate-object operator
The  evaluate-object  operator  creates  evaluations  for  tied  or conflicting
objects.  These are the objects on the ^item augmentation of  the  subgoal  for
the multi-choice impasse.  Soar creates this augmentation automatically.

By   default,   instances   of   evaluate-object  are  created  acceptable  and
indifferent, so that Soar can select them in turn  without  generating  further
impasses.    The user-select (see Section 9.3.11 on page 153) function provides
control over the order in which instances of evaluate-object are selected.   If
the selection space is augmented with ^operator-selection not-indifferent, then
instances of evaluate-object are created acceptable but not indifferent.  A tie
impasse  will arise, allowing domain-dependent knowledge to decide the order in
which the instances should be selected.

To provide easy access to all information relevant to creating  an  evaluation,
each evaluate-object operator has a standard set of augmentations.

^name           evaluate-object.

^type           evaluation.    Much  of the knowledge about the evaluate-object
                operator is general enough so that it  can  be  used  by  other
                operators that perform more specialized evaluations.  This more
                general knowledge tests ^type evaluation and not  the  name  of
                the operator.

^object         The identifier of the object to be evaluated.

^attribute      The   context   attribute   of   the   object  being  evaluated
                (problem-space state, or operator).

^evaluation     The  identifier  of  the  newly  created   evaluation   object,
                described further in Section 7.3.1.1 on page 105.

^state          The current state of the selection subgoal. Default productions
                use this augmentation to transfer the evaluation object to  the
                state when a value has been computed.

^desired        The  desired  object  of  the  supergoal (the goal in which the
                multi-choice impasse arose).

^superproblem-space
                The problem space selected in the supergoal.

^superstate     The state selected in the supergoal.


Below is a sample evaluate-object operator.

    (operator o30 ^name evaluate-object ^type evaluation ^evaluation e33
                  ^state s28 ^desired d10
                  ^superproblem-space p12 ^superstate s14)


7.3.1.1. Evaluation objects
As  mentioned  above,  a  new  object  of  class  evaluation is created when an
evaluate-object operator is selected.  This evaluation object is linked to  the
operator's ^evaluation attribute.  The object is created with the following set
of augmentations (of which the first three contain the same information as  the
corresponding augmentations of the evaluate-object operator):

^object         The identifier of the object to be evaluated.

^state          The current state of the selection subgoal.  The state also has
                a pointer back to the evaluation object.

^desired        The desired object from the supergoal (the goal  in  which  the
                impasse arose).

^operator       The  identifier  of  the  evaluate-object  operator  that  this
                evaluation object augments.

^type           The name  of  the  operator  that  was  used  to  generate  the
                evaluation.    Usually  this  is evaluate-object, but for other
                applications  it  might  be  some  other  evaluation-generating
                operator.


Currently,  there  is  default knowledge for two types of evaluations:  numeric
and symbolic.  They are distinguished by the augmentation that is added to  the
evaluation   object   when   they   are  computed.    If  the  augmentation  is
^numeric-value, its value is assumed to be an integer.  If the augmentation  is
^symbolic-value, its value is assumed to be one of a predefined set of symbolic
values,  which  includes  success  and  failure.    The  details  of  computing
evaluations are explained in Section 7.3.3 on page 110.

Some behavior, such as termination of an evaluate-object operator, depends only
on whether any evaluation has been computed.  Therefore, when either a  numeric
or  symbolic evaluation is added to the evaluation object, a default production
augments the object with ^value t.

The example below shows two evaluation objects.  The first has a numeric value,
and the second has a symbolic value.

    (evaluation E4 ^object O44 ^state S34 ^desired E3330
            ^operator O5555 ^numeric-value 10 ^value t)

    (evaluation E4 ^object O44 ^state S34 ^desired E3330
            ^operator O5555 ^symbolic-value success ^value t)


7.3.1.2. Applying the evaluate-object operator
The  evaluate-object  operator,  as  with all other operators, can apply either
directly or in a subgoal.  To apply it directly,  domain-dependent  productions
must augment the operator's evaluation object with a value.

If  a  no-change  impasse  arises after an instance of evaluate-object has been
selected, the evaluation will be  computed  in  the  resulting  subgoal.    The
evaluation  subgoal  is  discussed in Section 7.3.3 on page 110.  Once subgoals
have been used to compute evaluations, chunks that have  been  built  from  the
subgoals can directly compute the evaluations.

Terminating  the operator is done automatically by the default productions once
the evaluation object has a value.  If the evaluation produced by the  operator
does  not  lead  to the termination of the multi-choice subgoal, the reconsider
preference will lead to the selection of another evaluate-object operator.



7.3.2. The evaluation subgoal
If an evaluate-object operator leads to an impasse, the default response is  to
recreate  the  context  that  led to the tie or conflict, and select the object
being evaluated.  Within this new context, the system can do lookahead  search,
selecting  the object and discovering the ramifications of that selection.  Any
ramifications are taken to reflect on  the  object  selected.    Therefore,  an
evaluation  based on the problem solving in the subgoal is used as the value of
the evaluated object.  For example, the evaluation of a lookahead state is used
for the operator that created it.


7.3.2.1. State copying
When  performing  a  lookahead  search  to  evaluate a tied operator, the state
selected in the context where the tie or conflict arose must be duplicated  for
use  in the evaluation subgoal.  We will call this state the tie-context state.
If the original tie-context state is used, the lookahead process will modify it
not  only  in  the  subgoal,  but also in the original goal.  Then, because the
tie-context state is modified, there  can  be  no  backtracking  to  try  other
operators.    This will also destroy the context of the tie impasse because the
changes to the state will lead to a change in what operators are proposed.

The default productions provide a copy mechanism that creates duplicate  states
for  lookahead search.  By default, the copy mechanism will create a new, empty
state, copy to it all the augmentations of the tie-context  state,  and  select
the  new state in the evaluation subgoal.  However, it may also be necessary to
duplicate objects  linked  to  the  state,  by  copying  augmentations  of  the
tie-context  object  to  a  new  identifier.    The copy mechanism can be given
various directions for how to  build  a  duplicate  state.    Some  factors  to
consider when specifying how to copy a state are given below.

Efficiency      Perhaps  only a subset of the tie-context state is necessary in
                the  subgoal.    The  efficiency  concern  dictates  that  only
                necessary attributes should be copied.

Modifying subobjects
                Operators in the evaluation subgoal may modify objects that are
                attached to the state, as well as the state itself.  Subobjects
                that will be modified must themselves be  duplicated,  so  that
                the original objects aren't permanently altered.

State refinements
                State refinements are  simple  inferences  that  are  based  on
                existing  data in the state.  A state refinement is not created
                by an operator, but is created  based  on  the  results  of  an
                operator.    For  example,  the value of a state is often based
                only on the current values of augmentations in the  state,  and
                can  be added as a refinement.  One important property of state
                refinements is that they are  retracted  automatically  if  the
                state  changes  so  that they are no longer relevant.  However,
                when a state refinement is copied to  a  duplicate  state,  the
                copy  is  supported  through  the  existence of the tie-context
                state, independent of changes to the duplicate  state.    Thus,
                even  when  the duplicate state is modified during a lookahead,
                the state refinement value copied from  the  tie-context  state
                will  incorrectly  persist because that state is unchanged.  To
                avoid incorrect  behavior,  state  refinements  should  not  be
                copied  from  the  tie-context  state. Instead, the productions
                that created the refinements in the original state can recreate
                the refinements for the duplicate state.


The  copy  mechanism  recognizes a set of problem space attributes that specify
which augmentations of the state to copy or leave behind, and which  subobjects
to duplicate when copying.  The attributes must be augmentations of the problem
space that will be selected in the evaluation  subgoal.    The  attributes  are
given below.  Those augmentations that are underlined are supplied by default.

^default-state-copy yes
                Enables state copying.  A value of no  disables  state-copying,
                in  which case acceptable and worst preferences are created for
                the original state.

^one-level-attributes
                The  value  is  a  set  of  attributes to copy to the duplicate
                state.  To "copy an attribute" means to copy all  augmentations
                of the tie-context state that share that attribute.

^two-level-attributes
                The value is a set of attributes whose values are themselves to
                be  duplicated,  and  the  duplicates  copied  to the duplicate
                state. To "duplicate a value" means  to  duplicate  the  object
                whose identifier is the value of the attribute.

^all-attributes-at-level one
                Indicates that all attributes on the tie-context state  are  to
                be  copied  to  the  duplicate  state.    This is equivalent to
                listing all attributes as the value of ^one-level-attributes. A
                value  of  two  indicates  that all attributes on the state are
                two-level-attributes.

^dont-copy      The value is a set of attributes to not copy to  the  duplicate
                state.

^dont-copy-anything true
                This signals that  no  attributes  are  to  be  copied  to  the
                duplicate state.
These augmentations can be used in combination to specify what the structure of
the duplicate should be.  The effects of the legal combinations  are  given  in
the  table  below.    ARGS  represents  a set of attributes, ALL stands for all
attributes of the tie-context state, NONE stands for no attributes, and "-" and
"+"  represent  the  obvious  set  operations.   "Copy" means to copy the given
attributes to the duplicate state directly, and "duplicate" means to  duplicate
the values and copy the duplicates to the duplicate state.

                                      --
                                      ||           |
                                      ||Attributes | Semantics
                                      ||           |
                                      ||                        |
                                      ||default   copy(ALL)     |
                                      ||                        |
                                      ||                          |
                                                                  |
                                      ||dont-copy-anything true   copy(NONE)
                                      ||                          |
                                      ||                          |
                                      ||one-level-attributes ARGS | copy(ARGS)
                                      ||                          |
                                      ||                            |
                                                                               R
                                                                               G
                                                                    |          S
                                      ||two-level-attributes ARGS   duplicate(A)
                                      ||                            |
                                      ||                            |
                                      ||all-attributes-at-level one | copy(ALL)
                                      ||                            |
                                      ||                            |
                                                                               (
                                                                               A
                                                                               L
                                                                               L
                                      ||all-attributes-at-level two | duplicate)
                                      ||                            |
                                      ||                             |
                                                                               1
                                                                               )
                                      ||one-level-attributes ARGS1,  |copy(ARGS,
                                                                               e
                                                                               (
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                                                               2
                                      || two-level-attributes ARGS2  | duplicat)
                                      ||                             |
                                      ||                             |
                                                                               -
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                                                               )
                                      ||all-attributes-at-level one, | copy(ALL,
                                                                               t
                                                                               e
                                                                               (
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                      || two-level-attributes ARGS   |  duplica)
                                      ||                             |
                                      ||                             |
                                                                               S
                                                                               )
                                      ||all-attributes-at-level two, | copy(ARG,
                                                                               t
                                                                               e
                                                                               (
                                                                               A
                                                                               L
                                                                               L
                                                                               -
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                      || one-level-attributes ARGS   |  duplica)
                                      ||                             |
                                      ||                             |
                                                                               -
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                      ||all-attributes-at-level one, | copy(ALL)
                                      || dont-copy ARGS              |
                                      ||                             |
                                      ||                             |
                                                                               e
                                                                               (
                                                                               A
                                                                               L
                                                                               L
                                                                               -
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                      ||all-attributes-at-level two, | duplicat)
                                      || dont-copy ARGS              |
                                      ||                             |
                                      ||                             |
                                                                               S
                                                                               1
                                                                               )
                                      ||all-attributes-at-level two, | copy(ARG,
                                                                               t
                                                                               e
                                                                               (
                                                                               A
                                                                               L
                                                                               L
                                                                               -
                                                                               (
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                                                               1
                                                                               +
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                                                               2
                                                                               )
                                      || one-level-attributes ARGS1, |  duplica)
                                      || dont-copy ARGS2             |
                                      ||                             |
                                      ||                             |
                                                                               -
                                                                               (
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                                                               1
                                                                               +
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                                                               2
                                                                               )
                                                                               )
                                      ||all-attributes-at-level one, | copy(ALL,
                                                                               t
                                                                               e
                                                                               (
                                                                               A
                                                                               R
                                                                               G
                                                                               S
                                                                               1
                                      || two-level-attributes ARGS1, |  duplica)
                                      || dont-copy ARGS2             |
                                      ||                             |
                                      --

Other  combinations  than  those  listed  above are not supported and should be
avoided.  It is an undetected error for an attribute to be the  value  of  more
than  one  of  these control attributes.  It is also an undetected error for an
attribute with constant values to be  listed  as  a  two-level-attribute.    If
^all-attributes-at-level  two  is  given,  the  latter  error can be avoided by
listing attributes with constant values as one-level-attributes.

The following are some other noteworthy features of the copy mechanism.

   1. An attribute is either copied or not  copied.  If  an  attribute  is
      copied, all values for that attribute are copied.

   2. When  objects deeper than one level below the state will be modified
      in an evaluation subgoal, the copy mechanism  provides  no  support.
      Domain-dependent  productions  to  duplicate  those  objects must be
      provided.

   3. The copy mechanism retains the graph structure of the identifiers in
      the  tie-context  objects  only  down to objects one level below the
      state.  If an object two or more levels below the state points to an
      object  that is duplicated when copied, the "deep" object will point
      back to the tie-context version of the duplicated object.

   4. Parallel preferences are created for all attributes on the duplicate
      state,  and  all  attributes of duplicated objects.  Thus, attribute
      tie impasses that would occur on the  tie-context  state  might  not
      occur on the duplicate state.


7.3.2.2. State copying example
The  following  example  illustrates the basic operation of the copy mechanism.
In the Switchyard Task, railway cars are represented as objects attached to the
^car  attribute  of  the  state.  Car objects have, among other attributes, one
that describes their position (^position), which is changed by  operators  that
move  the  cars.    If  a  car's  position  is the same as its destination, the
^in-position attribute of the state gets that car  as  a  value;  the  task  is
finished  when  there is no car that is not in position.  There is an attribute
of the state that indicates whether or not the siding is clear (^siding-clear).
Finally,  there  may  be  other  attributes  that are accessed read-only in the
subgoal.

For this example, objects attached to ^car should be duplicated,  because  they
will  be edited as cars' positions change.  The ^siding-clear attribute is also
necessary information for use in lookahead, but it takes constant values, so it
must be copied directly.  The ^in-position attribute is a state refinement, and
so it should not be copied.   The  following  production  gives  the  necessary
directions  to  the copy mechanism.  Note that parallel preferences are usually
necessary for creating the control augmentations.

    (sp your-production-name
        (goal <g> ^problem-space <p>)
        (problem-space <p> ^name switching-task)
        -->
        (problem-space <p>
             ;; copy ^siding-clear and other attributes:
            ^all-attributes-at-level one + &
             ;; duplicate car objects:
            ^two-level-attributes car + &
             ;; leave behind the refinement:
            ^dont-copy in-position + &))


7.3.2.3. Operator copying
Once an operator is selected for application in a lookahead search, it  may  be
further  instantiated  with  augmentations based on the current state.  As with
the state from  the  tie-context,  if  an  operator  from  the  tie-context  is
selected,  these  modifications  will  affect  the  original  operator from the
tie-context and disrupt future problem solving.  Therefore, a copy mechanism is
provided  to  duplicate  the  operators  from  the  tie  context,  and  use the
duplicates in the evaluation subgoal.

In creating the duplicate operator, objects duplicated for the state  are  used
in  place  of  the original objects, maintaining the integrity of pointers from
the operator to the state.

Fewer control options are available for operator copying.  It can be  disabled,
by  changing  value of ^default-operator-copy from yes (provided by default) to
no.  A list of attributes not to copy from  the  tie-context  operator  can  be
specified  with  ^dont-copy.   The former attribute augments the problem space,
and the latter augments the operator itself.

The value of the ^object augmentation of the evaluate-object operator,  when  a
multi-choice impasse is over operators, is always the tie-context operator, and
never the duplicate operator used in the evaluation subgoal.



7.3.3. Computing evaluations
Independent of whether the evaluation is computed in  a  subgoal  or  a  single
production,  it  must  be  computed.    There  are  two classes of evaluations,
symbolic and numeric.  The default knowledge provides  support  for  processing
and comparing evaluations.


7.3.3.1. Computing numeric evaluations
Numeric  evaluations  can  be  computed  by  a  single  production,  a  set  of
productions, or a subgoal.    All  of  these  methods  must  create  the  right
augmentation  of  the  correct  object  so  that  the  default  productions can
terminate  the  evaluate-object  operator  and  create  preferences   for   the
alternative  objects.    The correct action is to augment the evaluation object
(which is the value of the  ^evaluation  augmentation  of  the  evaluate-object
operator)   with  ^numeric-value  number.    For  example,  a  domain-dependent
production would contain at least the following:

    (sp your-production-name
       (goal <g> ^state <s> ^object <sg> ^desired <d> ^applied <o>)
       (goal <sg> ^state <ss> ^operator <so>)
       (operator <so> ^name evaluate-object ^evaluation <e> ^object <o>)
       conditions that match features of state <s>
       conditions that match features of desired state <d>
        -->
       (evaluation <e> ^numeric-value your-evaluation))

Numeric evaluations are useful when features  of  a  state  correspond  to  the
distance  from  the state to the goal and can be mapped onto either the integer
or the real numbers.  The value computed for each state can then be compared to
the  value  computed for another state and a preference can be created based on
the ordering of the numeric values.  Complex  combinations  of  numbers  for  a
numeric  evaluation  of  a  state  are  possible using the compute action.  For
example, your-evaluation could be the addition of two other  numbers:  (compute
<num1>  +  <num2>). See Section 4.2.3.2 on page 21 for a further description of
compute.


7.3.3.2. Comparing numeric evaluations
As tied objects acquire numeric values, default productions compare the  values
to  decide  which  object  is  better.  The productions must be told whether to
prefer higher or lower values.  This is done by augmenting the  desired  object
of  the  goal above the selection subgoal with either ^better higher or ^better
lower,respectively.  The desired object must have class desired,  as  described
in Section 7.3 on page 33.

By  default,  objects  that  have  equal  numeric  values  are made indifferent
(regardless of the ^better augmentation).  This can be  changed  by  augmenting
the  desired  object  with ^equal not-indifferent. If equal values are not made
indifferent, and the tie is not otherwise broken, then  a  second  tie  impasse
will arise in the original context, between the equal-valued objects.
7.3.3.3. Computing symbolic evaluations
Soar  provides  a set of eight predefined symbolic evaluations.  The evaluation
object can be augmented with attribute ^symbolic-value and one of the following
values:   require-success,   success,  partial-success,  indifferent,  partial-
failure, failure, and prohibit-failure.

The semantics of these values are given below, relative  to  their  use  in  an
evaluation  subgoal.    As  with  numeric  evaluations,  objects  with the same
evaluation are made indifferent.

Require-success
                The  state  is  the  only  next  state  in which success can be
                achieved, and this is the only  path  that  can  lead  to  this
                state.  This  is  translated  into a require preference for the
                operator.

Success         The state achieves the goal.  There may be  other  states  that
                achieve  the  goal  and  other  paths  to  this state.  This is
                translated into a best preference for the operator.

Partial-success The state is on the path to the goal.  The state  may,  or  may
                not  be  on  the  shortest  or  best path to the goal.  This is
                translated into a best preference for the  operator.    If  one
                operator  has a success augmentation, and a second operator has
                a partial-success augmentation, a preference  is  created  that
                the first operator is better than the second.

Indifferent     There  is  knowledge that it does not matter whether this state
                is reached.  This is translated into an indifferent  preference
                for the operator.

Partial-failure The  state  is  not on the path to success.  This is translated
                into a worst preference for the operator.

Failure         The state is a failure state.  This is translated into a  worst
                preference   for   the   operator.    If  one  operator  has  a
                partial-failure augmentation,  and  a  second  operator  has  a
                failure  augmentation,  a  preference is created that the first
                operator is better than the second.

Prohibit-failure
                If  the  state  is  encountered, success can never be achieved.
                This  is  translated  into  an  prohibit  preference  for   the
                operator.


The  default  knowledge also provides a simpler method to use in the evaluation
subgoal.  One of the predefined symbolic values can augment a  lookahead  state
as  the attribute, taking the desired object its value.  The following template
shows how to use a success evaluation as a goal test in an evaluation subgoal:

    (sp your-production-name
       (goal <g> ^state <s> ^desired <d>)
       conditions that detect subgoal success by comparing <s> to <d>.
        -->
       (state <s> ^success <d>))

These symbolic augmentations  are  converted  by  default  productions  to  the
corresponding ^symbolic-value augmentations for the evaluation object.

The  desired object is copied from the tie-context automatically by the default
productions.  The value of the ^desired augmentation  is  necessary  because  a
given  state  may occur in multiple goals.  The desired object must be included
in the augmentation so that the symbolic evaluation is correctly  tied  to  the
appropriate desired state.


7.3.3.4. Default evaluations
In the evaluation subgoal, evaluations are usually computed by domain-dependent
productions.  However, sometimes an evaluation can be  computed  automatically,
based on activity below the subgoal.

   1. If an operator is found to be on the path to a solution generated by
      successive lookaheads (success, partial-success, or required-success
      is  detected  for  the desired state), then the operator is given an
      evaluation of partial-success, which will in turn be translated into
      a best preference.

   2. If  an operator is being evaluated using lookahead but the lookahead
      reaches a dead end (where either no operators are proposed  for  the
      current   lookahead   state,   or  all  operators  are  rejected  or
      prohibited),  then  the  evaluation   object   is   augmented   with
      ^symbolic-value failure which is translated into a worst preference.


7.3.3.5. Novalue evaluations
The  selection  space provides processing for a particular kind of value called
novalue.  This value  can  be  given  to  either  the  ^symbolic-value  or  the
^numeric-value attribute.  It is automatically made worse than any other value.

If  all objects in a selection subgoal evaluate to novalue, and that subgoal is
below another selection subgoal, then  the  operator  being  evaluated  in  the
higher  subgoal  also  evaluates  to  novalue.  If there is no higher selection
subgoal, then all of the novalue objects are made indifferent  to  each  other,
which also resolves the impasse.

Novalue  is  intended for use in lookahead search, although it can also be used
in direct application of evaluate-object.  It is a declaration that there is no
knowledge  for  evaluating  a  state,  other than that further lookahead search
based on this state is undesirable.

No chunk is built when novalue is returned from one selection space to  another
because  there  is  a  test  for exhaustion (see Section 5.1 on page 23).  This
makes it possible to backtrack from an unprofitable state without the danger of
building  overgeneral  chunks.    To  completely  prevent  overgeneral  chunks,
domain-dependent productions that assign novalue to the  evaluation  object  in
the  evaluation  subgoal  should  test  the  ^quiescence  t augmentation of the
subgoal.



7.3.4. Halting Soar with success or failure
If a state for the top goal is marked with  ^success  or  ^required-success,  a
default  production  will  cause  Soar to halt.  If a state for the top goal is
marked with ^failure or ^prohibit-failure, Soar will halt with failure.

7.4. Operator subgoaling
If an operator has been selected but cannot be applied to the current state,  a
useful  strategy  is to create a subgoal to find a state where the operator can
be applied.  This strategy is called  operator  subgoaling  (also  precondition
satisfaction)  and  is  a  common  AI  technique  dating back to GPS.  In Soar,
operator subgoaling is appropriate when an operator has  been  selected  and  a
no-change  impasse  arises.  This is implemented by recreating the same context
in the subgoal, but with the desired state being the the operator that is to be
applied.

To  recreate  the same context, acceptable and worst preferences are created to
select the operator's problem space in the subgoal.  If no other problem spaces
are  suggested,  the  problem  space  will be selected, allowing a search to be
performed in the same problem space as the supergoal, but with a new goal, that
of  applying  the  supergoal's  operator.  The presumption is that the selected
operator could not apply to the current state, so another state must be found.

Once  the  super  problem  space  has  been  selected,  the   goal   is   named
operator-subgoal  and  augmented  with the superoperator as its ^desired.  This
establishes a convention that when the desired augmentation of  a  goal  is  an
operator,  then  the  object  of  the  goal  is to achieve a state in which the
operator can be applied.  Within the subgoal, the  superoperator  will  not  be
selected,  since  it  is  known that the operator will not apply to it.  If the
state ever changes so that the operator can apply,  it  will  apply  by  having
productions  fire in the supercontext that modify the state and then reconsider
it.  Thus, the termination of operator  subgoaling  is  done  automatically  by
applying it in the supercontext.

7.5. Execution monitoring
A  small  set  of the default productions print messages at run time, to inform
the user of useful details of execution.  These productions use the  write  and
write2 functions, and the text they produce is not incorporated in chunks.

Currently, three types of information are printed:

   1. Goal success and failure.

      A  goal  succeeds  when  the  state in the subgoal is augmented with
      ^partial-success, ^require-success, or ^success.  A goal fails  when
      it   is   augmented  with  ^partial-failure,  ^prohibit-failure,  or
      ^failure.  Section 7.3.3.3 describes use of these symbols  as  state
      augmentations.

   2. Values of objects evaluated in the selection space.

      When  an  evaluation object is augmented with either ^symbolic-value
      or ^numeric-value, the value of that attribute is printed.

   3. Attribute impasses.

      When an impasse object for a non-context slot enters working memory,
      a message describing its structure is printed.

These  monitoring  productions  can be disabled by augmenting the top goal with
^verbose false.
8. Encoding A Task in Soar
Encoding a task in Soar requires three stages: mapping the problem  description
into the Problem Space Computational Model (PSCM), mapping the PSCM description
into the abstract Symbol-Level Computational Model  (SLCM),  and  then  finally
mapping  the  abstract  SLCM  on  to  the  actual  syntax  of  Soar.  The prior
discussions of the Blocks World in Chapters 2 and 2 3 emphasized the  PSCM  and
abstract  SLCM.    In this chapter we map the pseudo-productions for the Blocks
World developed in Chapter 3 onto Soar.  This  requires  mapping  the  abstract
descriptions   of   productions  on  to  Soar's  syntax  and  deciding  on  the
representations that will be used for the problem spaces, states, and operators
employed in the task.

Our  approach will parallel the earlier presentations on encoding a task, where
the knowledge is organized by relevant PSCM level functions.  The basis for the
second  stage  is  a  set of templates for productions that perform the various
PSCM operations.  These templates are in Appendix II on page 185 and  they  are
the  basis  of all of the productions in the chapter.  The suggested method for
adding knowledge to Soar is to fill in  these  templates  with  domain-specific
information.

In  implementing  a  task,  a  decision  must be made as to whether the task is
executed by manipulating  and  sensing  an  external  environment,  or  through
internal  simulation.    Often  the  decision is made by the task specification
itself, such as if Soar is being used to control a mobile robot.  But for  many
tasks,  especially those implemented as research projects, it is up to the user
to decide.  For example, in solving the  Blocks  World,  do  the  blocks  exist
outside of Soar, possibly in a simulator or on a table being viewed by cameras?
Or is the problem a ``mental'' exercise for Soar,  where  it  only  manipulates
internal  representations  of  blocks and it has direct and complete control of
their existence?  The first case requires the  use  of  the  input  and  output
facilities described in Chapter 6.

In this chapter we present an internal implementation of the Blocks World where
the goal is to place block A on top of B, and B on top of C, which in turn must
be  on  the  table.    This  presentation  includes  productions for all of the
required  knowledge.    We  will  also  present  extensions  to  the   original
description  of  the  Blocks  World  in  which we demonstrate all of the common
subgoals that arise during a task.  In these sections we will include solutions
to  common  problems  that arise in Soar.  Many of the interface functions from
Chapter 9 are included in traces to demonstrate their common uses.

Throughout this chapter we will include actual  productions.    Each  of  these
productions  has  a name. We have created a set of conventions for naming in an
attempt to make it easy to determine the purpose of a production based  on  its
name.    The  convention  for  naming  productions  is  based  on the following
template:
    [context]*[PSCM function]*[PSCM object type]*[name(s)]
The [context] describes  the  general  context  in  which  this  production  is
applicable,  usually  the  name  of the relevant goal.  All default productions
have default as the context name. The [PSCM object type] is the type of context
object  that  is  affected by the production, being either goal, problem-space,
state, or operator.  The [PSCM function] is the PSCM function performed by  the
production:  proposal,  comparison, selection, refinement, evaluation, testing,
application, termination, and detection.  The [name(s)] is the the name of  the
PSCM  object  the  production  is about, or some other descriptive term for the
objects being augmented.

8.1. Task representation
This section presents some general issues concerning  representation  in  Soar,
starting  with general issues of object representation, then specific issues of
representation of states, and concludes by deriving a plausible  representation
scheme for the blocks-world problem.



8.1.1. Object representation issues
One  of  the reasons for paying careful attention to representation is that the
representation of data in working memory directly  affects  the  generality  of
learning.    A  prime  reason is that the conditions of chunks are based on the
working memory elements matched by productions and not the  conditions  in  the
productions themselves. A second reason is that different representations allow
more or less direct access to different units of knowledge.  If a piece of data
can  be  accessed only by also accessing other data, chunking will be unable to
separate out only the relevant access.  To date we  do  not  have  an  complete
theory  of  how a given situation should be represented in Soar; however, we do
have a set  of  general  rules  that  should  be  obeyed  when  deciding  on  a
representation  for  objects  in working memory.  Each of these is discussed in
detail below.

   1. Constants should appear only in places  where  specific  values  are
      explicitly  necessary; they should not be used when equality between
      values is all that is needed;

   2. All relevant relations between objects  and  predicates  on  objects
      should  be  represented  explicitly in working memory (as opposed to
      being implicit within production conditions);

   3. All functionally independent uses of a concept should be represented
      independently;

   4. Disjunctive  tests  should be handled by explicitly representing the
      disjunction  in  working  memory  (rather  than  by  using  <<>>  in
      production conditions).


8.1.1.1. Constants
Constants  allow productions to be sensitive to specific symbols.  A production
can test two different aspects of a constant: it can test the exact value of  a
constant,  or  it can test that a constant in one condition is equal to another
constant in another condition.  When testing the exact value of a constant, the
constant   must   appear  explicitly  in  the  conditions  of  the  production.
Therefore, the problem solving is dependent on that  specific  value,  and  any
chunk  built  to  summarize  the  problem  solving would correctly contain that
constant.

When testing the equality of two constants, the constant need not appear in the
production.    Instead,  the  production can contain a variable that is matched
against both occurrences of the constant.  Therefore, the  problem  solving  is
independent  of  the  specific values of the constants, being dependent only on
the fact that they are equal (or  not  equal).    A  chunk  would  nevertheless
include  the specific constants because chunking determines conditions based on
the working memory elements and not the original production  conditions.    The
problem arises because the constant is being overloaded with two functions: its
specific value, and its equality relation to other constants.  The solution  to
this  problem is to separate out the "identity" of a constant from its specific
value.  This is done by representing the constant using a Soar  object  (rather
than  just  a  symbol).    The  identifier  of  the Soar object can be used for
equality tests on the constant (as the chunker variablizes  object  identifiers
after  back-tracing), and the constant's specific value can be tested (and thus
included in chunks) by accessing it through its corresponding object.

To illustrate this point, consider two alternative representations of the ontop
relation  that  might  be  used  in the Blocks World to signify that block A is
above block B. In the first case, the value of the ontop augmentations  is  the
name  of  the  block (B).  In the second case, the value of the augmentation is
the identifier of an object (represented by  variables  in  the  example)  that
contains the name of the blocks.

    Case 1:  (block <A> ^ontop B ^name A)

    Case 2:  (block <A> ^ontop <B> ^name A)
             (block <B> ^name B)

Using  the  second  representation,  a  production can test the equality of two
objects by testing only the identifier and not the name.  During chunking,  the
identifier  is  variablized  so  that  only  the  equality  test  remains.  One
difficulty with this approach is that it requires that  all  references  to  an
object use the same identifier.  So, for example, in Case 2 as described above,
working memory might contain:

    (block a22 ^ontop b26 ^name A)
    (block b26 ^name B)

(where a22 and b26 are Soar-generated identifiers).  Now if we wished to add  a
block C which is left-of B, we must find and use B's identifier (b26).  This is
done in a production by matching block  B's  object,  with  conditions  in  the
production as follows:

      (state <s> ^block-set <B>)
      (block <B> ^name B)
    ...
    -->
      (state <s> ^block-set <C> + &)
      (block <C> ^name C ^left-of <B>)


8.1.1.2. Predicates
For  many  applications,  it  is  necessary  to test numeric predicates such as
less-than and greater-than in the conditions of productions.  Soar  allows  the
inclusion  of  these  predicates  in  the conditions; however, they can lead to
overly specific chunks. If a predicate is used in a production  in  a  subgoal,
the  resulting  chunk will contain the exact value that satisfied the predicate
because chunking does not examine the conditions of  productions,  but  instead
bases chunks on the working memory elements that matched the conditions.

This  problem  can  be  avoided by representing all relevant numeric predicates
explicitly in working memory.  The representation  in  working  memory  can  be
tested  through  a  symbolic  match  of  a  production, leading to a chunk that
includes the general test instead of the specific value.

As an example, consider trying to match a  block  that  is  bigger  than  block
A.  The  first  case  has  the  predicate  contained  in  the  condition of the
production and the resulting condition for a chunk contains the exact constants
that  were  in  the  original working memory elements.  The second case has the
predicate represented explicitly in working memory.    This  leads  to  a  more
general  chunk  that  includes  the  predicate  and not the exact values of the
original example.

    Case 1:
       original        (object <A> ^type block ^size <size-A> ^name A)
       conditions      (object <B> ^type block ^size > <size-A>)

       chunk           (object <O1> ^type block ^size 14 ^name A)
       conditions      (object <O2> ^type block ^size 19)

    Case 2:
       original        (object <A> ^type block ^size <size-A> ^name A)
       conditions      (object <B> ^type block ^size <size-B>)
                          (number <size-A> ^less-than <size-B>)

       chunk           (object <O1> ^type block ^size <size-A> ^name A)
       conditions      (object <O2> ^type block ^size <size-B>)
                          (number <size-A> ^less-than <size-B>)

The second approach requires that the size values are represented  as  separate
objects  as  well  as  requiring that the relation is represented explicitly in
working memory.  But where do the explicit representations of  predicates  come
from?  Determining which predicates must be available requires a little reverse
engineering, and in general,  will  require  domain-specific  productions  that
compute  the  predicates  only  when they are needed.  For many tasks it may be
possible to learn the productions that compute these predicates.  One  possible
approach is to have a predicate-creation problem space that is invoked whenever
an impasse arises because a required predicate has not been computed.


8.1.1.3. Functional overloading
In any representational scheme, it is possible to overload a single symbol with
many  different meanings. For example, if the state contains the description of
an algebra problem, it might have  the  concept  left  used  in  two  different
contexts,  to  represent  expressions  on  the  left  side of equal sign and to
represent terms on the left side of another operator, such as plus.  These  two
different  meanings  of left are functionally independent.  However, if both of
these are tested in a problem solving episode, the resulting chunks can contain
tests  making  them  dependent.  That is, any tests concerning the sides of the
equation may be dependent on tests of sides  of  the  operator.    This  arises
because chunking assumes that if the same identifier is used in multiple places
(in this case, the identifier of the object with the augmentation ^name  left),
then  a chunk must test that it is the same, even though in this example it did
not have to be the same.  The appropriate solution to this problem is to create
two symbols, possibly left-expression and left-term.


8.1.1.4. Disjunctive tests
Productions  in  Soar  allow  disjunctive  tests  (by  using  the  <<>> syntax,
described in Section 4.2.2.4 on page 20); these tests match if one of a set  of
augmentations  appears  in  working  memory.    The use of disjunction allows a
production condition to be more general, but just as with predicates,  chunking
does  not  capture that generality.  If a disjunction is used in a production's
condition  (e.g.,  for  the  names  of  two  problem   spaces,   such   as   <<
problem-space-one  problem-space-two  >>),  a  chunk  that  summarized problem-
solving including a firing of that production would include a test for only one
of the two names, not both (since the chunker only examines contents of working
memory, and not the conditions of productions).  This would make the chunk more
specific than necessary.

As  an  example,  consider  the case where a production may apply in one of two
problem spaces, problem-space-one and problem-space-two.  Assume it applies  in
problem-space-one  in  this  case.  If a disjunctive test (<< problem-space-one
problem-space-two >>) is used in the production conditions, the chunk will only
test for problem-space-one.

To  solve  this  problem,  the  disjunction should be reified by creating a new
concept for the disjunction.  A symbol can  be  created  which  represents  the
disjunctive  condition,  and  this symbol will then appear in the conditions of
chunks.    Continuing  the  example,  we  could  create  a   new   augmentation
space-one-or-two as follows:

    (sp problem-space-one-or-two*elaborate*add*space-one-or-two
       (goal <g> ^problem-space <p>)
       (problem-space <p> ^name << problem-space-one problem-space-two >>)
    -->
       (problem-space <p> ^space-one-or-two t))

The  production that formerly contained the disjunctive test would be rewritten
using the new augmentation instead of the disjunction:

    (sp problem-space-one-or-two*THE-PRODUCTION
       (goal <g> ^problem-space <p> ...)
       (problem-space <p> ^space-one-or-two t)
    ...

And the chunk will test for the following condition:

       (problem-space <p> ^space-one-or-two t)

Thus the chunk is general in that it may apply in either problem space.



8.1.2. State representation issues
The representation for a state can affect the efficiency and the generality  of
problem  solving  and learning.  From our experience, efficiency and generality
are maximized if productions are able to test and modify only those aspects  of
the problem that are necessary to perform the required functions.

In practice, this translates into two rules:

   1. All relevant knowledge should be represented explicitly;

   2. Dynamic and static information should be represented independently.

Relevant  knowledge  should  be  represented  explicitly  as  opposed  to being
implicit within the conditions of productions.  For example, if it is  relevant
that one block is larger than another, this should be represented explicitly in
working memory with a ^larger-than annotation (or some such), rather than being
tested  for  implicitly  in  productions, for example by testing that block A's
^size is greater than block B's (see Section 4.2.2.5 on page 20).

Static information remains constant throughout all states in the problem space.
For  example, in a problem space for stacking blocks, the size, name, and color
of a block will not be changed by  any  of  the  operators  that  move  blocks.
Dynamic  information  is information that does change from state to state, such
as the location of a block in our example.

By representing the dynamic information  independently,  it  can  be  modified,
copied, or tested without accessing the static information, thus maximizing the
generality of  any  learning  dependent  on  it.    That  is,  we  can  compare
relationships  without  testing static information explicitly.  For example, if
we wanted to test that two blocks were on both on top  of  a  third  block,  we
could  test  for  the  equality  of the relationship between the blocks without
explicitly testing the blocks' names.  This would  result  in  a  more  general
chunk (see Section 8.1.1.1 on page 37).

In  addition, using an independent representation of dynamic information allows
us to easily represent multiple states referring to the same objects (i.e., the
current  state  and  the  desired  state).    The  dynamic  information will be
different for the different states, but the  static  information  will  be  the
same.  Thus the static information does not need to be replicated.

For  different problem spaces, different information will be static or dynamic.
For instance, in our example, if we included operators that allowed us to paint
the blocks, then color would become a dynamic property.  Thus, the structure of
the representation of a situation will be dependent on the problem  space  used
to  attempt  a goal.  An implication of this is that the extension of a problem
space through the discovery  of  a  new  operator  may  require  modifying  the
underlying state representation.

In the remainder of this section, we derive a representation for a state of the
Blocks World task that represents the relevant data explicitly  and  represents
dynamic  and  static  information  independently.    As  a general strategy, we
suggest representing states as a set of objects.   (In  this  context  we  mean
conceptual  objects,  such as blocks, rather than Soar working memory objects.)
Each object has a representation of its dynamic  properties  which  contains  a
pointer to its static representation.

In the Blocks World task, the relevant knowledge is:

   1. The types of the available objects: blocks and a table.

   2. The blocks being manipulated.

   3. The names of the blocks.

   4. The table that the blocks can rest on.

   5. The  ontop  relationship  between blocks and the table, such as that
      one block is on top of another block, or that a block is on  top  of
      the table.

   6. The property of a block that its top is clear.

   7. The  property  that  the  table  is always clear enough to hold more
      blocks.

For a simplified internal model (where it is a assumed that the table is  large
enough  to  hold  all  of the blocks), this information is sufficient.  If this
were a task performed by a real robot, we would include additional information,
such as the x and y coordinates of the blocks, and the size and orientations of
the blocks.

All of this information should be represented explicitly in working  memory  so
that  it  can  be directly matched by productions.  Any predicate which must be
tested by productions should be explicitly placed  in  working  memory,  as  in
Section  4.2.2.5  on  page 20, as opposed to being "computed" implicitly within
production conditions.

One possible representation that makes all of the relations explicit  is  model
based.    In  a  model-based representation, each object represented in working
memory directly corresponds to an object in the  situation  being  represented.
In  this  case,  each  object  corresponds  to  a  block  or to the table.  The
augmentations of  the  objects'  representations  correspond  to  the  objects'
properties  and the relations between the objects.  Using this representational
scheme, we could represent the state where block A is on top of block B,  block
B is on the table, and block C is also on the table as follows:

    (state <state> ^objects <table> <block-A> <block-B> <block-C>)
    (object <block-A> ^name A     ^type block ^clear yes ^ontop <block-B>)
    (object <block-B> ^name B     ^type block ^clear no  ^ontop <table>)
    (object <block-C> ^name C     ^type block ^clear yes ^ontop <table>)
    (object <table>   ^name table ^type table ^clear yes)

In  using  this representation, the blocks are referenced by their identifiers,
such as <block-A>, instead of their name, such as A. If the  names  were  used,
any  access  of  the  block would test the name, even if it was irrelevant (see
Section 8.1.1.1 on page 37).

This representation makes it difficult to  copy  the  state  without  accessing
irrelevant data.  In copying the state for a lookahead search, constant, static
augmentations, such as the name and the type augmentations, must be copied  (so
that  we  can  compare  the current to the desired state), even though only the
under and ontop augmentations can be modified in the lookahead search.   As  we
have continually been preaching, accesses to these specific constants will show
up in chunks and thus make learning undergeneral.

A more subtle problem arises when another state must be represented that refers
to  the same objects, such as the desired state of a goal.  A desired state may
represent some constraints on the blocks that must  be  achieved  in  order  to
satisfy  the  goal.    For example, the goal may be to stack the blocks so that
block A is on block B and block B is on block C, which is on the table.    This
could be represented as:

    (state <dstate> ^objects <dtable> <dblock-A> <dblock-B> <dblock-C>)
    (object <dblock-A> ^name A ^ontop <dblock-B>)
    (object <dblock-B> ^name B ^ontop <dblock-C>)
    (object <dblock-C> ^name C ^ontop <dtable>)
    (object <dtable>   ^name table)

However,  with this representation, there is not a single object representing a
given block.  For example, block A is  represented  by  objects  <block-A>  and
<dblock-A>.    Thus,  each  different  use  of  an  object  is represented by a
different object in working memory.  Therefore, in order  to  determine  if  an
object  in  the  current  state  meets  the constraints of the desired state, a
production must match two object structures and test that they  have  the  same
constant for a name.  As described in Section 8.1.1.1 on page 37, this leads to
overly specific chunks because they will test the specific names of the  blocks
when equality is all that is needed.

One  way  to  avoid these problems is to have a single representation of all of
the static properties of an object, with all of the  dynamic  structure  of  an
object  represented separately.  The dynamic structures are specific to a given
state, so they are accessed through augmentations of a state.    We  will  call
these dynamic structures object-dynamic.

The  static  structures  are  accessed  through  augmentations  of  the dynamic
objects, and are called ^object-static. Using this representational scheme, the
initial and desired states presented earlier are represented as follows:

    (state <state> ^object-dynamic <block-A-dyn> <block-B-dyn>
                                <block-C-dyn> <table-dyn>)
    (object-dynamic <block-A-dyn> ^object-static <block-A>
       ^clear yes ^ontop <block-B>)
    (object-dynamic <block-B-dyn> ^object-static <block-B>
       ^clear no  ^ontop <table>)
    (object-dynamic <block-C-dyn> ^object-static <block-C>
       ^clear yes ^ontop <table>)
    (object-dynamic <table-dyn>   ^object-static <table>
       ^clear yes)

    (state <dstate> ^object-dynamic <dblock-A-dyn> <dblock-B-dyn>
                                                   <dblock-C-dyn>)
    (object-dynamic <dblock-A-dyn> ^object-static <block-A>
       ^ontop <dblock-B>)
    (object-dynamic <dblock-B-dyn> ^object-static <block-B>
       ^ontop <dblock-C>)
    (object-dynamic <dblock-C-dyn> ^object-static <block-C>
       ^ontop <dtable>)

    (object-static <block-A> ^name A     ^type block)
    (object-static <block-B> ^name B     ^type block)
    (object-static <block-C> ^name C     ^type block)
    (object-static <table>   ^name table ^type table)

This representation makes it possible to compare the identity of objects in the
current and desired states for equality without testing any specific constants.

Additional static information, such as the color, size, or shape of a block can
be  added to the object-static representation.  Additional dynamic information,
such as the exact x, y, and z location  of  an  object  can  be  added  to  the
object-dynamic.

This representation has three problems.  First, when creating the desired state
(or other states  that  are  alternatives  to  the  current  state),  the  same
identifiers  for  the  static  object  information  must  be  used.  This often
requires matching an abstract description of  the  desired  state  against  the
current  state to determine the identifiers of the internal descriptions of the
objects.  Although this requires testing the specific values of  constants,  it
does  not affect the chunks learned during problem solving, because the results
of the subgoal will not be dependent on the specific values of  the  constants,
but  only  on  the  identifiers.    Thus  this  process does not lead to overly
specific learning.

The second problem  with  this  representation  is  that  it  requires  that  a
commitment  is  made  to  which information is dynamic and which information is
static when the problem is set up.  Thus, a preanalysis of the operators of the
problem  space maybe necessary.  If new operators are discovered during problem
solving, it may be  necessary  to  dynamically  modify  the  structure  of  the
representation (and this could be difficult).

The third problem with this representation is that it uses a multi-attribute as
an augmentation of the state.   Multi-attributes can decrease the efficiency of
the production matches, as described in Section 4.2.4 on page 21, and should be
avoided if possible.  One possible approach is to explicitly maintain  a  focus
of  attention  on  a  subset of the objects, thus reducing the cost of matching
productions that access the objects focussed on.  The  problem  with  focus  of
attention mechanisms is that they require deliberate selection of which objects
should be attended to, and thus exact  their  own  efficiency  costs;  however,
these  selections  are  open  to  control through preferences, and thus, can be
minimized with additional knowledge.

To reduce the negative affect  of  the  multi-attribute,  the  multi-attributes
function (described in Section 4.2.4 on page 21) should be used.  In this case,
since ^object-dynamic is a multi-attribute of the state and the desired  state,
we would use the following call:

    (multi-attributes  '((state object-dynamic) (desired object-dynamic)))

8.2. Initialization
The  first  step  in  running  a  task in Soar is initialization, which usually
involves emptying working memory,  selecting  run-time  options,  and  possibly
adding some initial elements to working memory.



8.2.1. Starting up soar
The  suggested method for starting Soar is to call the function run-task with a
numeric argument specifying the number of decisions to run (see  Section  9.5.4
on  page  156).  If no argument is given, Soar will run until it is interrupted
by a carriage-return from the keyboard.  Run-task automatically calls functions
that  allow the user to select run-time options as well as calling the function
init-soar, which initializes Soar by emptying working memory (see Section 9.2.1
on  page 151).  When Soar starts with an empty working memory, the architecture
creates a goal that has nil as its supergoal:  (goal <g> ^object nil).  This is
the top-goal and the only goal with nil as its supergoal.

When  Soar  starts  up,  it  has default knowledge loaded in that automatically
proposes a name for the top-level goal as well as a top-level problem space and
state  (see  Section 7 on page 33).  These are proposed with accompanying worst
preferences so  that  they  will  be  selected  only  if  there  are  no  other
alternatives.    If  they  are  selected by the decision procedure, the initial
trace will look as follows:

    <1 soar> (run-task 2)

    0   G: G1
    1   P: P2 (top-ps)
    2   S: S4 (top-state)

A summary of the current goal stack can be printed using pgs, which stands  for
print  goal stack (see Section 9.7.2 on page 164).  In this case, there is only
the single goal and the results are as follows:

    <2 soar> (pgs)

        G: G1 (top-goal)
        P: P2 (top-ps)
        S: S4 (top-state)
    Decision Cycle 3

The contents of working memory can be printed using  the  sppwm  function  (see
Section 9.7.7 on page 165). In general, sppwm prints out all objects in working
memory that match its arguments, but when given no arguments, it prints out all
of working memory.

    <3 soar> (sppwm)

    (goal g1 ^problem-space p2 p2 + ^state s4 s4 + ^object nil
             ^name top-goal ^desired d3)
    (problem-space p2 ^name top-ps)
    (state s4 ^io-state s4 ^name top-state)


    <4 soar> (sppwm state)

    (state s4 ^io-state s4 ^name top-state)

The  selection of problem space p2 is represented in working memory as (goal g1
^problem-space p2).  The acceptable preference created to select p2 is also  in
working  memory  and  is  represented  as  (goal g1 ^problem-space p2 +).  Soar
prints both of these together in a shorthand as (goal g1 ^problem-space  p2  p2
+).  Similarly, state s4 is the current state for goal g1 and has an acceptable
preference in working memory.  The goal is augmented with ^object nil  (created
by  Soar),  signifying  that  it  does  not have a supergoal.  The goal also is
augmented with a name (^name top-goal)  and  a  desired  state  (^desired  d3).
Initially the desired does not have any augmentations.

The  problem space has a single augmentation with its name (^name top-ps).  The
state has an augmentation for its name (^name top-state)  and  an  augmentation
called  ^io-state that points to the top state in the goal stack, which in this
case is s4.  All input and output goes through the top state (see Chapter 6  on
page  26) and a general convention is to augment states with ^io-state pointing
to the top state.  This allows uniform access  to  input  and  output  for  all
levels of goals.  States representing hypothetical situations (as in lookahead)
would not have this augmentation.



8.2.2. Initializing Soar to run a task
In order for the system to work on the Blocks World problem, there  must  be  a
goal  in  working  memory  to  solve the problem.  The goal to solve the Blocks
World could be arise in one of two possible ways.

   1. The Blocks World is the only task that the system can perform.   The
      top  goal  in  working memory then becomes the goal of the task.  In
      this case, the problem can be initialized in one of two ways:

         a. Productions are added by the user to  augment  the  top  goal.
            One  production  tests for (goal <g> ^object nil) and augments
            the goal with  the  appropriate  desired  state.    Additional
            productions  then propose the initial problem space and state.
            Below is an example of the first  production  for  the  Blocks
            World.

              (sp top-goal*elaborate*goal*solve-blocks-world
                (goal <g> ^object nil)
              -->
                (goal <g> ^desired <d> ^name solve-blocks-world)
                (desired <d> ....))

         b. The   functions  init-wm  and  init-context  can  be  used  to
            initialize  the  top  context  and  working  memory.     These
            functions  allow  the  user to pre-specify the initial context
            before any Soar productions are matched.  (see Sections  9.3.1
            on  page 151 and 9.3.3 on page 152.) The function init-wm acts
            like the action side of a production, creating preferences for
            all  of  the  objects  that are arguments to it.  The function
            init-context is a special argument for init-wm,  allowing  the
            user  to specify (using variables) the initial identifiers for
            a subset of the top context.

              (init-wm
                (init-context <g> <p> <s>)
                (goal <g> ^desired <d> ^name solve-blocks-world)
                (problem-space <p> ^name build-tower)
                (state <s> ...)
                (desired <d> ...))

   2. There are many tasks that the system can work on and stacking blocks
      is but one.  In this case, there must be an operator that represents
      the task of stacking blocks.  This operator  is  proposed  and  once
      selected,  a  no-change  impasse  arises  along  with  an associated
      subgoal in which the task is performed.

The second option is more general and preferred because it allows the system to
work  on many different tasks.  The first option is often used when debugging a
new task.  For the remainder of this chapter, we assume the second option, that
is, the task of stacking blocks arises as an operator in some supergoal.

In  general,  the initial state of a top-level task is defined by input from an
environment.   Unfortunately,  this  requires  writing  the  input  and  output
functions  that  support  interaction  with  a  real Blocks World or at least a
simulator.  In this example, we will assume that the system recalls the initial
state from its long-term production memory.  Although this assumption restricts
the system to attempting problems that start with  this  state,  other  initial
states  can  be used by simply changing the production that recalls the initial
state.  The problem we will work on is the same one as used in Chapters  2  and
3,  and as shown in Figure 2-5 on page 7 with an initial state in which block A
is on block B, and blocks B and C are on the table.  The goal is  to  create  a
tower with A on B, B on C, and C on the table.

Once  the  initial  state  is selected, it will be modified by internal actions
instead of reflecting the perception of changes  to  an  external  environment.
The production to augment the initial state is as follows:

    (sp top-goal*elaborate*initial-state
      (goal <g> ^name top-goal ^state <s>)
      (state <s> ^name top-state)
      -->
      (state <s> ^object-dynamic <table-dyn> + &,  <blockA-dyn> + &,
                                 <blockB-dyn> + &, <blockC-dyn> + &)
      (object-dynamic <blockA-dyn> ^ontop <blockB> ^clear yes
            ^object-static <blockA>)
      (object-static <blockA> ^name A ^type block)
      (object-dynamic <blockB-dyn> ^ontop <table>  ^clear no
            ^object-static <blockB>)
      (object-static <blockB> ^name B ^type block)
      (object-dynamic <blockC-dyn> ^ontop <table> ^clear yes
            ^object-static <blockC>)
      (object-static <blockC> ^name C ^type block)
      (object-dynamic <table-dyn> ^object-static <table> ^clear yes)
      (object-static <table> ^name table ^type table)
      (write1 (crlf) "Initial state has A on B and B and C on the table."))

Notice  that  all  of  the  ^object-dynamic  augmentations  of  the  state  are
multi-attributes and thus have parallel preferences for  each  of  the  values.
The  default  assumption  in Soar is that only a single value is allowed for an
augmentation.  If there is more  than  one  value  that  can  be  selected,  an
attribute impasse will arise, unless parallel preferences are used.

To  improve  efficiency,  it  is  important  to declare multi-attributes at the
beginning of a task (see Sections 9.17.1 on page 178 and  4.2.4  on  page  21).
Thus, the following function call is included at the beginning of the file that
defines the Blocks World task.

    (multi-attributes  '((state object-dynamic) (desired object-dynamic)))

The write1 action at the end of the production provides  a  simple  method  for
printing  comments  during a run.  In general, text I/O should be used, but for
simple tracing, write1 is sufficient.

Production top-goal*elaborate*initial-state matches  the  current  contents  of
working memory and will fire on the next elaboration cycle.  The user can query
Soar to determine which productions have new instantiations waiting to fire  by
using the (ms) function (see Section 9.9.1 on page 167).

    <5 soar> (ms)

    Instantiations:
    top-goal*elaborate*initial-state
    default*propose*operator*wait

The results of this function show that there are two productions ready to fire.
One of these, top-goal*elaborate*initial-state, we expected,  but  there  is  a
second  default production ready to fire, called default*propose*operator*wait.
We can print out this production  using  the  function  spr  which  prints  out
productions and working memory objects (see Section 9.7.5 on page 165).

    <6 soar> (spr default*propose*operator*wait)

    (sp default*propose*operator*wait
       (goal <g> ^problem-space <p> ^state <s>)
       (problem-space <p> ^name top-ps)
     -->
       (goal <g> ^operator <o> + <o> <)
       (operator <o> ^name wait +))

This  production  creates  the  wait  operator  with  an  acceptable  and worst
preference (see Section 7.1 on page 33).  The wait operator  will  be  selected
when  no  other  operator  is acceptable for the top problem space.  Thus, when
there is nothing else for the system to do, it will wait.

If we continued the run at the default  level  of  trace,  there  would  be  no
indication  of  specific  production  firings;  only  context decisions will be
traced.  To change the trace level, the function (watch) is called (see Section
9.6.6  on page 160). The default level of trace is 0 and it prints out only the
selections of goals, problem spaces, states, and operators.  To see changes  to
working  memory,  watch  level 2 is necessary.  To run only a single production
firing cycle, (run 1) is used (see Section 9.5.3 on page 156).

    <7 soar> (watch 2)

    <8 soar> (run 1)
    --Preference Phase--
    Initial state has A on B and B and C on the table.
    Firing 3:9 top-goal*elaborate*initial-state 6 21 20
    Firing 3:9 default*propose*operator*wait 14 12 21
    --Working Memory Phase--
    =>wm: 74: (goal g1 ^operator o14 +)
    =>wm: 76: (operator o14 ^name wait)
    =>wm: 77: (object-dynamic t6 ^object-static t12)
    =>wm: 78: (object-dynamic t6 ^clear yes)
    =>wm: 79: (object-static t12 ^name table)
    =>wm: 80: (object-static t12 ^type table)
    =>wm: 81: (state s4 ^object-dynamic t6)
    =>wm: 82: (state s4 ^object-dynamic b7)
    =>wm: 83: (state s4 ^object-dynamic b8)
    =>wm: 84: (state s4 ^object-dynamic b9)
    =>wm: 85: (object-dynamic b9 ^ontop t12)
    =>wm: 86: (object-dynamic b9 ^clear yes)
    =>wm: 87: (object-dynamic b9 ^object-static b13)
    =>wm: 88: (object-dynamic b8 ^ontop t12)
    =>wm: 89: (object-dynamic b8 ^clear no)
    =>wm: 90: (object-dynamic b8 ^object-static b10)
    =>wm: 91: (object-dynamic b7 ^ontop b10)
    =>wm: 92: (object-dynamic b7 ^clear yes)
    =>wm: 93: (object-dynamic b7 ^object-static b11)
    =>wm: 94: (object-static b13 ^name c)
    =>wm: 95: (object-static b13 ^type block)
    =>wm: 96: (object-static b11 ^name a)
    =>wm: 97: (object-static b11 ^type block)
    =>wm: 98: (object-static b10 ^name b)
    =>wm: 99: (object-static b10 ^type block)
    ***break***


During the preference phase, the productions fire, creating  their  preferences
and  executing any actions, such as write1 which prints out ``Initial state has
A on B and B and C on the table.'' in this trace.

The creation of the preferences does not show up during a watch 2  trace,  only
in  a  watch  3  trace.  The firing of a production is labeled with the current
decision (3) and the current elaboration cycle (9).  The name of the production
is  followed  by  the time-tags of the working memory elements that matched the
conditions of the production.  Thus, working memory  elements  6,  21,  and  20
matched the conditions of top-goal*elaborate*initial-state.

During the working memory phase, all of the changes are made to working memory.
Additions are denoted by =>, while removals are denoted by <=.  In  this  case,
no  working  memory elements are removed, and working memory elements 74-99 are
created.

The numbers 74-99 are the time-tags of the individual working memory  elements.
Time-tags  are  used  by  other  user interface functions, such as smatches and
full-matches.  They can be used to  print  out  an  individual  working  memory
element by using (wm) (see Section 9.7.9 on page 166).

    <9 soar> (wm 74)

    74:(GOAL G1 ^OPERATOR O14 +)

This working memory element is the acceptable preference for the wait operator,
object o14.

8.3. Proposal of the operator to perform the task
Once the top goal, problem space, and  state  are  selected,  the  operator  to
perform the task can be proposed.  The task operator would usually contain some
description of the desired state that is to be achieved after all, the  purpose
of  an  operator  is to modify the world in some way.  The desired state may be
based on input from the outside (``Please create a stack of blocks with block A
on  block  B,  which is on block C, which is on the table."), as a component of
some other goal (to stack the blocks and line up the spheres), or just  because
the  system  has  the  `urge'  to  do  it (``I just hate it when blocks are not
stacked.'').

For this demonstration, we will assume that the operator for creating  a  stack
of  blocks  A, B, and C is proposed whenever those blocks are available and not
in place.  Different tasks can be attempted by modifying the  productions  that
propose the operator or by adding productions that propose alternative tasks.

In  order to propose the operator, there must be a test that the blocks are not
already stacked.  If such a test is not included, the system  will  continually
try  to  stack  the  blocks  even when they are in position. The easiest way to
encode this test is to add a production that detects when  the  blocks  are  in
position  and  then  test  that the result of this production is not in working
memory.  Below is a production to detect that the blocks are correctly stacked.

    (sp top-goal*elaborate*state*detect-tower
      (goal <g> ^problem-space <p> ^state <s>)
      (problem-space <p> ^name top-ps)
      (state <s> ^object-dynamic <blockA-dyn> <blockB-dyn>
            <blockC-dyn> <table-dyn>)
      (object-dynamic <blockA-dyn> ^ontop <blockB>
            ^object-static <blockA>)
      (object-dynamic <blockB-dyn> ^ontop <blockC>
            ^object-static <blockB>)
      (object-dynamic <blockC-dyn> ^ontop <table>
            ^object-static <blockC>)
      (object-static <blockA> ^name A)
      (object-static <blockB> ^name B)
      (object-static <blockC> ^name C)
      (object-static <table>  ^name table)
      -->
      (state <s> ^object-dynamic <tower> + &)
      (object-dynamic <tower> ^top-block <blockA> ^middle-block <blockB>
                      ^bottom-block <blockC>))

The state is augmented with an object that has a top-block, a middle-block, and
a  bottom-block.    It  could  be further augmented with a type, such as tower,
although it is unnecessary for our example.

The next production tests that the blocks exist and that  there  is  no  tower.
The  test that there is no tower is a conjunctive negation because it tests for
the absence of a set of conditions.  This production  will  match  as  long  as
there  is  no structure in working memory that matches all of the conditions in
the negation.    The  production  creates  an  acceptable  preference  for  the
operator, and augments it with a name and a desired state.

    (sp top-goal*propose*operator*build-tower
      (goal <g> ^problem-space <p> ^state <s>)
      (problem-space <p> ^name top-ps)
      (state <s> ^object-dynamic <blockA-dyn> <blockB-dyn> <blockC-dyn>
                                                           <table-dyn>)
      (object-dynamic <blockA-dyn> ^object-static <blockA>)
      (object-static <blockA> ^name A)
      (object-dynamic <blockB-dyn> ^object-static <blockB>)
      (object-static <blockB> ^name B)
      (object-dynamic <blockC-dyn> ^object-static <blockC>)
      (object-static <blockC> ^name C)
      (object-dynamic <table-dyn>  ^object-static <table>)
      (object-static <table> ^name table)
     -{(state <s> ^object-dynamic <tower>)
       (object-dynamic <tower> ^top-block <blockA> ^middle-block <blockB>
                      ^bottom-block <blockC>)}
      -->
      (goal <g> ^operator <o>)
      (operator <o> ^name build-tower ^desired-state <ds>)
      (desired <ds>  ^ontop-count 3
               ^object-dynamic <dblockA-dyn> + &, <dblockB-dyn> + &,
                               <dblockC-dyn> + &)
      (object-dynamic <dblockA-dyn> ^ontop <blockB> ^object-static <blockA>)
      (object-dynamic <dblockB-dyn> ^ontop <blockC> ^object-static <blockB>)
      (object-dynamic <dblockC-dyn> ^ontop <table>  ^object-static <blockC>)
      (write1 (crlf) "The goal is to get A on B on C on the table"))

It is not absolutely necessary to create an explicit description of the desired
state in working memory.  The task can be performed by a blind search with only
a  test  that  a  tower has been built.  The explicit state description will be
useful for  implementing  means-ends  analysis  to  control  the  selection  of
operators.

In  creating  the  desired  state, this production must match the blocks in the
current state so that  the  identifiers  of  the  blocks  and  table  (<table>,
<blockB>,  and <blockC>) are used in the desired state. This allows the desired
state  to  refer  directly  to  the  objects  in  the  current  state,  thereby
simplifying  the  matching of the desired state against the current state.  The
productions that test the desired state need only  test  the  equality  of  the
identifiers,  and  do  not  have  to test the actual names of the blocks.  This
leads to more generality during chunking (see Section 8.1.1.1 on page 37).

The following trace shows where the build-tower operator is proposed  and  then
selected  by the decision procedure to be the current operator of goal G1.  The
d command is used to advance to the next decision (see 9.5.1 on page 155).

    <10 soar> (d 1)

    --Preference Phase--
    The goal is to get A on B on C on the table
    Firing 3:11 TOP-GOAL*PROPOSE*OPERATOR*BUILD-TOWER 14 12 21 81 89 92 82
                   86 94 83 98 90 80 76 78
    --Working Memory Phase--
    =>wm: 112: (goal g1 ^operator o15 +)
    =>wm: 115: (operator o15 ^name build-tower)
    =>wm: 116: (operator o15 ^desired-state d16)
    =>wm: 117: (object-dynamic d19 ^ontop t13)
    =>wm: 118: (object-dynamic d19 ^object-static b14)
    =>wm: 119: (object-dynamic d18 ^ontop b14)
    =>wm: 120: (object-dynamic d18 ^object-static b11)
    =>wm: 121: (object-dynamic d17 ^ontop b11)
    =>wm: 122: (object-dynamic d17 ^object-static b12)
    =>wm: 123: (desired d16 ^object-dynamic d17)
    =>wm: 124: (desired d16 ^object-dynamic d18)
    =>wm: 125: (desired d16 ^object-dynamic d19)

    --Quiescence Phase--
    =>wm: 126: (goal g1 ^operator o15)
    3:13 decide operator o15
    3   O: o15 (build-tower)
    ***BREAK***

At this point, operator o15 has been  selected  and  the  system  is  ready  to
attempt the task of building a tower.

8.4. Subgoal creation for operator application
The  build-tower  operator  must  be applied in a subgoal, where the individual
blocks can be moved to build the tower.  Once the build-tower operator has been
selected, there are no productions to apply it directly and a no-change impasse
will arise.

    <11 soar> (watch 0)
    T
    <12 soar> (d 1)
    4   ==> G: g21 (operator no-change)

When the subgoal is created, it has a collection of augmentations  that  define
the  type  of impasse.  Using spr (see Section 9.7.5 on page 165), the complete
structure of the goal object can be displayed:

    (goal g21 ^quiescence t ^impasse no-change ^object g1 ^attribute operator
              ^choices none)

Once the subgoal has been created, productions can fire to elaborate  the  goal
with  a  name  and the desired state taken from the operator.  The name for the
goal provides a symbol that  can  be  tested  by  other  productions  that  are
specific  to the goal.  Instead of testing the name, the productions could just
as well test that the  goal  is  a  no-change  for  the  build-tower  operator;
however,  it is much simpler to just test the name.  The refinement of the goal
with the  desired  state  makes  it  possible  to  have  productions  that  are
independent  of the exact type of impasse (in this case operator no-change) and
just test the ^desired augmentation of the goal.   For  example,  a  production
with  means-ends  knowledge  to select operators in the subgoal can compare the
desired state to the current state without ever testing the type of impasse.

    (sp blocks*elaborate*goal*build-tower
        (goal <g> ^object <sg> ^impasse no-change ^attribute operator)
        (goal <sg> ^operator <so>)
        (operator <so> ^name build-tower ^desired-state <ds>)
        -->
        (goal <g> ^desired <ds> ^name build-tower))

8.5. Problem space proposal for subgoal
Once a subgoal is created, a problem space must be proposed.  A  problem  space
symbol  will  act  as  a  cue for proposing and selecting the initial state and
operators in the subgoal.  Operators should be defined such that  any  sequence
of  operator  applications  that  produces  a  final  state  that satisfies the
constraints of the problem.  For example, in the  Blocks  World,  changing  the
name  of  a  block  is  not  a  legal  operation  and would violate an implicit
constraint in the problem description.

If the problem space selection can be made based on the name of the goal,  then
a  simple production such as the one below will be sufficient for problem space
proposal.

    (sp solve-blocks-world*propose*space*blocks-world
      (goal <g> ^name build-tower)
    -->
      (goal <g> ^problem-space <p>)
      (problem-space <p> ^name blocks-world))

Since the variable <p> only appears in the action, it will be bound to a  newly
generated  symbol,  starting  with  the first letter of the variable (something
like p22).  The second occurrence of <p> will use this same symbol.   The  goal
is  augmented  with a name that can be tested by later productions.  After this
production fires and the next decision is made, the cumulative trace at  (watch
0) is as follows:

    0   G: g1
    1   P: p2 (top-ps)
    2   S: s4 (top-state)
    Initial state has A on B and B and C on the table.
    The goal is to get A on B on C on the table
    3   O: o15 (build-tower)
    4   ==>G: g21 (operator no-change)
    5      P: p22 (blocks-world)

8.6. Problem space refinement
A  name for the problem space is usually sufficient for providing the necessary
context for problem solving  in  the  subgoal.    When  the  problem  space  is
elaborated, it will often be with some abstract description of the structure of
its states and operators.  An explicit description  of  the  structure  of  the
states   or  operators  makes  it  possible  to  have  general  techniques  for
manipulating these objects.  The best example of this arises when  a  lookahead
search is to be performed in the subgoal (see Section 8.13 on page 143).

8.7. Proposal of the initial state
When  a  new  problem  space  is  selected for a goal, an initial state must be
proposed and selected.  The initial state can be an existing state in the  goal
hierarchy,  in which case, an acceptable (or require) preference should be used
to select it.  If a new state is to be  created,  an  acceptable  (or  require)
preference  should  be  created  and  the rest of the structure added on during
elaboration.

For subgoals that are applying an operator, the initial state is usually either
the same as the superstate (the state to which the operator was being applied),
or it is a new state with a pointer back  to  the  superstate.    Below  is  an
example for the Blocks World where the same state is used.

    (sp blocks*propose*initial*state*top-initial-state
        (goal <g> ^name build-tower ^problem-space <p> ^object <sg>)
        (problem-space <p> ^name blocks-world)
        (goal <sg> ^state <ss>)
        -->
        (goal <g> ^state <ss>))

If  the  operators  in  the  subgoal create augmentations of the state that are
local to the subgoal, then it is best to have a new state symbol with a pointer
back  to  the superstate.  All access to the relevant data on the superstate is
indirect through this pointer; however, when the subgoal terminates, all of the
temporary  data is automatically removed.  For many tasks, the state in the top
context is important because it is the locus for all input and output.    As  a
convention,  the attribute ^superstate is used for superstates and ^io-state is
used for the top state in which all input  and  output  is  performed.      For
example,  in the Blocks World, the following production would be appropriate if
the operators in the subgoal created temporary structures.

    (sp blocks*propose*initial*state*top-initial-state
        (goal <g> ^name build-tower ^problem-space <p> ^object <sg>)
        (problem-space <p> ^name blocks-world)
        (goal <sg> ^state <ss>)
        (state <ss> ^io-state <ios>)
        -->
        (goal <g> ^state <s>)
        (states <s> ^superstate <ss> ^io-state <ios>))

Using d, we can fire this production and select the state.

    <13 soar> (d 1)

    6      S: S4 (TOP-STATE)

To see the substructure of the state after it is selected, we can use spr  with
a second argument that specifies how many levels of augmentations to print out.
The default is 1, which shows just the augmentations of the object that is  the
argument  to  spr.  By using 2, we can print the augmentations of S4 as well as
one level of substructure:

    <14 soar> (spr s4 2)

    (state s4 ^io-state s4 ^name top-state
              ^object-dynamic b10 b9 b8 t7)
       (object-dynamic t7 ^object-static t13 ^clear yes)
       (object-dynamic b8 ^ontop b11 ^clear yes ^object-static b12)
       (object-dynamic b9 ^ontop t13 ^clear no ^object-static b11)
       (object-dynamic b10 ^ontop t13 ^clear yes ^object-static b14)

8.8. Operator proposal
In our implementation of the Blocks World, there is a single general  operator,
which  moves  a  block  from  one  location  to  another.    For a given state,
instantiations of this operator are created for  moving  each  clear  block  to
either another clear block or the table.  To create the operator instantiations
requires only one production, shown below.   Each  operator  instantiation  has
three  fields:  ^name for the name of the operator, which is always move-block;
^moving-block for the block being moved; and ^destination for the place (either
a block or the table) the block is moving to. At the same time that an operator
is created, an acceptable preference is created for it so that the operator can
be selected.

    (sp blocks*propose*operator*move-block*destination
      (goal <g> ^problem-space <p> ^state <s>)
      (problem-space <p> ^name blocks-world)
      (state <s> ^object-dynamic <blockA-dyn>
                             {<> <blockA-dyn> <blockB-dyn>})
      (object-dynamic <blockA-dyn> ^object-static <blocka> ^clear yes
            -^ontop <blockb>)
      (object-static <blocka> ^type block)
      (object-dynamic <blockB-dyn> ^object-static <blockb> ^clear yes)
      -->
      (operator <o> ^name move-block
            ^moving-block <blocka> ^destination <blockb>)
      (goal <g> ^operator <o> +))

The conditions of this production test that an operator will be created only if
it can apply.  After testing for the name of the problem space, it  tests  that
there is a block that is clear, and another object, which can be either a block
or a table, that is clear.  It also tests that those two  places  are  not  the
same,  so  that it never attempts to move a block on top of itself.  Finally it
tests that there does not exist an ontop relation with the block  to  be  moved
(<block>)  already  on  top  of the place it is being moved to (<destination>).
This is to avoid moving a block onto the table when it is already on the table.

An alternative approach would be to have two  productions,  one  that  proposes
operators  for moving a block onto a second block, and a second production that
proposes moving a block onto the table.  If  this  approach  were  used,  there
would  be  no  need to represent that the table is clear because that knowledge
would be implicit in the production that proposed the operators.

The operator instantiations are created only if they can be  applied,  and  are
automatically  retracted  when  they  no  longer  apply,  so that no additional
productions are required to reject inapplicable operators.  Another alternative
would  be to generate operator instantiations for moving every block onto every
other block  (possibly  including  itself)  and  add  productions  that  reject
operators when they are not applicable.

8.9. Operator comparison
Operator  comparison  is  the  process of creating desirability preferences for
competing operators.  Soar's preference scheme supports  relative  comparisons,
such as that operator o32 is better than operator o25, and it supports absolute
preferences, such as that operator o25 is worst (see Section 9.8.1 on page  166
for more information on the semantics of preferences).

Below  is an example operator-comparison production that prefers operators that
move a block into its position over operators that do  not.    This  production
alone is not sufficient to distinguish between all possible competing operators
(see Section 3.10.6 on page 15).  Additional productions are needed that prefer
operators  that move blocks at the bottom of the tower into place and clear off
blocks that need to be moved.

    (sp blocks*compare*operator*move-block*into-place*better
      (goal <g> ^problem-space <p> ^desired <d>
                ^operator <o1> + ^operator { <> <o1> <o2>} +)
      (problem-space <p> ^name blocks-world)
      (desired <d> ^object-dynamic <dblockA-dyn>)
      (object-dynamic <dblockA-dyn> ^object-static <dblockA>
            ^ontop <dblockB>)
      (operator <o1> ^name move-block ^moving-block <dblockA>
            ^destination <dblockB>)
      (operator <o2> ^name move-block ^moving-block <dblockC>
            ^destination <dblockD>)
     -{(desired <d> ^object-dynamic <dblockC-dyn>)
       (object-dynamic <dblockC-dyn> ^object-static <dblockC>
                                     ^ontop <dblockD>)}
      -->
      (goal <g> ^operator <o1> > <o2>))

The first condition tests for the current problem  space,  state,  and  desired
state.    It  also  includes tests for two acceptable preferences for operators
(^operator <o1> + ^operator <o2> +). By  testing  for  acceptable  preferences,
this  production  can  fire  before  either  operator  is selected.  The second
condition tests the name of the problem space.  The next  two  conditions  test
that  the  desired state has an ontop relation that operator <o1> will achieve.
The remaining conditions test that the result of operator <o2> is not a part of
the desired state.  The action of the production is to create a preference that
makes operator <o1> better than <o2>.

One problem with this production is that it must partially  match  against  all
pairs  of  acceptable operators, which can be computationally expensive. We can
demonstrate this by using the memories function that will show  the  number  of
partial  instantiations  for  expensive productions (see Section 9.17.2 on page
178).  For example, during a run where there are six available  operators,  two
of which move a block into place, memories gives the following information:

    <15 soar>  (memories 2)

    Productions with largest memories
    286: blocks*compare*operator*move-block*into-place*better
    46: blocks*propose*operator*move-block*destination

The  comparison  production has five times the number of partial instantiations
as the next highest production.

A possible alternative is to only match against  one  operator,  and  create  a
unary  preference,  such  as best or worst for that operator.  For example, the
following productions will create a best preference for an operator that  moves
a  block into its desired position, and a worst preference for an operator that
does not move a block into its desired position or onto the table.

    (sp blocks*compare*operator*move-block*into-place*best
      "Prefer moving blocks into their desired location"
      (goal <g> ^problem-space <p> ^state <s> ^desired <d>
                ^operator <o1> +)
      (problem-space <p> ^name blocks-world)
      (desired <d> ^object-dynamic <dblockA-dyn>)
      (object-dynamic <dblockA-dyn> ^object-static <blockA> ^ontop <blockB>)
      (operator <o1> ^name move-block ^moving-block <blockA>
            ^destination <blockB>)
      -->
      (goal <g> ^operator <o1> >, =))

    (sp blocks*compare*operator*move-block*not-into-place*worst
      (goal <g> ^problem-space <p> ^desired <d>
               ^operator <o2> +)
      (problem-space <p> ^name blocks-world)
      (operator <o2> ^name move-block ^moving-block <dblockA>
            ^destination <dblockB>)
      -{(desired <d> ^object-dynamic <dblockA-dyn>)
        (object-dynamic <dblockA-dyn> ^object-static <dblockA>
                                          ^ontop <dblockB>)}
      -(object-static <dblockB> ^type block)
      -->
      (goal <g> ^operator  <o2> <, =))

These productions will be much more efficient to match, as demonstrated below:

    <15 soar>(memories 4)

    Productions with largest memories
    53: blocks*compare*operator*move-block*into-place*best
    46: blocks*propose*operator*move-block*destination
    43: top-goal*propose*operator*build-tower
    32: blocks*compare*operator*move-block*not-into-place*worst

However, these productions will have slightly  different  semantics,  and  will
lead  to different results if additional better preferences are available.  For
example, if operator X moved a block into its desired position, and operator  Y
did  not  move  a  block  into  its desired position, the first production will
create a preference that X  is  better  than  Y.  If  there  is  an  additional
production  that  creates a preference that operator Y is better than X, then a
conflict impasse will arise.  If the productions that create the worst and best
preferences are used, no conflict will arise because the better preference will
dominate and X will be selected.  Thus, for the remainder of  this  example  we
will not include these two productions.

Other  productions  can be added to further control the selection of operators.
The previous productions do not create any preferences  between  two  operators
that  both  move  blocks  into  their desired locations.  Obviously, the system
should prefer stacking lower blocks first.  It should  always  build  from  the
bottom up and never attempt to create partial towers.  The following production
prefers operators that move a block into its desired  position  over  operators
that  will move a block into place on top of the block being moved by the first
operator.  This creates a partial ordering that  leads  to  having  the  bottom
block  always  placed first, followed by the one on top of that and so on until
all blocks are in place.

    (sp blocks*compare*operator*move-block*lower*better
      (goal <g> ^problem-space <p> ^desired <d>
                ^operator <o1> + ^operator <o2> +)
      (problem-space <p> ^name blocks-world)
      (desired <d> ^object-dynamic <dblockA-dyn>
                              { <> <dblockA-dyn> <dblockB-dyn> })
      (object-dynamic <dblockA-dyn> ^object-static <dblockA>
                                    ^ontop <dblockB>)
      (object-dynamic <dblockB-dyn> ^object-static <dblockB>
                                    ^ontop <dblockC>)
      (operator <o1> ^name move-block ^moving-block <dblocka>
            ^destination <dblockb>)
      (operator <o2> ^name move-block ^moving-block <dblockb>
            ^destination <dblockc>)
      -->
      (goal <g> ^operator <o1> < <o2>))

The final operator selection production fires even when it is not  possible  to
move a block into its desired position.  This is the case in our example when A
is on B and both B and C are on the table.  The only available operators are to
move  A onto C or the table and to move C onto A. This final production creates
worst preferences for operators that move blocks onto other blocks,  when  that
is  not  their  desired position.  In general, this allows other operators that
merely unstack blocks to be chosen.

    (sp blocks*compare*operator*move-block*not-into-position*worst
      (goal <g> ^problem-space <p> ^state <s> ^desired <d>
                ^operator <o1> +)
      (problem-space <p> ^name blocks-world)
      (desired <d> ^object-dynamic <dblockA-dyn>)
      (object-dynamic <dblockA-dyn> ^object-static <dblockA>
                                    ^ontop <dblockB>)
      (operator <o1> ^name move-block ^moving-block <dblockA>
                          ^destination { <> <dblockB> <dblockC>})
      (object-static <dblockC> ^type block)
        -->
      (goal <g> ^operator <o1> <, =))

Another operator selection production would  be  required  to  select  randomly
between  operators  that  build  different towers if the desired state is not a
single tower of blocks (see Section 2.3.2 on page 7).

The trace below shows a (watch 1) trace  of  the  proposal  and  comparison  of
operators that lead to the selection of the first operator.

    <16 soar> (watch 1)

    T
    <17 soar> (run 2)

    --Preference Phase--
    Firing 7:25 blocks*propose*operator*move-block*destination
                117 116 119 57 67 68 72 56 53 52
    Firing 7:25 blocks*propose*operator*move-block*destination
                117 116 119 57 67 68 72 59 61 62
    Firing 7:25 blocks*propose*operator*move-block*destination
                117 116 119 59 61 62 70 57 67 68
    --Working Memory Phase--
    --Preference Phase--
    Firing 7:27 blocks*compare*operator*move-block*not-into-position*worst
                117 116 119 112 124 135 136 99 98 97 137 70
    Firing 7:27 blocks*compare*operator*move-block*not-into-position*worst
                117 116 119 112 128 132 133 101 94 93 134 72

Three  operators  are proposed: move A to the table, move A to C, and move C to
A. Worst preferences are created for moving A to C, and moving C  to  A,  since
neither  one  moves  a  block into its desired location.  Moving A to the table
does not move a block into a desired position, but it does move  the  block  to
the table, so it is not made worst.

To  examine  the preferences, the preferences function can be used (see Section
9.8.1 on page 166 for more details).   Preferences  will  display  all  of  the
active preferences for a given identifier and attribute.  In this case, we want
to examine the ^operator attribute of the current goal: g20.

    <18 soar> (preferences g20 operator)

    Accepts:
    (goal g20 ^operator o24 +)   I-Support: 1   O-Support: NIL
    (goal g20 ^operator o23 +)   I-Support: 1   O-Support: NIL
    (goal g20 ^operator o22 +)   I-Support: 1   O-Support: NIL
    Worsts:
    (goal g20 ^operator o24 <)   I-Support: 1   O-Support: NIL
    (goal g20 ^operator o23 <)   I-Support: 1   O-Support: NIL
    Indifferents:
    (goal g20 ^operator o24 =)   I-Support: 1   O-Support: NIL
    (goal g20 ^operator o23 =)   I-Support: 1   O-Support: NIL

All of the currently active preferences are supported by  either  I-support  or
O-support.    I-support  means that the preference is supported by a production
instantiation, while O-support means that a  preference  is  supported  by  the
augmentation  or  application  of an operator (see Section 4.2.1 on page 19 for
more details on support). By examining the preferences it easy to see that only
o22 does not have a worst preference and thus will be selected.

To automatically determine the implications of these preferences without making
the actual decision, the tally function can be used (see Section 9.8.2 on  page
166).  Tally runs the decision procedure for a given identifier and attribute.

    <19 soar> (tally g20 operator)

    Old Preference Tally:
    Status:         nil
    Winning Values: nil
    Impasse Items:  nil

    Decide Trace:

    (G20 operator)
     Acceptable o24((c) (a) move-block) o23((a) (c) move-block) o22((a)
            (table) move-block)
     Post-reject o24((c) (a) move-block) o23((a) (c) move-block) o22((a)
            (table) move-block)
     Post-best o24((c) (a) move-block) o23((a) (c) move-block) o22((a)
            (table) move-block)
     Post-worst o22((a) (table) move-block)

    New Preference Tally:
    Status:         WINNER
    Winning Values: (O22)
    Impasse Items:  NIL
    T
    <20 soar> (d 1)

    --Quiescence Phase--
    7:29 decide operator o22
    7      O: O22 ((a) (table) move-block)

8.10. Operator application
An  operator of a problem space is applied after it is selected by the decision
procedure, i.e., after its identifier  replaces  the  existing  symbol  in  the
operator  slot;  whatever happens while a given identifier occupies an operator
slot comprises the attempt to apply that operator.  Selecting an  operator  and
installing  its  identifier  in  the  operator slot produces a context in which
productions associated with the operator can execute (they contain a  condition
that tests that the operator is selected).

To  apply  an  instantiated  operator  in  the  Blocks World, the state must be
changed so that the moved block is above its destination.  Therefore, the block
being  moved  is now on top of a different object, the object it is moved to is
no longer clear (unless it was the table) and the  object  it  was  on  is  now
clear.

To  maximize  the  generality  of  the  process,  it  is necessary to split the
application of the operator into independent productions.  If multiple  changes
are  performed  by  the  same  production, each change will be dependent on the
complete  conjunction  of  conditions  instead  of  those  that  are  minimally
necessary  for  making  a  change.  When a result is produced by a subgoal, the
conditions of the chunk are based on what was tested in order  to  produce  the
results.   Therefore, chunking generality is maximized if each of these changes
are performed by a separate production that tests only the conditions necessary
for that change.

The  productions in this example delete the ontop augmentation of the state and
create a new ontop augmentation from scratch.

    (sp blocks*apply*move-block*off*remove-ontop
      (goal <g> ^state <s> ^operator <o>)
      (state <s> ^object-dynamic <mblock-dyn>)
      (object-dynamic <mblock-dyn> ^object-static <mblock>
            ^ontop { <> <tblock> <blockb> } - ^ontop <tblock>)
      (operator <o> ^moving-block <mblock> ^destination <tblock>)
      -->
      (object-dynamic <mblock-dyn> ^ontop <blockb> - ))

This production deletes the old ontop augmentation that had the moving block in
it.   The negated condition is necessary so that the production does not delete
the new ontop created by the following production.

This production creates the new ontop relation for the block being moved.

    (sp blocks*apply*move-block*to*create-ontop
      (goal <g> ^state <s> ^operator <o>)
      (state <s> ^object-dynamic <mblock-dyn>)
      (object-dynamic <mblock-dyn> ^object-static <mblock>)
      (operator <o> ^moving-block <mblock> ^destination <tblock>)
      -->
      (object-dynamic <mblock-dyn> ^ontop <tblock>))

The following production deletes the clear augmentation of the object that  the
block  is  moving  to.  It will apply only to blocks and so will not apply if a
block is being moved to the table.

    (sp blocks*apply*move-block*destination*remove-cleartop
      (goal <g> ^state <s> ^operator <o>)
      (state <s> ^object-dynamic <tblock-dyn>)
      (object-dynamic <tblock-dyn> ^object-static <tblock> ^clear yes)
      (object-static <tblock> ^type block)
      (operator <o> ^destination <tblock>)
      -->
      (object-dynamic <tblock-dyn> ^clear yes - ^clear no))

The final production creates a  clear  augmentation  for  the  block  that  was
underneath  the  block being moved.  It does not apply if the block being moved
was on the table.

    (sp blocks*apply*move-block*off-block*create-cleartop
      (goal <g> ^state <s> ^operator <o>)
      (state <s> ^object-dynamic <mblock-dyn>
                            { <> <mblock-dyn> <ublock-dyn> })
      (object-dynamic <ublock-dyn> ^object-static <ublock> ^clear no)
      (object-dynamic <mblock-dyn> ^object-static <mblock>
            ^ontop  { <> <tblock> <ublock> })
      (operator <o> ^moving-block <mblock> ^destination <tblock>)
      (object-static <ublock> ^type block)
      -->
      (object-dynamic <ublock-dyn> ^clear no - ^clear yes))

In this production, there is a test that the block underneath the  block  being
moved  is  not  equal  to  the  destination block: (object-dynamic <mblock-dyn>
^ontop { <> <tblock> <ublock> }).  This prevents the production  from  applying
after  the  production that created the new ontop augmentation has fired.  This
demonstrates a common problem  where  a  production  rejects  or  creates  some
structure  based  on the original state.  If care is not taken, that production
will continue to match new structures created  by  other  operator  application
productions.

For our example, the (watch 2) following trace is produced:

    <21 soar> (watch 2)

    T
    <22 soar> (run 1)

    --Preference Phase--
    Firing 8:30 blocks*apply*move-block*off*remove-ontop
                143 169 164 163 81 92 90
    Firing 8:30 blocks*apply*move-block*off-block*create-cleartop
                143 169 164 163 81 92 90 98 82 88 89
    Firing 8:30 blocks*apply*move-block*to*create-ontop
                143 169 163 81 92 164
    --Working Memory Phase--
    <=WM: 88: (object-dynamic b8 ^clear no)
    =>WM: 172: (object-dynamic b8 ^clear yes)
    <=WM: 90: (object-dynamic b7 ^ontop b10)
    =>WM: 173: (object-dynamic b7 ^ontop t19)

Because  of  the  changes that have been made to the state, the production that
created the acceptable preference for the operator to move A to  the  table  no
longer  matches  (blocks*propose*operator*move-block*destination).    It should
retract its I-support for those preferences.  The changes will also  allow  new
operators  to move blocks A and C onto B, and to move block B onto blocks A and
C. We can view the impending changes using (ms).

    <23 soar>  (ms)

    Retractions:
    blocks*propose*operator*move-block*destination
    blocks*apply*move-block*off*remove-ontop
    blocks*apply*move-block*off-block*create-cleartop

    Instantiations:
    blocks*terminate*operator*move-block
    blocks*propose*operator*move-block*destination (4 occurrences)

The changes to the state also cause the productions that applied  the  operator
to   retract  this  I-support  for  its  preferences.    However,  since  these
preferences were created by operator application, they  have  O-support  within
this goal.

    <24 soar> (preferences b8 clear)

    Accepts:
    (object-dynamic b8 ^clear yes +)   I-Support: 1   O-Support: T

8.11. Operator termination
Operators  are  terminated  by  creating a reconsider preference.  A reconsider
preference will allow additional operators to compete for  the  operator  slot.
In  this  example,  the  following  production  tests  that  the state has been
modified appropriately.  It does not test that  the  clear  augmentations  have
been  correctly  modified,  only  that  the block being moved is in its correct
position.

    (sp blocks*terminate*operator*move-block
      (goal <g> ^state <s> ^operator <o>)
      (state <s> ^object-dynamic <mblock-dyn>)
      (operator <o> ^destination <tblock> ^moving-block <mblock>)
      (object-dynamic <mblock-dyn> ^object-static <mblock> ^ontop <tblock>)
      -->
      (goal <g> ^operator <o> @))

The action of a operator termination  production  is  to  create  a  reconsider
preference  (@) for the current operator.  A reconsider preference signals Soar
that the decision procedure is  to  be  run  on  the  operator  slot  following
quiescence.    For  context  slots,  the  decision  procedure  is only run if a
reconsider preference exists, or there is currently  no  value  for  the  slot.
Below  is  a  (watch 3) trace of the next elaboration phase.  A (watch 3) trace
shows the creation of preferences in addition to  changes  in  working  memory.
Four  new  operators  are  created,  the  current  operator  is  retracted  and
reconsidered.    Note  that  the  current  operator  is  not   changed   during
elaboration.    That  will  not  occur until quiescence is reached.  Thus, even
though there is no acceptable preference for operator o22, it is still selected
as  the  current operator.  The one side effect of the reconsider preference is
that the goal is augmented with ^applied o22, signifying that the operator  has
terminated.

    <25 soar> (watch 3)

    <26 soar> (run 1)

    --Preference Phase--
    Firing 8:32 blocks*terminate*operator*move-block
                143 169 163 164 81 92 173
                ((goal g20 ^operator o22 @))
    Firing 8:32 blocks*propose*operator*move-block*destination
                141 140 143 81 91 92 96 82 172 89
                ((goal g20 ^operator o26 +) (operator o26 ^destination b10 +)
                 (operator o26 ^moving-block b11 +) (operator o26
                    ^name move-block +))
    Firing 8:32 blocks*propose*operator*move-block*destination
                141 140 143 82 172 89 98 81 91 92
                ((goal g20 ^operator o27 +) (operator o27 ^destination b11 +)
                 (operator o27 ^moving-block b10 +) (operator o27
                    ^name move-block +))
    Firing 8:32 blocks*propose*operator*move-block*destination
                141 140 143 82 172 89 98 83 85 86
                ((goal g20 ^operator o28 +) (operator o28 ^destination b13 +)
                 (operator o28 ^moving-block b10 +) (operator o28
                    ^name move-block +))
    Firing 8:32 blocks*propose*operator*move-block*destination
                141 140 143 83 85 86 94 82 172 89
                ((goal g20 ^operator o29 +) (operator o29 ^destination b10 +)
                 (operator o29 ^moving-block b13 +) (operator o29
                    ^name move-block +))
    Retracting 8:32 blocks*propose*operator*move-block*destination
                141 140 143 81 91 92 96 80 79 78
                ((goal g20 ^operator o22 +) (operator o22 ^destination t19 +)
                 (operator o22 ^moving-block b11 +) (operator o22
                    ^name move-block +))
    --Working Memory Phase--
    <=WM: 144: (goal g20 ^operator o22 +)
    =>WM: 187: (goal g20 ^operator o29 +)
    =>WM: 183: (goal g20 ^operator o28 +)
    =>WM: 179: (goal g20 ^operator o27 +)
    =>WM: 175: (goal g20 ^operator o26 +)
    =>WM: 191: (goal g20 ^applied o22)
    =>WM: 192: (operator o29 ^name move-block)
    =>WM: 193: (operator o29 ^moving-block b13)
    =>WM: 194: (operator o29 ^destination b10)
    =>WM: 195: (operator o28 ^name move-block)
    =>WM: 196: (operator o28 ^moving-block b10)
    =>WM: 197: (operator o28 ^destination b13)
    =>WM: 198: (operator o27 ^name move-block)
    =>WM: 199: (operator o27 ^moving-block b10)
    =>WM: 200: (operator o27 ^destination b11)
    =>WM: 201: (operator o26 ^name move-block)
    =>WM: 202: (operator o26 ^moving-block b11)
    =>WM: 203: (operator o26 ^destination b10)

Now  that  new  operators  have  been created, the productions that compare the
operators can fire:

    <27 soar> (ms)

    Instantiations:
    blocks*compare*operator*move-block*lower*better
    blocks*compare*operator*move-block*into-place*better (8 occurrences)
    blocks*compare*operator*move-block*not-into-position*worst
                                                         (2 occurrences)

Thus, within a single elaboration phase, an operator is applied, new  operators
are created, and preferences are created to select the next operator.

8.12. Task operator termination
Determining  that  the task operator has been successfully implemented involves
detecting that the current state has been changed into some new desired  state.
The  test that the current state achieves some desired state can be represented
either explicitly or implicitly.  An explicit  representation  would  have  the
desired   state  represented  as  an  augmentation  of  the  operator  with  an
accompanying set of productions that can  compare  the  current  state  of  the
problem  space  to the desired state.  Alternatively, the desired states may be
represented implicitly; so that  there  may  be  a  production,  or  a  set  of
productions,  that  recognizes  that  a  given state satisfies the goal without
comparing it to an explicit description.  In the case  where  the  operator  is
applied  in  a  subgoal,  the  test  may  also be made by the application of an
operator in the subgoal.  There can be many  levels  of  explicit  or  implicit
representation  in which parts of the desired state are explicitly represented,
and parts of the test are embedded in productions.

For this task, the termination of the operator can be detected by testing  that
a     tower     object     has    been    created    for    the    blocks    by
top-goal*elaborate*state*detect-tower.  The following production tests for  the
tower  object  and  then  creates  a  reconsider preference for the build-tower
operator.

    (sp top-goal*terminate*operator*build-tower
      (goal <g> ^problem-space <p> ^state <s> ^operator <o>)
      (problem-space <p> ^name top-ps)
      (state <s> ^object-dynamic <tower>)
      (object-dynamic <tower> ^top-block <blockA> ^middle-block <blockB>
                      ^bottom-block <blockC>)
      (operator <o> ^name build-tower)
      (object-static <blockA> ^name A)
      (object-static <blockB> ^name B)
      (object-static <blockC> ^name C)
      -->
      (goal <g> ^operator <o> @))

A reconsider preference is a signal  to  the  decision  procedure  that  a  new
decision can be made for the the operator slot.  At the point when the operator
is terminated, the acceptable  preference  for  the  operator  will  have  been
retracted,  because  the production that created it tested that blocks were not
stacked in a tower.  The following trace shows that the  appropriate  operators
are  selected  and  following decision 9, the desired state is achieved and the
task operator is terminated.  Once the task operator is  terminated,  the  wait
operator is selected and terminated.

    <28 soar> (watch 0)

    <29 soar> (d 4)

    8      O: O28 ((b) (c) move-block)
    9      O: O26 ((a) (b) move-block)
    10  O: O5 (wait)
    11  O: O5 (wait)

8.13. Using lookahead search
If the knowledge encoded in the operator selection productions is not available
during problem solving, a tie impasse will arise and a subgoal will be  created
to  make  the selection.  The default response to a tie impasse is to perform a
lookahead search that tries out the tied operators on a copy  of  the  original
state  so that the results of the operators can be compared (see Section 7.3 on
page 33 for more details).



8.13.1. State copying
In a lookahead search, the original state can not be used because  it  will  be
destructively   modified   during   the  search,  making  additional  lookahead
impossible.  Only by creating a copy of the state can the state  be  preserved.
In  creating  a  copy,  it is usually the case that a complete duplicate of the
original state is not necessary.  Only those aspects of the state that will  be
modified need to be copied.  By augmenting the problem space with a description
of those aspects of the state that need to be copied, a set of general  copying
productions  can  be  used for many different tasks.  Without this information,
there would have to be domain-specific productions to perform the copying.

To support the most common types of state representations,  there  are  default
productions  that will automatically create a copy of the top one or two levels
of the state  (see  Section  7.3.2.1  for  more  details).    To  enable  these
productions,   the   original   problem   space   should   be   augmented  with
^default-state-copy yes.  For states that follow the  guidelines  described  in
Section  8.1.2  on  page  38, all of the dynamic data, which can change through
operator application, is organized together as augmentations of  the  state  in
the object-dynamic structures.

In  order for the default productions to correctly copy a state, they must know
which aspects of the state must be copied and whether any substructure must  be
copied.   If an attribute of the state has a value that can be copied directly,
it is called a one-level-attribute. The values of the object-dynamic attributes
can  not  be  copied  directly  because  their substructure will be modified by
operators in the lookahead.  Such an attribute is called a two-level-attribute.
Instead,  a  new  object-dynamic  structure  must  be  created  and  all of the
augmentations  of  the  original  object-dynamic  structures  must  be  copied.
Although this is rather complicated in general, for the state structure used in
our example, all that is  necessary  is  to  augment  the  problem  space  with
^default-state-copy  yes  and  ^two-level-attributes  object-dynamic  as  shown
below:

    (sp blocks*elaborate*problem-space*blocks-world
        (goal <g> ^name build-tower ^problem-space <p>)
        (problem-space <p> ^name blocks-world)
        -->
        (problem-space <p> ^default-state-copy yes
                       ^default-operator-copy no
                       ^two-level-attributes object-dynamic + &))

This production also augments the problem space with ^default-operator-copy no.
As with states, it is possible for the lookahead search to add augmentations to
an operator when it is being instantiated for the state.   These  augmentations
may  use  values  from  the copied state instead of the original, so that it is
necessary to also create a copy of the operator.



8.13.2. Operator application
When performing a lookahead search, the operators must be applied to  the  copy
of  the state.  If the operator will modify the external environment when it is
applied to the top-level state, there must exist productions that will simulate
its  actions on the copy of the state.  Thus, performing a lookahead search can
often require additional knowledge that is not used when actions  are  executed
in  the  external environment when no internal simulation is required.  For the
Blocks World task we have implemented, the top-level state is modified directly
without  an external environment so that no additional productions are required
for lookahead.

When productions are required to simulate the actions of an external  operator,
they  must  fire only during the lookahead and not at the top-level, otherwise,
there could be confusion as to whether the changes to the top-level state arose
because  of  changes in the external environment or because they are simulated.
To differentiate between applying the operator to the top-level state or during
the  lookahead,  the productions can test the name of the current goal.  During
lookahead, the goal is  augmented  with  (goal  <g>  ^name  implement-evaluate-
object) (see Section 7.3.1 on page 33 for details of the evaluation goal).



8.13.3. Evaluating states
As described in Section 3.10.11 on page 16, knowledge must be added that allows
the states of the lookahead search to be evaluated.  The simplest case involves
detecting  that  the  desired  state  has  been  achieved.    In this case, the
lookahead state is augmented with ^success <d>, where <d> is the identifier  of
the  desired state.  The detection of success has to be specific to the desired
state because a single state may occur in more than  one  goal  with  different
desired  states.    Default  productions  will  match  against the detection of
success and translate it into an evaluation for the task operator being  tested
in  lookahead.   This evaluation is then converted to an appropriate preference
(in this case best) for the task operator, possibly breaking the tie impasse.

For the  Blocks  World,  the  detection  of  success  is  decomposed  into  two
productions.    The  first  detects  when one of the blocks has gotten into its
desired ontop position.  This is determined by testing that the  current  state
has  an  object-dynamic that corresponds to one in the desired state.  The goal
is then augmented with the identifier of the object  that  is  in  its  desired
position.    Since this is done with an entailment, it will be retracted if the
current state ever changes so that the  block  is  no  longer  in  its  desired
position.

    (sp blocks*elaborate*operator*achieved
      (goal <g> ^state <s> ^desired <d>)
      (state <s> ^object-dynamic <block-dyn>)
      (object-dynamic <block-dyn> ^ontop <blockb> ^object-static <blocka>)
      (desired <d> ^object-dynamic <dblock-dyn>)
      (object-dynamic <dblock-dyn> ^ontop <blockb> ^object-static <blocka>)
      -->
      (goal <g> ^achieved <dblock-dyn> <dblock-dyn> &))

The  second production tests that all three blocks are in their desired places.
For this test to work, the original desired state must be  augmented  with  the
count  of the number of objects that must be stacked, otherwise this production
would fire in cases where more than three blocks  must  be  stacked,  but  only
three are in position.

    (sp blocks*terminate*operator*build-tower*three
      (goal <g> ^state <s> ^desired <d>
            ^achieved <dontop1> { <> <dontop1> <dontop2> }
            {<> <dontop1> <> <dontop2> <dontop3>})
      (desired <d> ^object-count 3)
      -->
      (state <s> ^success <d> <d> &))



8.13.4. Search control
As  described  in  Section  7.3.1  on  page  33,  the  lookahead  search can be
controlled through the addition of control knowledge.  For the Blocks World,  a
simple,  but  effective,  piece  of  control knowledge is to never move a block
twice.  Although, it is possible to solve a problem by moving  the  same  block
twice, there is always a shorter path.

Detecting  that  a block has moved twice requires maintaining a bit of history,
namely, that the block that was moved.  Soar does  not  automatically  maintain
any history of the operators that have applied.  Therefore, productions must be
added to maintain a record of the block that has moved.  This is easy to do  by
merely adding productions that will fire in parallel with the existing operator
application productions.

The first production below creates an augmentation (^last-moved-block) with the
value  of the block being moved by the current operator.  The second production
deletes the old value.

    (sp blocks-world*apply*operator*remember*moved-block
        (goal <g> ^state <s> ^operator <o>)
        (operator <o> ^moving-block <mb>)
        -->
        (state <s> ^last-moved-block <mb> +))

    (sp blocks-world*apply*operator*delete*old-moved-block
        (goal <g> ^state <s> ^operator <o>)
        (state <s> ^last-moved-block {<> <mb> <omb>})
        (operator <o> ^moving-block <mb>)
        -->
        (state <s> ^last-moved-block <omb> -))

Using the ^last-moved-block augmentation, the following production rejects  any
operator that will move the most recently moved block.

    (sp blocks-world*reject*move-block*twice
        (goal <g> ^problem-space <p> ^state <s> ^operator <o> +)
        (problem-space <p> ^name blocks-world)
        (state <s> ^last-moved-block <mb>)
        (operator <o> ^moving-block <mb>)
        -->
        (goal <g> ^operator <o> -))

By  adding  these  search-control  productions, the lookahead search will avoid
trying wasted moves.  This greatly reduces the  search  space.    For  example,
whenever  a  tower  is  constructed  that  is  not  the desired state, the only
available operator is to move the block that was placed on top the tower.   The
search  control  productions  will  reject  this  operator  and  a  dead end is
detected.  Soar can then abandon that path.

Section 7.3.1 on page 33 has a complete trace of the problem solving using this
knowledge.
9. Top-Level Variables and Functions
This  chapter  describes  the  global  variables and functions that are used to
control Soar.  Where appropriate, functions are followed by  a  list  of  their
arguments.    Arguments  in  square  brackets  are  optional.   An asterisk (*)
suffixing a function signifies that  that  function  may  take  any  number  of
arguments.  Each function description is followed by an example.

Any  function  called  without  an  argument  (when  that  argument should be a
production name, the identifier of an object, or a working memory element) will
automatically  use  the  last  argument  value, of the appropriate type, as its
argument.  For example, in the following example, smatches  will  automatically
use boole*create-initial-state as its argument.

    (pm boole*create-initial-state)
    (smatches)

For  a  concise overview of the Soar interface functions, see the section named
Function Summary and Index on page 217.

9.1. Soar global variables



9.1.1. *chunk-free-problem-spaces*
A list of problem space names for which chunking should not be used.    If  the
subgoal's  current  problem  space has its name in the list, and the subgoal is
terminated, no chunk will be built for that subgoal.  Initially NIL.
For   example,   if   the   blocks-world   problem   space   is   included   in
*chunk-free-problem-spaces*, Soar will not chunk the result of implementing the
evaluate-object  operator,  because  the  operator  is   implemented   in   the
blocks-world  problem  space. However, Soar will chunk the results of a subgoal
to break a tie between operators because the selection space  is  used  in  the
subgoal.

Justifications are still built for the results created in problem spaces listed
in *chunk-free-problem-spaces*.



9.1.2. *default-user-select*
Used to decide from among a group of indifferent objects,  but  only  when  the
method  specified  via user-select or set-user-select fails. See Section 9.3.11
for more details.  Initially T, which means the user will be  asked  to  decide
among the indifferent objects.



9.1.3. *max-chunk-conditions*
No  production  will  be built that has a greater number of conditions than the
value in *max-chunk-conditions*.  Initially 200.



9.1.4. *max-elaborations*
If *max-elaborations* cycles are encountered during the elaboration phase, then
the  elaboration  phase  is  terminated and the decision procedure is executed.
This limits the total number of cycles of parallel production firing  but  does
not  limit  the  total  number of productions that can fire during elaboration.
Initially 100.



9.1.5. *mem-array-size*
Soar uses a hashing scheme to process the  equality  tests  of  variables  that
occur more than once in the conditions of a production.  This variable controls
the size of these hash tables.  It should be increased if a program is  running
slowly  and  has  a  large number of partial instantiations (and thus has large
numbers of entries in the hash tables).

Initially 10.  This value should be changed only immediately following  a  call
to  restart-soar  (then  followed  by  the loading of default.soar and the task
productions).



9.1.6. *pfired*
If T, then a count is kept of the number of times each production fires  during
a run.  Initially NIL.

The function pfired (see Section 9.9.4), prints the production counts (but only
if *pfired* is T).



9.1.7. *spo-default-depth*
The default depth of objects printed by the function spo (see  Section  9.7.4).
Initially 1.



9.1.8. *subgoal-tabs*
If  T, the functions watch (see Section 9.6.6) and pgs (see Section 9.7.2) will
indent during the context stack's tracing or printing.  If NIL, watch  and  pgs
will  not  indent,  but  will  instead  print  the  subgoal  depth as a number.
Initially T.



9.1.9. *warning*
If T, Soar warning messages are printed.  If NIL,  warnings  are  not  printed.
Initially T.



9.1.10. *watch-free-problem-spaces*
Contains  a  list  of problem-space names that will not be traced during Soar's
run. Initially NIL.

9.2. Initializing Soar



9.2.1. init-soar
Empties working memory and re-initializes runtime statistics  in  Soar  without
removing productions.

    (init-soar)



9.2.2. restart-soar
Re-initializes  Soar,  removes  all  productions  (including chunks and default
productions), empties working memory, and resets all global variables to  their
initial (default) values.  See also excise-task, Section 9.13.3.

    (restart-soar)
    (load "default.soar")

9.3. Setting the initial environment
See Section 9.16 for functions and macros used to set the I/O envrionment.



9.3.1. init-context [G] [P] [S] [O]
Clears working memory (through a call to init-soar) and then creates an initial
goal context.  If init-context is not called  when  Soar  is  started,  working
memory will be initialized with (goal g1 ^object nil).
This  function  takes up to four arguments.  The first is the identifier of the
initial goal; the second is the identifier of the initial  problem  space;  the
third  is  the identifier of the initial state; the fourth is the identifier of
the initial operator.

It is recommended that this function be called within  init-wm,  and  that  its
arguments  are  variables bound within init-wm to new Soar symbols. See Section
9.3.3 for an example of this usage.

The effects of init-context will not be seen until run has been called.

    (init-context <goal-id> <problem-space-id> <state-id> <op-id>)



9.3.2. init-task
A Lisp function that the user should provide with every  Soar  program.    This
function  should  take  care of all initialization required to run the program.
The following example is taken from the Eight Puzzle:

    (defun init-task ()
     "Init-task functions are a Soar convention to initialize a
     task for running."
      (init-soar)    ;; Clear out WM and the CONTEXT
      (user-select   ;; Tell Soar how to choose among indifferent objects
           (soar-menu "Select path"
           '(
             ("Benchmark" (c13 c22 c32 c21 c12 c13 c22 c32 c12 c13 c31))
             ("User control" t)
             ("Deterministically random" first)
             ("Random" nil))))
      (set-learning-choice))



9.3.3. init-wm [X] [*]
Calls init-soar and then initializes working memory through arguments that  are
either  calls  to  init-context  or  elements  to  be  added to working memory.
Variables can  appear  within  the  arguments,  as  identifiers  or  values  in
augmentations  and  as  the identifiers of objects in the call to init-context.
All of the arguments are evaluated as if they were actions of a production.

A useful application of init-wm is to create context objects and bind  them  to
the  arguments  of init-context. As the following example shows, except for the
goal, the initial context is not installed until Soar  has  been  run  for  one
elaboration cycle.

    <soar>(init-wm
      (init-context <g> <p> <s> <o>)
      (goal <g> ^name First-goal)
      (problem-space <p> ^name First-problem-space)
      (state <s> ^name first-state)
      (operator <o> ^name first-operator))
    <soar> (pgs)

        G: G1 (FIRST-GOAL)
    Decision Cycle 0
    <soar> (run 1)

    0   G: G1 (FIRST-GOAL)
    0   P: P2 (FIRST-PROBLEM-SPACE)
    0   S: S3 (FIRST-STATE)
    0   O: O4 (FIRST-OPERATOR)
    ***BREAK***
    NIL
    <soar> (pgs)

        G: G1 (FIRST-GOAL)
        P: P2 (FIRST-PROBLEM-SPACE)
        S: S3 (FIRST-STATE)
        O: O4 (FIRST-OPERATOR)
    Decision Cycle 1



9.3.4. learn [A] [*]
Sets  or  displays  the flags that control chunking. Described fully in Section
9.15.3.



9.3.5. lispsyntax
Changes the readtable to use standard Lisp conventions.

    (lispsyntax)



9.3.6. set-learning-choice
Allows the user to select the learning mode at  the  start  of  a  task's  run.
Takes  no  arguments; the function prompts the user.  Should be called from the
(user-defined) init-task function (see Section 9.3.2).

    (set-learning-choice)



9.3.7. set-user-select
Allows the user to set the user-select mode at the start of a task's  run.  See
Section  9.3.11  for  more information on user-select.  Takes no arguments; the
function prompts the user.  Should be called from the (user-defined)  init-task
function.

    (set-user-select)



9.3.8. soar-menu "string" L
Provides  a menu for the user.  Takes two arguments: the first is a string that
describes the purpose of the menu and the second is a list.   The  list  should
consist  of  atoms  and/or two-element sublists.  When soar-menu is called, the
user is asked to select between the atoms and the sublist's elements.    If  an
atom  is selected, that atom is returned.  If the first element of a sublist is
selected, the second elements of that sublist is returned.

In the following example, soar-menu is used to call user-select with one of  T,
first, or NIL:

    (user-select
      (soar-menu "Setting user-select..."
        '(("User control" T)
          ("Deterministically random" FIRST)
          NIL)))



9.3.9. soarsyntax
Changes the readtable to use Soar conventions.

    (soarsyntax)



9.3.10. soarsyntaxp
Returns T if the Soar readtable is being used; otherwise, returns NIL.

    (soarsyntaxp)



9.3.11. user-select [X]
Allows  the  user  to  set  which  option  should  be  used  to  select between
indifferent objects. X can be t, NIL, 'first, or a list.  If X is not provided,
user-select will display the current user-select mode.

If  X  is  t,  then whenever Soar is going to make a choice between indifferent
objects, the user will be asked to make the selection.  If X is NIL, Soar  will
make the selection randomly.  If X is 'first, Soar will always select the first
indifferent object found (a deterministic selection).

If X is a list, then the list should contain numbers, atoms,  or  lists.    For
each  selection, the first element of the list is popped off and used to select
an object. This provides a simple way to "program"  the  selections.    If  the
popped  element  of  X  is  a number, it will be used to index into the list of
objects to be selected (1 for the first).  If the popped element  of  X  is  an
atom,  the  objects are examined, and the first one that has the element as the
value of a trace-attribute is selected.  This provides a  symbolic  method  for
picking  the appropriate object.  However, if there is no single attribute that
uniquely defines the appropriate object, then a list of values can be provided.
If  the  popped  element  of X is a list, the first indifferent object that has
values of trace-attribute equal to each of the symbols in the list is selected.

In all cases, if the current value in the list does not allow for the selection
of an object (a number is too high, or the symbol does not  match  any  of  the
choices,  or  the  list  is exhausted), user-select is called with the value of
*default-user-select* (see Section 9.1.2).

The initial value of user-select is 'first.

    (user-select t)

9.4. Loading productions



9.4.1. load "filename"
Loads the file given as its (quoted) argument.

    (load "eight.soar")



9.4.2. start-default
Causes all following productions read in up to a call  to  stop-default  to  be
considered  default  productions.  Therefore, all default productions should be
bracketed by a call to start-default and stop-default.    Chunks  will  not  be
considered default productions.

Default  productions  are  not  removed with a call to excise-task (see Section
9.13.3).

    (start-default)



9.4.3. stop-default
Causes all following productions to be considered task productions, instead  of
default   productions.      See   Section  9.4.2  for  more  information  about
start-default.

    (stop-default)

9.5. Running and breaking Soar



9.5.1. d [N]
Runs Soar for N decisions.  If N is not included, runs until a break or halt is
encountered.  While Soar is running, it can be stopped at anytime by entering a
carriage return.  (See Section 9.16.1 for  how  to  change  the  default  break
character.)  (d N) is equivalent to (run N d).

    (d 3)



9.5.2. pbreak [X] [*]
With  arguments,  sets  breakpoints  for  them.  Without an argument, lists the
items for which breakpoints are set.

The argument, X, can specify specify  an  augmentation,  prefererence,  context
object,  or  production name.  If X is an augmentation or preference, Soar will
break following the elaboration cycle in which X was created.  If X is the name
or identifier of a context object, Soar will break following the decision cycle
in which a context object is selected with that name or identifier.   If  X  is
the  name  of  a production, Soar will break on the elaboration cycle following
the next firing of an instantiation of that production.

If X is a two-element  list  of  the  form  (<item>  R),  where  <item>  is  an
augmentation,  a preference, or a production name, pbreak sets a breakpoint for
the removal of the augmentation or preference or  for  the  retraction  of  the
production.

The effects are undone by unpbreak (see Section 9.5.5).

    <soar> (pbreak (state s3 ^blank-cell c22))

    T
    <soar> (pbreak (state s3 ^blank-cell c22 +))

    T
    <soar> (pbreak s4)

    T
    <soar> (pbreak eight*create-operator*move-tile)

    T
    <soar> (pbreak ((state s3 ^blank-cell c22) R))

    T
    <soar> (pbreak ((state s3 ^blank-cell c22 +) R))

    T
    <soar> (pbreak (eight*create-operator*move-tile R))

    T
    <soar> (pbreak)

    Augmentation Addition Breaks:
      ((STATE S3 BLANK-CELL C22))
    Augmentation Removal Breaks:
      ((STATE S3 BLANK-CELL C22))
    Preference Addition Breaks:
      ((STATE S3 BLANK-CELL C22 +))
    Preference Removal Breaks:
      ((STATE S3 BLANK-CELL C22 +))
    Firing Breaks:
      (EIGHT*CREATE-OPERATOR*MOVE-TILE)
    Retraction Breaks:
      (EIGHT*CREATE-OPERATOR*MOVE-TILE)
    Context Installation Breaks:
      (S4)



9.5.3. run [N] [X]
With no arguments, runs Soar until a break or a halt is encountered.

The  first  argument,  N,  can  be a number, or it can specify an augmentation,
prefererence, context object, or production name. The second argument,  X,  can
be either D or R.

When  N  is  a  number,  it  specifies the number of cycles to run Soar. If the
second argument not provided or is not D, N signifies  elaboration  cycles.  In
                                            th
this  case,  Soar will halt just after the N   elaboration cycle. (The decision
phase is counted as one elaboration cycle.)  If the second  argument  is  D,  N
                                                                             th
signifies  decision  cycles.    In this case, Soar will halt just after the N  
decision cycle.

When N is an  augmentation  or  preference,  Soar  halts  following  the  first
elaboration  cycle  in  which  an  augmentation  or preference that matches the
description is created or retracted.  If the second argument is not provided or
in  not  R,  Soar  will  halt  following  the  elaboration  cycle  in which the
augmentation entered  working  memory  or  the  preference  entered  preference
memory.  If  the second argument is R, Soar will halt following the elaboration
cycle in which the augmentation or preference is retracted.

When N is the name or identifier of a context object, Soar halts following  the
first  elaboration  cycle  in  which  a  context  object with the given name or
identifier is selected. If the second argument is provided, it will be ignored.

When N is the name of a production, Soar halts following  the  next  firing  or
retraction  of  an  instantiation of that production. If the second argument is
not provided or is not R, Soar will halt following  the  elaboration  cycle  in
which  the  production  fired;  if  the  second  argument  is R, Soar will halt
following the elaboration cycle in which the production retracts.

    (run 100)
    (run 100 d)
    (run (state s4 ^blank-cell c22))
    (run (state s4 ^blank-cell c22) r)
    (run (state s4 ^blank-cell c22 +))
    (run o22)
    (run eight*create-operator*move-tile)
    (run eight*create-operator*move-tile r)



9.5.4. run-task [N]
Calls init-soar, followed by init-task, followed by d.   Because  users  should
supply  all  Soar programs with an init-task function (see Section 9.3.2), this
                                                                             th
provides a common mode of initialization.  The function will  run  to  the  N  
decision  cycle.    If  N  is  missing, then Soar runs until a break or halt is
encountered.

    (run-task 5)



9.5.5. unpbreak [X] [*]
Removes breaks set by the function pbreak; as with pbreak, the argument, X, can
be  the  name  of  a production, the name of an object, or the identifier of an
object. With no arguments, removes all breakpoints.

    <soar> (pbreak zig zag)

    T
    <soar> (unpbreak zig)

    T
    <soar> (pbreak)

    Augmentation Addition Breaks:
      NIL
    Augmentation Removal Breaks:
      NIL
    Preference Addition Breaks:
      NIL
    Preference Removal Breaks:
      NIL
    Firing Breaks:
      NIL
    Retraction Breaks:
      NIL
    Context Installation Breaks:
      (ZAG)

9.6. Tracing decisions, productions, and objects



9.6.1. decide-trace [X]
Turns on a trace of the decision procedure when N is t; both context  decisions
and  non-context  decisions are traced.  The default value is NIL.  If X is not
provided, the current setting is returned.
The trace of the decision procedure shows the path of candidate objects as they
are  filtered  based on their preferences.  Objects with require and acceptable
preferences are collected,  then  filtered  by  desirability  preferences  (see
Section 3.4 for details on preference processing).

    <soar> (decide-trace t)

    T
    <soar> (run 1)

    (G21 OPERATOR)
     ACCEPTABLE O28((BLOCK2) MOVE-BLOCK) O27((BLOCK1) MOVE-BLOCK)
                O26((BLOCK3) MOVE-BLOCK) O25((BLOCK1) MOVE-BLOCK)
                O24((BLOCK3) MOVE-BLOCK) O23((BLOCK2) MOVE-BLOCK)
     POST-REJECT O28((BLOCK2) MOVE-BLOCK) O27((BLOCK1) MOVE-BLOCK)
                 O26((BLOCK3) MOVE-BLOCK) O25((BLOCK1) MOVE-BLOCK)
                 O24((BLOCK3) MOVE-BLOCK) O23((BLOCK2) MOVE-BLOCK)
     POST-BEST O28((BLOCK2) MOVE-BLOCK) O27((BLOCK1) MOVE-BLOCK)
               O26((BLOCK3) MOVE-BLOCK) O25((BLOCK1) MOVE-BLOCK)
               O24((BLOCK3) MOVE-BLOCK) O23((BLOCK2) MOVE-BLOCK)
     POST-WORST O28((BLOCK2) MOVE-BLOCK) O27((BLOCK1) MOVE-BLOCK)
                O26((BLOCK3) MOVE-BLOCK) O25((BLOCK1) MOVE-BLOCK)
                O24((BLOCK3) MOVE-BLOCK) O23((BLOCK2) MOVE-BLOCK)
     POST-INDIFFERENT O28((BLOCK2) MOVE-BLOCK) O27((BLOCK1) MOVE-BLOCK)
                      O26((BLOCK3) MOVE-BLOCK) O25((BLOCK1) MOVE-BLOCK)
                      O24((BLOCK3) MOVE-BLOCK) O23((BLOCK2) MOVE-BLOCK)
    7      ==>G: G30 (OPERATOR TIE)



9.6.2. ptrace [X] [*]
With  arguments, turns on a trace of those items.  With no arguments, lists the
items currently being traced. X can refer to a production or to  an  object  or
working memory element.

If X is a production name, that production will be traced whenever it fires.

If  X is an object name or identifier, all working memory elements that augment
that object are traced when they are created or matched by a firing production.

If X is the time-tag of a working memory element or a partial description of  a
working  memory element, any working memory element matching that specification
will be traced when it is created or matched by a firing production. A  partial
description can be class name alone, or a class name followed by an identifier,
attribute, or attribute-value pair.  If the class name is given by itself, then
all objects of that class will be traced.

The effects are undone by unptrace (see Section 9.6.4).

The   following   example,   from  the  Eight  Puzzle,  traces  the  production
eight*create-problem-space, the object with  identifier  p3,  and  the  working
memory element with time-tag 12:

    <soar> (ptrace eight*create-problem-space p3 12)

    Rule Traces:
      (EIGHT*CREATE-PROBLEM-SPACE)
    Object Traces:
      (P3)
    Tme Traces:
      ((GOAL G1 OPERATOR O33 +))
    <soar> (run-task 3)

    Select path
    Choose from this list by position in list (1-n)

    1: Benchmark
    2: User control
    3: Deterministically random
    4: Random
    ? 3

    Learning choice
    Choose from this list by position in list (1-n)
    1: Learning at all levels
    2: Learning bottom-up
    3: No learning
    ? 3

    Learn status: off all-goals print trace

    0   G: G1
    Firing 1:1 EIGHT*CREATE-PROBLEM-SPACE
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^NAME EIGHT-PUZZLE +)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^DEFAULT-STATE-COPY YES +)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^DEFAULT-OPERATOR-COPY NO +)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^ONE-LEVEL-ATTRIBUTES BLANK-CELL +)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^ONE-LEVEL-ATTRIBUTES BLANK-CELL &)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^ONE-LEVEL-ATTRIBUTES TILE-CELL +)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^ONE-LEVEL-ATTRIBUTES TILE-CELL &)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^TWO-LEVEL-ATTRIBUTES BINDING +)
    Firing EIGHT*CREATE-PROBLEM-SPACE : -->
                    (PROBLEM-SPACE P3 ^TWO-LEVEL-ATTRIBUTES BINDING &)
    1   P: P3 (EIGHT-PUZZLE)
    Firing EIGHT*CREATE-INITIAL-STATE&DESIRED-STATE : matches
                    (PROBLEM-SPACE P3 ^NAME EIGHT-PUZZLE)
    2   S: S4
    Firing EIGHT*CREATE-OPERATOR*MOVE-TILE : matches
                    (PROBLEM-SPACE P3 ^NAME EIGHT-PUZZLE)
    Firing EIGHT*CREATE-OPERATOR*MOVE-TILE : -->
                    (GOAL G1 ^OPERATOR O33 +)
    Firing EIGHT*CREATE-OPERATOR*MOVE-TILE : matches
                    (PROBLEM-SPACE P3 ^NAME EIGHT-PUZZLE)
    Firing EIGHT*CREATE-OPERATOR*MOVE-TILE : matches
                    (PROBLEM-SPACE P3 ^NAME EIGHT-PUZZLE)
    3   ==>G: G36 (OPERATOR TIE)
    ***BREAK***
    NIL



9.6.3. trace-attributes L
Modifies  the  tracing  of  a  run  so  that values of specific attributes of a
selected context object are printed.  The values that are traced  can  also  be
used  by  user-select  to  control the selection of indifferent context objects
(see Section 9.3.11).

This function takes a list of two-element lists as its  argument.    The  first
element  of  each sublist should be a class and the second element should be an
attribute.  After trace-attributes is called, a watch trace of level 0  through
2  (and  pgs)  will  print  the  specified  attribute's value when an object is
selected to the context role.  If the value  is  an  identifier  with  a  ^name
attribute,  then  that identifier's name is printed.  The tracing is recursive,
so that if the value is an identifier that  appears  in  an  augmentation  with
another  class  in  trace-attributes, its attributes will be traced, and so on.
The recursion stops whenever a previously traced identifier, or one that has no
trace-attributes,  is  encountered.  Initially,  the  following  attributes are
traced:

    ((goal role) (goal impasse) (goal superoperator)
            (operator instance) (operator object))

The ^name attribute  is  considered  to  be  within  trace-attributes  for  all
objects,  so  it  should  not  be  included  in trace-attributes.  All calls to
trace-attributes merely add pairs  to  the  list.    Pairs  are  removed  using
untrace-attributes.

    (trace-attributes '((state back-plane) (operator module) (module size)))



9.6.4. unptrace [X] [*]
With no arguments, removes all traces set by the function ptrace.  Can be given
same arguments as ptrace; see Section 9.6.2.

    <soar> (ptrace zig zag)
    (zig zag)
    <soar> (unptrace zig)
    (zag)



9.6.5. untrace-attributes L
Removes attributes from tracing.  This is exactly the opposite of the  function
trace-attributes (see Section 9.6.3).

    (untrace-attributes '((state back-plane) (module size)))



9.6.6. watch [N] [T]
Sets  the  trace  level  for  Soar's  run;  N  determines  the  amount of trace
information produced by the system; the default value of N is  0  (see  below).
The  second argument, if not NIL, will cause only non-default productions to be
traced.  If the second argument is NIL (or is not  provided),  all  productions
(including  default)  will  be  traced.   With no arguments given, watch prints
information about the current watch level.

-1              No trace information will be printed.

0               Prints the  current  decision  cycle  number,  the  role  being
                changed,  the  identifier  of  the  object, changes to the goal
                context,  and  the  name  and  any  attributes  declared   with
                trace-attributes  (see  Section  9.6.3).  Objects are indented;
                indenting can be turned off  by  setting  the  global  variable
                *subgoal-tabs*  to  NIL  (see Section 9.1.8).  When there is no
                indenting, the subgoal depth is printed  at  the  beginning  of
                each  line.  Subgoals are prefaced by arrows (==>) so that they
                are easy to distinguish.

.5              Adds to (watch 0) a trace of the names of productions  as  they
                fire.

1               Adds  to  (watch .5) a trace of time-tags of the working memory
                elements that match the productions. The trace begins with  the
                decision  cycle  number,  followed  by  the  elaboration  cycle
                number.  These numbers are followed by the name  of  the  fired
                production.    Following this information is a list of the data
                that was  matched  by  the  production  (given  by  time-tags),
                followed  by  -->, followed by the data that was created by the
                production (given by time-tags).

1.5             Just like (watch 1), except that the  working  memory  elements
                are printed instead of the time-tags.

2               Prints  out  the  time-tags  and  the  working  memory elements
                matched, removed or created.

3               Prints out the preferences that  are  created  and  removed  by
                productions  in  addition  to  the working memory elements that
                matched, created or removed.

task            This disables the tracing of default productions.  It does  not
                affect  the  numeric  level  of  tracing.    The form is (watch
                'task).

Below is an example from the start of the Blocks World.

    <soar> (watch 0)
    T
    <soar> (d 2)

    0   G: G1
    1   P: P2 (TOP-PS)
    2   S: S4 (TOP-STATE)
    ***BREAK***
    NIL
    <soar> (watch 1)

    T
    <soar> (d 1)

    --Preference Phase-- Initial state has all blocks clear
    Firing 3:7 TOP-GOAL*ELABORATE*INITIAL-STATE 10 17 18 19 11
    Firing 3:7 TOP-GOAL*PROPOSE*OPERATOR*WAIT 19 9 12
    Firing 3:7 TOP-GOAL*PROPOSE*OPERATOR*STACK-BLOCKS 19 9 12
    --Working Memory Phase--
    --Preference Phase-- The goal is to get block3 on block2
    Firing 3:9 TOP-GOAL*INSTANTIATE*OPERATOR*STACK-BLOCKS 92 88 104 103
    95 106 105 94 108 107 93 87 84 18 19 9 12
    --Working Memory Phase--
    --Quiescence Phase--
    3:11 DECIDE OPERATOR O17
    3   O: O17 (STACK-BLOCKS)
    ***BREAK***
    NIL
    <soar> (watch 3)

    T
    <soar> (d 2)

    --Preference Phase--
    --Working Memory Phase--
    --Quiescence Phase--
    =>WM: 133: (GOAL G21 ^QUIESCENCE T)
    =>WM: 134: (GOAL G21 ^IMPASSE NO-CHANGE)
    =>WM: 135: (GOAL G21 ^OBJECT G1)
    =>WM: 136: (GOAL G21 ^ATTRIBUTE OPERATOR)
    =>WM: 137: (GOAL G21 ^CHOICES NONE)
    4   ==>G: G21 (OPERATOR NO-CHANGE)

    --Preference Phase--
    Firing 5:15 TOP-GOAL*ELABORATE*GOAL*STACK-BLOCKS 87 132 135 136 134
    ((GOAL G21 ^PROBLEM-SPACE P22 +)
     (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES CLEAR &)
     (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES CLEAR +)
     (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES ONTOP &)
     (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES ONTOP +)
     (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES TABLE &)
     (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES TABLE +)
     (PROBLEM-SPACE P22 ^DEFAULT-STATE-COPY YES +)
     (PROBLEM-SPACE P22 ^NAME SIMPLE-BLOCKS-WORLD +))
    Firing 5:15 OPSUB*PROPOSE-OPERATOR-SUBGOALING 12 135 136 134
    ((GOAL G21 ^PROBLEM-SPACE P2 <) (GOAL G21 ^PROBLEM-SPACE P2 +))
    --Working Memory Phase--
    =>WM: 148: (GOAL G21 ^PROBLEM-SPACE P2 +)
    =>WM: 138: (GOAL G21 ^PROBLEM-SPACE P22 +)
    =>WM: 149: (PROBLEM-SPACE P22 ^NAME SIMPLE-BLOCKS-WORLD)
    =>WM: 150: (PROBLEM-SPACE P22 ^DEFAULT-STATE-COPY YES)
    =>WM: 151: (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES TABLE)
    =>WM: 152: (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES ONTOP)
    =>WM: 153: (PROBLEM-SPACE P22 ^ONE-LEVEL-ATTRIBUTES CLEAR)
    --Quiescence Phase--
    =>WM: 154: (GOAL G21 ^PROBLEM-SPACE P22)
    5:17 DECIDE PROBLEM-SPACE P22
    5      P: P22 (SIMPLE-BLOCKS-WORLD)
    ***BREAK***
    NIL

9.7. Displaying working memory



9.7.1. back-trace [I] [G]
Prints all productions used in goal G to produce the  working  memory  elements
described  by  the  argument,  I.  Also prints the working memory elements that
were matched by those productions that would be included in a chunk, if it were
to  be  built  with  I  as  its actions.  If G is not provided, the most recent
subgoal is used in its place.
The argument, I, can be a time-tag, an object identifier  (in  which  case  all
augmentations  of the object are used), or a pattern that includes at least one
attribute.  If I is the latter, then all working  memory  elements  that  match
that  pattern will be used.  If I is not given, back-trace will use the results
for goal G; if there are no results at the time of the function  call,  nothing
will be printed.

Beginning  with the working memory elements described by I, the production that
created I are found, their names printed, and the working memory elements  that
matched  their  conditions  are  collected.    If  one of the elements in I was
created in a subgoal, then a trace of the chunk that was created for I in  that
subgoal is found, and the identifier of the subgoal is printed.  If a collected
working memory element is linked to the  supercontext,  it  is  printed,  on  a
separate  line,  because  it will be the basis of a condition in a chunk.  If a
collected working memory element is not linked to the super-context,  then  the
name  of  the  production  that  created the working memory element is printed,
followed on the same line by the  working  memory  element,  then  the  process
recurses,  with the printing indented to signify that a new production trace is
being processed.  Once all of the conditions of a production  trace  have  been
processed,  either  through  additional  recursion,  or  because  they  will be
conditions,  the  printing  outdents,  and  the  processing  of  the  remaining
collected working memory elements continues.

During  the back-tracing, if a working memory element currently being processed
is the same as a working memory element that has already been processed, it  is
ignored.    In  the  special  case where a collected working memory element was
created by the decision procedure (either a context slot or  an  augmentation),
decision-procedure  is  printed  and the working memory element associated with
that creation act is backtraced.

    <soar> (back-trace e48)

    Backtracing to determine conditions for goal:
    G36
    Working-memory elements being traced:
    (EVALUATION E48 ^OPERATOR O43 ^STATE S38 ^DESIRED D2
                    ^TYPE EVALUATE-OBJECT ^OBJECT O33 ^NUMERIC-VALUE -1
                    ^VALUE T)
    Productions and conditions traced through:
       242:(EVALUATION E48 ^VALUE T)
       <--DEFAULT*ELABORATE*EVALUATION*VALUE-T
          239:(EVALUATION E48 ^NUMERIC-VALUE -1)
          <--G49
             69:(STATE S4 ^BLANK-CELL C23)
             5:(PROBLEM-SPACE P3 ^ONE-LEVEL-ATTRIBUTES BLANK-CELL)
             65:(STATE S4 ^BINDING B16)
             62:(STATE S4 ^BINDING B19)
             3:(PROBLEM-SPACE P3 ^ONE-LEVEL-ATTRIBUTES BINDING)
             68:(STATE S4 ^TILE-CELL NIL)
             4:(PROBLEM-SPACE P3 ^ONE-LEVEL-ATTRIBUTES TILE-CELL)
             53:(BINDING B16 ^TILE T12)
             47:(BINDING B19 ^TILE T5)
             48:(BINDING B19 ^CELL C23)
             54:(BINDING B16 ^CELL C13)
             136:(OPERATOR O33 ^TILE-CELL C13)
             135:(OPERATOR O33 ^BLANK-CELL C23)
             137:(OPERATOR O33 ^NAME MOVE-TILE)
             25:(BINDING D26 ^TILE T12)
             26:(BINDING D26 ^CELL C13)
             36:(DESIRED D2 ^BINDING D26)
             8:(PROBLEM-SPACE P3 ^NAME EIGHT-PUZZLE)
             175:(OPERATOR O43 ^DEFAULT-OPERATOR-COPY NO)
             <--DEFAULT*ELABORATE*GOAL*DEFAULT*OPERATOR-COPY
                6:(PROBLEM-SPACE P3 ^DEFAULT-OPERATOR-COPY NO)
                167:(OPERATOR O43 ^ATTRIBUTE OPERATOR)
                <--DEFAULT*APPLY*EVALUATE*AUGMENT*OPERATOR-ATTRIBUTE
                   165:(OPERATOR O43 ^TYPE EVALUATION)
                   <--DEFAULT*ELABORATE*OPERATOR*TYPE-EVALUATION
                      153:(OPERATOR O43 ^NAME EVALUATE-OBJECT)
                      <--DEFAULT*PROPOSE*OPERATOR*EVALUATE-OBJECT
                         145:(GOAL G36 ^ITEM O33)
                         <--DECISION
                            12:(GOAL G1 ^OPERATOR O33 +)
                         150:(GOAL G36 ^STATE S38)
                         <--DEFAULT*PROPOSE*INITIAL-STATE
                            147:(PROBLEM-SPACE P37 ^NAME SELECTION)
                            <--DEFAULT*PROPOSE*PROBLEM-SPACE*SELECTION
                169:(OPERATOR O43 ^SUPERPROBLEM-SPACE P3)
                <--DEFAULT*APPLY*EVALUATE*AUGMENT*OPERATOR-SUPER-SPACE
                   11:(GOAL G1 ^PROBLEM-SPACE P3)
             176:(OPERATOR O43 ^DEFAULT-STATE-COPY YES)
             <--DEFAULT*ELABORATE*GOAL*DEFAULT*STATE-COPY*YES
                NIL:(PROBLEM-SPACE P3 ^DEFAULT-STATE-COPY NO)
               -         168:(OPERATOR O43 ^SUPERSTATE S4)
             <--DEFAULT*APPLY*EVALUATE*AUGMENT*OPERATOR-SUPER-STATE
                103:(GOAL G1 ^STATE S4)
             177:(OPERATOR O43 ^DESIRED D2)
             <--DEFAULT*APPLY*EVALUATE*AUGMENT*EVALUATION-OPERATOR-DESIRED
                9:(GOAL G1 ^DESIRED D2)
                170:(OPERATOR O43 ^EVALUATION E48)
                <--DEFAULT*APPLY*EVALUATE*CREATE*EVALUATION-OBJECT
       180:(EVALUATION E48 ^OBJECT O33)
       <--DEFAULT*APPLY*EVALUATE*AUGMENT*EVALUATION-OBJECT
       179:(EVALUATION E48 ^TYPE EVALUATE-OBJECT)
       <--DEFAULT*APPLY*EVALUATE*AUGMENT*EVALUATE-OBJECT-TYPE
       178:(EVALUATION E48 ^DESIRED D2)
       <--DEFAULT*APPLY*EVALUATE*AUGMENT*EVALUATION-DESIRED



9.7.2. pgs
Prints the context stack, indented at each subgoal, and then the decision cycle
number.    If  the  value  of  *subgoal-tabs*  is  NIL, the indentation will be
replaced by numbered depth counts.

    <soar> (pgs)

        G: G1 (TOP-GOAL)
        P: P2 (TOP-PS)
        S: S4 (TOP-STATE)
        O: O17 (STACK-BLOCKS)
        ==>G: G21 (OPERATOR NO-CHANGE)
           P: P22 (SIMPLE-BLOCKS-WORLD)
           S: S4 (TOP-STATE)
           ==>G: G30 (OPERATOR TIE)
              P: P31 (SELECTION)
              S: S32
              O: O33 (((BLOCK2 BLOCK3) MOVE-BLOCK) EVALUATE-OBJECT)
              ==>G: G46 (OPERATOR NO-CHANGE IMPLEMENT-EVALUATE-OBJECT)
                 P: P22 (SIMPLE-BLOCKS-WORLD)
                 S: D47
                 O: O28 ((BLOCK2 BLOCK3) MOVE-BLOCK)
    Decision Cycle 15



9.7.3. po I
Prints augmentations of the identifier, given by I.   Also  prints  preferences
for context augmentations.  Will not print if I is not in the identifier field.
Note that po accepts only one argument at a time.

    <soar> (po g36)

    163:(GOAL G36 ^OPERATOR O39)
    162:(GOAL G36 ^WAIT TRUE)
    149:(GOAL G36 ^OPERATOR O39 +)
    149:(GOAL G36 ^OPERATOR O41 +)
    149:(GOAL G36 ^OPERATOR O43 +)
    150:(GOAL G36 ^STATE S38)
    146:(GOAL G36 ^STATE S38 +)
    148:(GOAL G36 ^PROBLEM-SPACE P37)
    104:(GOAL G36 ^PROBLEM-SPACE P37 +)
    145:(GOAL G36 ^ITEM O33)
    144:(GOAL G36 ^ITEM O34)
    143:(GOAL G36 ^ITEM O35)
    142:(GOAL G36 ^CHOICES MULTIPLE)
    141:(GOAL G36 ^ATTRIBUTE OPERATOR)
    140:(GOAL G36 ^OBJECT G1)
    139:(GOAL G36 ^IMPASSE TIE)
    138:(GOAL G36 ^QUIESCENCE T)
    NIL



9.7.4. spo I [* D]
Prints the objects corresponding to the identifiers given by I.

There is one optional final argument: D.  If a depth is given, spo will print a
depth-first   expansion   of  objects  and  sub-objects  to  the  given  depth.
Sub-objects can  be  either  values  or  attributes  of  the  original  object.
Augmentations  of  objects will be printed once each.  The default depth (i.e.,
when a second argument to spo is not given) is held  in  the  global  variable,
*spo-default-depth* and is initially 1.

    <soar> (spo o28 2)

    (OPERATOR O28 ^NAME MOVE-BLOCK ^MOVING-BLOCK C9 ^TO-BLOCK C8)
       (OBJECT C9 ^NAME BLOCK3 ^TYPE BLOCK)
       (OBJECT C8 ^NAME BLOCK2 ^TYPE BLOCK)
9.7.5. spr X [*]
This  is  the  general  Soar print function.  It takes any number of arguments,
which can be time-tags, object identifiers, or production  names,  and  applies
the appropriate print function: spo, spm, or swm.

    <soar> (spr o28 s4)

    (OPERATOR O28 ^NAME MOVE-BLOCK ^MOVING-BLOCK C9 ^TO-BLOCK C8)
    (STATE S4 ^IO-STATE S4 ^NAME TOP-STATE ^TABLE T6
              ^BLOCK C9 C8 C7 ^ONTOP B12 B11 B10 ^CLEAR A15 A14 A13
              ^ACHIEVED D19)



9.7.6. ppwm [X] [*]
Without  any  arguments,  ppwm  prints out all of working memory.  Arguments to
ppwm provide a partial description of single working memory elements; a partial
description can be class name alone, or a class name followed by an identifier,
attribute, or attribute-value pair.  These arguments act as a filter,  so  that
only those working memory elements that match are printed.

    <soar> (ppwm operator ^to-block c8)

    188:(OPERATOR O28 ^TO-BLOCK C8)
    203:(OPERATOR O23 ^TO-BLOCK C8)
    376:(OPERATOR O54 ^TO-BLOCK C8)
    388:(OPERATOR O50 ^TO-BLOCK C8)



9.7.7. sppwm [X] [*]
Without  arguments,  prints all of working memory.  Arguments should be partial
descriptions of objects; sppwm finds all objects  matching  those  descriptions
and  prints  them.    A partial description can be class name alone, or a class
name followed by an identifier, attribute, or attribute-value  pair.    If  the
class name is given by itself, then all objects of that class will be printed.

    <soar> (sppwm operator ^to-block c8)

    (OPERATOR O28 ^NAME MOVE-BLOCK ^MOVING-BLOCK C9 ^TO-BLOCK C8)
    (OPERATOR O23 ^NAME MOVE-BLOCK ^MOVING-BLOCK C7 ^TO-BLOCK C8)
    (OPERATOR O54 ^NAME MOVE-BLOCK ^MOVING-BLOCK C9 ^TO-BLOCK C8)
    (OPERATOR O50 ^NAME MOVE-BLOCK ^MOVING-BLOCK C7 ^TO-BLOCK C8)



9.7.8. swm N [*]
Takes  any  number  of  time-tags as its argument, and prints the corresponding
objects in working memory.

    <soar> (swm 188)

    (OPERATOR O28 ^NAME MOVE-BLOCK ^MOVING-BLOCK C9 ^TO-BLOCK C8)



9.7.9. wm N [*]
Takes any number of time-tags as arguments, and prints the  associated  working
memory elements in the same order as they were presented as arguments.

    <soar> (wm 188 203)

    188:(OPERATOR O28 ^TO-BLOCK C8)
    203:(OPERATOR O23 ^TO-BLOCK C8)


9.8. Displaying preference memory



9.8.1. preferences O A
Prints  the  current  preferences  for  the  slot identified by the arguments O
(object) and A (attribute). Prints the instantiation support (i-support)  count
and the operator support (o-support) status of each preference.

    <soar> (preferences g46 operator)

    Requires:
    (GOAL G46 ^OPERATOR O28 !)   I-Support: 1   O-Support: NIL
    Accepts:
    (GOAL G46 ^OPERATOR O54 +)   I-Support: 1   O-Support: NIL
    (GOAL G46 ^OPERATOR O53 +)   I-Support: 1   O-Support: NIL
    (GOAL G46 ^OPERATOR O52 +)   I-Support: 1   O-Support: NIL
    (GOAL G46 ^OPERATOR O51 +)   I-Support: 1   O-Support: NIL
    (GOAL G46 ^OPERATOR O50 +)   I-Support: 1   O-Support: NIL
    (GOAL G46 ^OPERATOR O49 +)   I-Support: 1   O-Support: NIL



9.8.2. tally O A
Runs  the decision procedure on the current preferences for the slot identified
by the given object and attribute (arguments O and A, respectively) and  prints
the  result,  without  changing  working memory.  Also prints the result of the
last "real" decision made on the slot.

    <soar> (d 4)

    0   G: G1
    1   P: P2 (TOP-PS)
    2   S: S4 (TOP-STATE)
        Initial state has all blocks clear
        The goal is to get block3 on block2
    3   O: O17 (STACK-BLOCKS)
    4   ==>G: G21 (OPERATOR NO-CHANGE)
    <soar> (tally g1 operator)

    Old Preference Tally:
    Status:         NO-CHANGE
    Winning Values: NIL
    Impasse Items:  (O17)

    Decide Trace:

    (G1 OPERATOR)

    New Preference Tally:
    Status:         WINNER
    Winning Values: (O17)
    Impasse Items:  NIL

9.9. Displaying production memory



9.9.1. ms
Prints a list of productions that have instantiations in the match  set,  i.e.,
those  productions that will retract or fire in the next elaboration cycle.  If
the next cycle is the decision phase, no productions  are  listed,  and  (PHASE
DECIDE)  is  printed.  If a production has many instantiations, (N OCCURRENCES)
is printed on the right.  Note that some productions may be in the  match  set,
but  may not change working memory because the elements they create are already
in working memory.

    <soar> (ms)

    Retractions:
    BLOCKS*APPLY*MOVE-BLOCK*OFF*REMOVE-ONTOP
    BLOCKS*PROPOSE*OPERATOR*MOVE-BLOCK*TO-BLOCK (4 OCCURRENCES)
    BLOCKS*APPLY*MOVE-BLOCK*TO-BLOCK*REMOVE-CLEAR
    EVAL*PROPOSE-OPERATOR*EVALUATE-OBJECT*OPERATOR

    Instantiations:
    BLOCKS*TERMINATE*OPERATOR*MOVE-BLOCK
    BLOCKS*ELABORATE*OPERATOR*PARTIAL-SUCCESS*STACK-BLOCKS
    BLOCKS*PROPOSE*OPERATOR*MOVE-BLOCK*TO-TABLE
    T



9.9.2. full-matches P [*]
Prints the most  complete  match  possible  of  the  production  given  as  its
argument.    The  conditions of the production are listed, each preceded by the
number of currently active matches for that condition, or - if the condition is
negated.    The  pointer  >>>>  before a condition indicates that the condition
failed to match.

Below the conditions, full-matches prints (as MATCHES FOR LEFT)  the  time-tags
of  the  working  memory  elements that match each condition above the pointer.
After MATCHES FOR RIGHT, the conditions that have yet to be matched for a  full
match of the production are printed.

In the following example, the production initially does not match because there
is no state selected; one decision later, the production is fully matched  with
three different instantiations.

    <soar> (d 1)

    0   G: G1
    1   P: P3 (EIGHT-PUZZLE)
    ***BREAK***
    NIL
    <soar> (full-matches eight*create-operator*move-tile)

    (EIGHT*CREATE-OPERATOR*MOVE-TILE
      1   (GOAL <G> ^PROBLEM-SPACE <P>)
      1   (PROBLEM-SPACE <P> ^NAME EIGHT-PUZZLE)
      >>>>(GOAL <G> ^STATE <S>)
    ** MATCHES FOR LEFT **
     11 8
    ** MATCHES FOR RIGHT **
          (STATE <S> ^BLANK-CELL <C1>)
          (CELL <C1> ^CELL <C2>)

    0
    <soar> (d 1)

    2   S: S4
    ***BREAK***
    NIL
    <soar> (full-matches eight*create-operator*move-tile)

    (EIGHT*CREATE-OPERATOR*MOVE-TILE
      1   (GOAL <G> ^PROBLEM-SPACE <P>)
      1   (PROBLEM-SPACE <P> ^NAME EIGHT-PUZZLE)
      1   (GOAL <G> ^STATE <S>)
      1   (STATE <S> ^BLANK-CELL <C1>)
      3   (CELL <C1> ^CELL <C2>)
    ** MATCHES FOR ALL CONDITIONS **
     11 8 103 69 77
     11 8 103 69 78
     11 8 103 69 79

    0



9.9.3. memories [N]
Prints the N productions with the largest token memories.  See Section 9.17.2.



9.9.4. pfired [D]
Prints  the  number  of times each production fired; production names are given
from least frequently fired to most frequently fired.  If D is a number, the  D
productions  that  fired  most  will be printed.  If D is zero, the productions
that did not fire will be printed.  The global variable *pfired* must be set to
T (before the run) for this to work.

    <soar> (pfired 4)

    Number of times each production fired:
    12: BLOCKS*PROPOSE*OPERATOR*MOVE-BLOCK*TO-BLOCK
    7: EVAL*DUPLICATE-STATE*COPY-ONE-LEVEL-AUGMENTATIONS-OFF-STATE
    6: EVAL*PROPOSE*OPERATOR*EVALUATE-OBJECT
    6: EVAL*ELABORATE*OPERATOR*TYPE-EVALUATION



9.9.5. pi P [N]
Prints the time tags of working memory elements that form the Nth instantiation
(or partial instantiation) for production P.    If  N  is  missing,  the  first
instantiation is printed.

If  there  is more than one partial instantiation, the fullest instantiation is
considered the first one.

    <soar> (pi eight*create-operator*move-tile)

    (EIGHT*CREATE-OPERATOR*MOVE-TILE Fired Instantiation
    11:(GOAL G1 ^PROBLEM-SPACE P3)
    8:(PROBLEM-SPACE P3 ^NAME EIGHT-PUZZLE)
    103:(GOAL G1 ^STATE S4)
    69:(STATE S4 ^BLANK-CELL C23)
    79:(CELL C23 ^CELL C22))

    T



9.9.6. pm P [*]
Prints the productions given as arguments.  Production conditions  are  printed
in the same order as they are stored internally after ordering.  See also (spm)
(Section 9.9.8.)

    (pm blocks*apply*move-block*to-block*remove-clear)

    (p blocks*apply*move-block*to-block*remove-clear
       (goal <g> ^state <s>)
       (goal <g> ^operator <o>)
       (operator <o> ^to-block <tblock>)
       (object <tblock> ^type block)
       (state <s> ^clear <clear>)
       (clear <clear> ^block <tblock>)
     -->
       (state <s> clear <clear> -))



9.9.7. smatches P [*]
Prints the most  complete  match  possible  of  the  production  given  as  its
argument.    The  conditions of the production are listed, each preceded by the
number of currently active matches for that condition, or - if the condition is
negated.    The  pointer  >>>>  before a condition indicates that the condition
failed to match.

    <48 soar> (smatches eight*create-operator*move-tile)

    (EIGHT*CREATE-OPERATOR*MOVE-TILE
      1   (GOAL <G> ^PROBLEM-SPACE <P>)
      1   (PROBLEM-SPACE <P> ^NAME EIGHT-PUZZLE)
      >>>>(GOAL <G> ^STATE <S>)
          (STATE <S> ^BLANK-CELL <C1>)
          (CELL <C1> ^CELL <C2>)

    NIL



9.9.8. spm P [*]
Prints the production given as its argument.  Production conditions are printed
so that all of an augmentation's objects are grouped together.

    <soar> (spm eight*create-operator*move-tile)

    (SP EIGHT*CREATE-OPERATOR*MOVE-TILE
       (GOAL <G> ^PROBLEM-SPACE <P> ^STATE <S>)
       (PROBLEM-SPACE <P> ^NAME EIGHT-PUZZLE)
       (STATE <S> ^BLANK-CELL <C1>)
       (CELL <C1> ^CELL <C2>)
     -->
       (OPERATOR <O> ^NAME MOVE-TILE + ^TILE-CELL <C2> + ^BLANK-CELL <C1> +)
       (GOAL <G> ^OPERATOR <O> +))

    NIL



9.9.9. spr X [*]
This  is  the  general  Soar print function.  It takes any number of arguments,
which can be time-tags, object identifiers, or production names and applies the
appropriate print function:  spo, spm, or swm.

    <soar> (spr eight*create-operator*move-tile)

    (SP EIGHT*CREATE-OPERATOR*MOVE-TILE
       (GOAL <G> ^PROBLEM-SPACE <P> ^STATE <S>)
       (PROBLEM-SPACE <P> ^NAME EIGHT-PUZZLE)
       (STATE <S> ^BLANK-CELL <C1>)
       (CELL <C1> ^CELL <C2>)
     -->
       (OPERATOR <O> ^NAME MOVE-TILE + ^TILE-CELL <C2> + ^BLANK-CELL <C1> +)
       (GOAL <G> ^OPERATOR <O> +))

    NIL

9.10. Displaying other information



9.10.1. print-stats
Lists a summary of run statistics, including the following:

   - The  current  Soar  version,  creation  date, and date of the current
     statistics.

   - Number of productions:   The  total  number  of  productions  in  the
     system,  including  all  chunks  built during problem solving and all
     default productions .

   - Number of nodes, with sharing/without sharing: These directly  follow
     the number of productions, on the same line.  The first number is the
     number of nodes actually used in the production match  Rete  network.
     The  second  number  is the number of nodes that would be required if
     there were no sharing.

   - Number of chunks:  The number of chunks that have been built.

   - Elapsed time: This is CPU time spent running Soar,  followed  by  the
     total  time  used  by  the  chunking  mechanism  (this  time includes
     internal chunks).

   - Number of decision cycles:  The total number of  decision  cycles  in
     the run.

   - Number of elaboration cycles:  The total number of elaboration cycles
     that were executed during the run.  This is not the total  number  of
     production firings, as productions can fire in parallel.

   - Number  of elaboration cycles per decision cycle:  The average number
     of elaboration cycles executed during a decision cycle.

   - Number  of  production  firings:    This  is  the  total  number   of
     productions  that  were fired.  Each decision cycle is counted as one
     production firing.

   - Number of productions firing  in  parallel:    This  is  computed  by
     dividing the number of production firings (total production firings -
     decision cycles) by the number of elaboration cycles.

   - Number of actions:  This is  the  total  number  of  actions.    This
     includes all additions and deletions from working memory.

   - Working  memory  size:   This gives the average, maximum, and current
     number of working memory elements.

   - Token memory size:  This gives  the  average,  maximum,  and  current
     number of tokens used to represent the working memory elements in the
     Rete network.  When this number is large, the system  tends  to  slow
     down.

    <soar> (print-stats)

    Soar 5.2.0 (internal release)
    Created August 7th, 1990

    Run statistics on August  20, 1990
    Allegro CL 3.0.1_apollo.3 [apollo] (3/16/90 13:27)
      Apollo DN 3000 id: 385 Domain 9.6 seagull.engin.umich.edu

    105 productions (4272 / 14047 nodes)
     0 chunks (0 / 105 productions)
    14.85 seconds elapsed 0.217 seconds chunking overhead
    16 decision cycles (928.125 ms per cycle)
    29 elaboration cycles (512.069 ms per cycle)
        (1.8125 e cycles/d cycle)
    154 production firings (96.42857 ms per firing)
         5.3103447 productions in parallel
    425 RHS actions after initialization (34.941177 ms per action)
    49 mean working memory size (244 maximum, 244 current)
    383 mean token memory size (2011 maximum, 1889 current)
    2734 total number of tokens added
    845 total number of tokens removed
    3579 token changes (4.149204 ms per change)
         (8.401408 changes/action)



9.10.2. soarnews
Prints news about the current release.

    (soarnews)

9.11. Changing working memory



9.11.1. init-context [G] [P] [S] [O]
Used  to  specify  the  initial  context prior to the start of a Soar run.  See
section 9.3.1.



9.11.2. init-wm [X] [*]
Used to initialize working memmory prior to the start  of  a  Soar  run.    See
section 9.3.3.



9.11.3. pop-goal [X]
Removes  the  goal  X,  all  of  its  subgoals, and all working memory elements
created in it or its subgoals (including results).    Working  memory  elements
created  in  lower  subgoals but attached to a higher-level context will not be
removed. Also, no chunks are created when the goal is popped.

In addition, all preferences referring to the removed working  memory  elements
and  all  preferences  supported  by  the  removed  working memory elements are
removed from preferenced memory.

If X is not specified, the  last  subgoal  created  is  popped.    The  runtime
statistics  kept for print-stats are not modified to reflect the abandonment of
the subgoal.

This function allows a limited form of backup in  Soar.    If  there  are  some
errors  that  have  been made by an incorrect production in a subgoal, the user
can pop the subgoal, correct the production, and proceed.

    <soar>  (d 5)

    0   G: G1
    1   P: P2 (TOP-PS)
    2   S: S4 (TOP-STATE)
        Initial state has all blocks clear The goal is to get block3
        on block2
    3   O: O17 (STACK-BLOCKS)
    4   ==>G: G21 (OPERATOR NO-CHANGE)
    5      P: P22 (SIMPLE-BLOCKS-WORLD)
    ***BREAK***
    NIL
    <soar> (pop-goal g21)

    T
    <soar> (pgs)

        G: G1 (TOP-GOAL)
        P: P2 (TOP-PS)
        S: S4 (TOP-STATE)
        O: O17 (STACK-BLOCKS)
    Decision Cycle 6

9.12. Changing preference memory



9.12.1. pop-goal [X]
See section 9.11.3.



9.12.2. smake X
Adds a new element to preference memory.  Variables can be used in place of the
identifier,  leading  to the automatic generation of a new symbol. Since a call
to smake creates a preference, changes will not be reflected in working  memory
until Soar is run for one elaboration cycle.

Note  that  the  creation  of  a  new  preference does not guarantee that a new
augmentation will be added  to  working  memory.  It  is  possible  that  other
preferences  already  exist for the slot, or that competing preferences will be
created during the elaboration cycle required to run a decision on the slot.

Elements in working memory can be removed with sremove (see Section 9.12.3).

    <soar> (watch 2)
    <soar> (smake state <S1> ^name california +)
    <soar> (run 1)
    =>WM: 159:(STATE S47 ^NAME CALIFORNIA)



9.12.3. sremove N [*]
Removes from Soar the augmentation with time-tag N.  This can be used  only  at
the  top-level  to  remove  working  memory  elements; it cannot be included in
production  actions.  Unlike  smake,  this  function  affects  working   memory
directly.

    <soar> (watch 2)
    <soar> (smake state <S1>  ^name california)
    <soar> (run 1)
    =>WM: 1:(STATE S4 ^NAME CALIFORNIA)
    <soar> (sremove 1)
    <=WM: 1:(STATE S4 ^NAME CALIFORNIA)

9.13. Changing production memory



9.13.1. excise P [*]
Removes  productions  from  production  memory.  A hash sign (#) is printed for
every production excised.

    <soar>(excise blocks*apply*move-block*to-block*remove-clear)
    #
    (BLOCKS*APPLY*MOVE-BLOCK*TO-BLOCK*REMOVE-CLEAR)



9.13.2. excise-chunks
Excises all productions chunked since starting Soar. See Section 9.15.1.



9.13.3. excise-task
Excises  all  productions  that  were  not   in   between   start-default   and
stop-default.   Unless additional default productions are declared by the user,
this means that all productions  not  in  default.soar  will  be  excised  (see
Section 9.4.2).

    (excise-task)



9.13.4. op-apps L
Declares  productions  to  be operator-application productions, even if they do
not otherwise meet the criteria for operator application.  The  actions  of  an
operator-application  production  are not retracted when the conditions of that
production are no longer matched.

L is a list of production names.

    (op-apps '(my-otherwise-unsticky-production))



9.13.5. op-apps-undo L
Undoes the effects of op-apps. That is, productions that have been declared  to
be  operator-application  productions via a call to op-apps will be restored to
their original non-operator-application status.

L is a list of production names.

    (op-apps-undo '(my-otherwise-unsticky-production))



9.13.6. sp X
Creates a new production.  If the production  replaces  a  previously  existing
production  (i.e.,  a production with the same name) the old production will be
excised and its name will be printed.  An  optional  documentation  string  can
follow the production name.

    (sp blocks*create-problem-space
        "This creates the top-level space"
        (goal <g> ^supergoal nil)
        -->
        (goal <g> ^name solve-blocks-world ^desired <d> ^problem-space <p>)
        (problem-space <p> ^name blocks-world))

9.14. Justifications



9.14.1. last-justification
Prints the last justification created.

    (last-justification)



9.14.2. list-justifications ["filename"]
Prints  all justifications. If a file name is supplied (surrounded by quotation
marks) as an argument, then the justifications will be written  to  that  file,
over-writing any previous version of the file.

    (list-justifications)

9.15. Learning



9.15.1. excise-chunks
Excises  all  productions  chunked since starting Soar (either through starting
Soar or calling restart-soar).  The names of all chunked productions  are  held
in  *chunks*.  The function uses *chunks* to remove the chunked productions and
then sets *chunks* to NIL.

    <soar> (excise-chunks)
    ###########
    NIL



9.15.2. last-chunk
Prints the last production created by chunking.

    <soar> (last-chunk)

    (SP P83 ELABORATE
       (GOAL <G1> ^PROBLEM-SPACE <P1>
                  ^STATE <S1> ^DESIRED <D4>)
       (PROBLEM-SPACE <P1> ^NAME EIGHT-PUZZLE)
       (DESIRED <D4> ^BETTER HIGHER
                     ^BINDING <D2> { <> <D2> <D1> } ...)
       (STATE <S1> ^BLANK-CELL <C4> ^BINDING <B3> ...)
    .
    .
    .
     -->
       (GOAL <G1> ^OPERATOR <O1>))

    NIL



9.15.3. learn [A] [*]
With no arguments, all of the flags that control  chunking  are  displayed.  If
arguments  are  provided, they will alter the learning environment as described
below.  The arguments are not evaluated.  Below is a list  of  argument  pairs;
the first one (underlined) is the default.

   - off/on
     On turns chunking on and off turns it off.  If  learning  is  set  to
     off, it can be turned on and off at any point during a run.

   - all-goals/bottom-up
     The all-goals setting builds productions whenever a subgoal returns a
     result.    The alternate setting, bottom-up will cause productions to
     be built only for terminal subgoals (i.e., subgoals that do not  have
     any subgoals).

   - print/noprint/full-print
     With print, production names are printed as they are created.    With
     noprint, nothing is printed.  With full-print, the full production is
     printed when it is created.

   - trace/notrace/full-trace
     With  trace,  every  time  a  production is chunked, it is added to a
     list.  When a production on that list fires, it is traced with  watch
     1.    With full-trace, the building of the production is also traced.
     See Section 9.7.1  for  a  complete  description  of  the  back-trace
     format.

    <soar>(learn off)

    Learn status: off all-goals print trace
    OFF
    ALL-GOALS
    PRINT
    TRACE



9.15.4. list-chunks ["filename"]
Prints  all productions created by chunking.  The names are listed in the order
that the chunks were created.  If  a  file  name  is  supplied  (surrounded  by
quotation  marks) as an argument, then the chunks will be written to that file,
over-writing any previous version of the file.

    (list-chunks)



9.15.5. set-learning-choice
Allows the user to select the learning mode at  the  start  of  a  task's  run.
Takes  no  arguments; the function prompts the user.  Should be called from the
(user-defined) init-task function (see Section 9.3.2).

    (set-learning-choice)

9.16. Input and output



9.16.1. set-break-char X
Allows the user to redefine the  break  character  recognized  by  text  input,
assuming  that text input is turned on.  See Section 6.2.1 for how to turn text
input on.
X is the Lisp name used to refer to the character; a Lisp reference  should  be
consulted.

    (set-break-char #\space)



9.16.2. set-carriage-control X
When  text  input  is  turned  on,  toggles  Soar between reading in whitespace
information and ignoring it. When text input is off, has no effect.

When X is T, Soar will include whitespace information as distinct text objects.
When X is NIL, Soar returns to the default of ignoring whitespace characters.

The  carriage-control  setting  is irrelevant when the character-mode is set to
read in characters rather than atoms.

    (set-carriage-control t)



9.16.3. set-char-mode X
When text input is turned on, toggles between reading text input one  character
at  a  time and reading text input one atom at a time.  When text input is off,
has no effect.

When X is T, Soar will read one character at  a  time;  when  X  is  NIL,  Soar
returns to the default of reading one atom at a time.

    (set-char-mode t)



9.16.4. set-input-functions L
Establishes  the  user-defined  input  functions that will be called during the
input cycle.  See Section 6.3.2 for more information on general input.

L is a list of input functions.

    (set-input-functions (time-function vision-function))



9.16.5. set-macro-character X Y Z R
Allows the  user  to  change  a  terminating  character  to  a  non-terminating
character (and vice versa) for use with text input.

X represents the character to be changed (consult a Lisp reference for the name
used to specify the character), and Y represents the function that  corresponds
to  that  character.  (The mapping between characters and functions is given in
Figure 6-4 in Section 6.2.4.3.) If Z  is  T,  the  character  will  be  set  to
non-terminating;  if  Z  is  NIL,  the  character  will  revert to its original
terminating status. R must be *alternate-readtable*.

Only the characters listed in Figure 6-4  can  be  affected  by  this  call;  a
character that is originally non-terminating cannot be changed to terminating.

    (set-macro-character #\* #'read-asterisk t *alternate-readtable*)



9.16.6. set-output-mappings L
Establishes   the   mappings  between  output  functions  and  the  output-link
attributes that they respond to.  See Section 6.3.3  for  more  information  on
general output.

L is a list of output mappings of the form:

    ((output-function-1 output-attribute-1)
     (output-function-2 output-attribute-2)
     ...)

Example:

    (set-output-mappings ((robot-move-base base-o-link)
                          (robot-move-arm arm-o-link)))
9.16.7. set-text-input X
Turns text input on or off.

If X is T, then text input is turned on; if X is NIL, text input is returned to
the default off setting.

    (set-text-input t)



9.16.8. set-text-input-stream X
Redefines the stream used for text input.  X is  a  stream;  a  Lisp  reference
should be consulted for handling streams in your particular Lisp.

    (set-standard-text-input-stream *standard-input*)



9.16.9. set-text-output X
Turns text output on or off.

If  X is T, then text output is turned on; if X is NIL, text output is returned
to the default off setting.

    (set-text-output t)



9.16.10. set-text-output-stream X
Redefines the stream used for text output.  X is a  stream;  a  Lisp  reference
should be consulted for handling streams in your particular Lisp.

    (set-text-output-stream *dedicated-x-window*)



9.16.11. set-tab-settings N [*]
Redefines  the  tab  stops to be used by text output. This has no effect on the
indentation used for the functions watch and pgs.

If N is NIL, all tab stops are eliminated.

    (set-tab-settings 10 20 30 40)

9.17. Increasing and checking efficiency



9.17.1. multi-attributes L
Informs the Rete network that an attribute can have multiple values at the same
time, so that the reordering mechanism can take advantage of the information to
increase match efficiency.
The conditions are reordered when the productions are  loaded,  so  a  call  to
multi-attributes should precede the productions for a task.

Takes a list of two- or three-element lists for an argument.  The first element
of each sublist is a class name; the second element is an  attribute;  and  the
third  (optional)  element is the expected number of values for given attribute
(the default value is 5).

    (multi-attributes '((state binding 9) (cell cell 4)))



9.17.2. memories [N]
Prints the N productions with the largest token memories.  The default value is
10.   This function is very useful for identifying which productions have large
numbers of partial instantiations, and thus are  responsible  for  slowing  the
system down.

    <soar> (memories 6)

    Productions with largest memories
    50: BLOCKS*ELABORATE*OPERATOR*PARTIAL-SUCCESS*STACK-BLOCKS
    39: BLOCKS*PROPOSE*OPERATOR*MOVE-BLOCK*TO-BLOCK
    36: BLOCKS*SELECT-MOVE-BLOCK*IDENTICAL-ARE-INDIFFERENT
    28: BLOCKS*PROPOSE*OPERATOR*MOVE-BLOCK*TO-TABLE
    26: TOP-GOAL*INSTANTIATE*OPERATOR*STACK-BLOCKS
    20: EVAL*ELABORATE*OPERATOR*TYPE-EVALUATION



9.17.3. print-stats
Lists a summary of statistics. See Section 9.10.1.
I. Glossary of Terms

action          The  then-part  of  a  production  that  is  executed  when the
                production successfully matches working  memory.    The  normal
                action  is to create a preference for a working memory element.
                Other possible actions: bind, call2, halt, tabstop, write1, and
                write2.

attribute       The  third symbol in an augmentation.  It represents a relation
                of property of an object.    Each  augmentation  has  a  single
                attribute.  An  object  can  have  more  than one values for an
                attribute.  For example: ( ... ^attr val1 val2 ...).

augmentation    A working-memory element consisting of  four  fields:    class,
                identifier,  attribute,  and  value.   A group of augmentations
                that share a common class and identifier are called an object.

backtracing     A dependency analysis  that  determines  the  conditions  of  a
                chunk.

chunk           A production learned by Soar.

class           The  first  symbol  of  a working-memory element.  For example:
                (class ...).  Distinguished classes  are  goal,  problem-space,
                state, and [operator].

conditions      The  collection  of  statements  in the if-side of a production
                that are to be matched against the contents of working memory.

condition       A single condition within a production's condition side.

conflict impasse
                An  impasse  where  two  or  more  objects are better than each
                other.

conjunctive test
                A  collection  of  tests  in the condition of a production that
                must all be satisfied for the production to  fire.    They  are
                delimited by { }.

conjunctive negation
                A negated condition, comprised of a conjunction of two or  more
                condition elements.

constraint-failure
                An impasse where there are conflicting necessity preferences on
                which object to choose.

context object  The  value  of  a  context  slot, which is an object with class
                goal, problem-space, state, or operator.

context stack   A stack of goal contexts.

default knowledge
                The  set  of productions that are always loaded with a task and
                provide default responses to impasses.

expensive chunk A chunk whose conditions are combinatorially expensive to match
                against  working  memory.    Can slow down rather than speed up
                Soar's execution after learning.

goal context    A goal and its current problem space, state, and operator.

identifier      A symbol that identifies an object.  Also, the second symbol in
                an augmentation.  For example: (class identifier ^attr val1)

impasse         A  situation  where problem solving is unable to make progress.
                This is detected automatically by the decison procedure.  There
                are   four   types   of  impasses:  tie,  conflict,  no-change,
                constraint-failure.

instantiation   The set of working-memory elements that satisfy the production.

justification   A  structure  built  to  provide  support  for  the result of a
                subgoal.  It is essentially the instantiation of the chunk that
                would be built for the result.

linked          The  contents  of working memory and preference memory, and the
                conditions of productions must be  linked  to  a  goal  context
                through  the identifiers and values of the tested augmentations
                and preferences. The value of an augmentation provides  a  link
                if  the identifier is already linked to a goal identifier.  The
                actions of a production must be linked to the conditions.

multi-attribute An augmentation with multiple values.  For example, (^cells  c1
                c2 c3 ... c9).

negated condition
                Single condition elements that are preceded with a dash (-)  or
                groups  of  condition  elements surrounded by curly braces ({})
                and a single dash.  Signifies a test for the absence  of  those
                patterns in working memory.

no-change impasse
                An impasse where the elaboration phase runs to quiescence,  and
                the  decision  procedure  does not find a change to make to the
                context stack.

object          One or more working-memory elements with  the  same  class  and
                identifier.    Generally  written  as a list beginning with the
                class and identifier, and followed by augmentations.

overgeneral chunk
                A  chunk  whose  conditions  do  not sufficiently constrain the
                match, and which therefore fire in situations where they should
                not.

predicates      Tests  that  can  be included in the conditions of productions,
                including <> (not equal),  <=>  (not  same  type),  >  (greater
                than),  >=  (greater  than or equal, <= (less than or equal), <
                (less than or equal).

preference      A data structure created by the action  of  a  production  that
                asserts  the  relative  or  absolute  worth  of  a value for an
                augmentation.

problem space   The entire collection of states and operators used  to  find  a
                solution to the problem or complete the task at hand.

production      Conditional  statements that form the entire production system.
                If the conditions of a production are  matched,  or  are  true,
                then the actions of a production will be performed.

refinement      A  preference  created  by a production that is not an operator
                creation,  operator  modification,  or   operator   application
                production.  A refinement will be retracted when the production
                that created it no longer matches working memory.

support         Determines the persistence of preferences in preference memory.
                There are two types of support: I-support and O-support.

time-tag        A  unique  number  assigned to a working-memory element.  These
                are generated in sequential order  as  working-memory  elements
                are  created.    Watch  level 1 prints out the time-tags of the
                working-memory   elements   matched,   created   and   removed.
                Functions  wm  and  swm  will print out working-memory elements
                given a time-tag.

token           A data structure  that  holds  a  partial  instantiation  of  a
                production.

value           The fourth field of an augmentation.  It is associated with the
                attribute of the augmentation.  A value can be  a  constant  or
                the identifier of another augmentation.

working memory  The repository for all working-memory elements.

working-memory element
                A  single  unit  of  data  within  working  memory,  either  an
                augmentation or an acceptable preference for a context slot.
II. Templates for Common PSCM Operations
The convention for naming productions is based on the following template:
    [context]*[PSCM function]*[PSCM object type]*[name(s)]
The  [context]  describes  the  general  context  in  which  this production is
applicable.  For most productions it will be the problem space name or the name
of  the desired state if available.  This may be left off when the remainder of
the production name provides sufficient context  as  in  operator  application.
The  [PSCM  object  type]  is either goal, space (for problem space), state, or
operator, depending on the action of the production.  The  [PSCM  function]  is
the PSCM function performed by the production: proposal, comparison, selection,
elaboration, evaluation, testing, implementation, termination,  and  detection.
The  [name(s)]  is  the the name of the PSCM object the production is about, or
some other descriptive term for the objects being augmented.
II.1. Goals
II.1.1. Top Goal
(sp top-goal*elaborate*goal*[goal-name]
  (goal <g> ^object nil)
-->
  (goal <g> ^desired <d> ^name [goal name])
  [possibly preferences for desired state substructure])
II.1.2. Goal for subgoals
(sp [superproblem space name]*elaborate*goal*[goal-name]
  (goal <g> ^object <sg> ^impasse [impasse type] ^attribute [impasse role]
                                [necessary context about impasse])
  (goal <sg> [necessary supercontext])
  [more supercontext structure if necessary]
-->
  (goal <g> ^desired <d> ^name [goal name])
  [possibly preferences for desired state substructure])
II.2. Problem spaces
II.2.1. Propose top problem space
(sp [goal name]*propose*space*[problem space name]
  (goal <g> ^object nil ^name [goal name])
-->
  (goal <g> ^problem-space <p>)
  [possibly preferences for desired state substructure]
  (problem-space <p> ^name [problem space name]
                     ^default-state-copy yes  ; for state copying
                     ^one-level-attributes [attributes]
                     ^two-level-attributes [attributes]))
II.2.2. Propose problem spaces for subgoals
(sp [goal name]*propose*space*[problem space name]
  (goal <g> ^object <sg> ^name [goal name])
 -->
  (goal <g> ^problem-space <p>)
  (problem-space <p> ^name [problem space name]
                     ^default-state-copy yes  ; for state copying
                     ^one-level-attributes [attributes]
                     ^two-level-attributes [attributes]))
II.2.3. Compare problem spaces, binary preferences
(sp [goal name]*compare*spaces*[better space name]*[worse space name]
  (goal <g> ^problem-space <p1> + { <> <p1> <p2> } +
            ^object <sg> ^impasse [impasse type] ^attribute [impasse role]
                        [necessary context about impasse])
  (problem-space <p1> ^name [problem space name])
  (problem-space <p2> ^name [problem space name])
  (goal <sg> [necessary supercontext])
  [more supercontext structure if necessary]
-->
  (goal <g> ^problem-space <p1> [ >, =, or < ] <p2>))
II.2.4. Select problem space, unary preferences
(sp [goal name]*select*space*[name of space]
  (goal <g> ^problem-space <p1> +
            ^object <sg> ^impasse [impasse type] ^attribute [impasse role]
                        [necessary context about impasse])
  (problem-space <p1> ^name [problem space name])
  (goal <sg> [necessary supercontext])
  [more supercontext structure if necessary]
-->
  (goal <g> ^problem-space <p1> [ !, >, =, <, -, or ~ ]))
II.3. States
II.3.1. Propose initial state in the top problem space
(sp [problem space name]*propose*state*top-initial-state
  (goal <g> ^problem-space <p> ^object nil)
  (problem-space <p> ^name [problem space name])
-->
  (goal <g> ^state <s>)
  (state <s>  [structure of state])
  [more preferences for state structure if necessary])
II.3.2. Propose initial state in a subgoal
(sp [problem space name]*propose*state*initial-state
  (goal <sg> ^state <ss> [necessary supercontext])
  [more supercontext, especially about the superstate]
  (goal <g> ^problem-space <p> ^object <sg> [context about impasse])
  (problem-space <p> ^name [problem space name])
-->
  (goal <g> ^state <s>)
  (state <s> ^superstate <ss>
             [structure of state (usually copied from superstate)])
  [more preferences state structure if necessary])
OR using the superstate itself rather than a copy of it
(sp [superproblem space name]*propose*state*[problem space name]*initial-state
  (goal <sg> ^state <ss>)
  [necessary supercontext]
  (goal <g> ^problem-space <p> ^object <sg>
            [context about impasse])
  (problem-space <p> ^name [problem space name])
-->
  (goal <g> ^state <ss>))
II.3.3. Elaborate state
(sp [problem space name]*elaborate*state
  (goal <g> ^problem-space <p> ^state <s>)
  (problem-space <p> ^name [problem space name])
  (state <s> [necessary context for elaboration])
  [other conditions]
-->
  (state <s> [preferences for any arguments or substructure]))
II.3.4. Numeric evaluation of state in subgoal of evaluate-object
(sp [problem space name]*evaluate*state*numeric
  (goal <g> ^problem-space <p> ^state <s> ^object <sg> ^applied <o>)
  (problem-space <p> ^name [problem space name])
  (goal <sg> ^state <ss> ^operator <so>)
  (state <ss> ^evaluation <e>)
  (operator <so> ^type evaluation ^evaluation <e> ^object <o>
                 ^desired <d>)
  (state <s> [augmentations used to determine distance to desired state])
  (desired <d> [augmentations used to determine distance of state])
  -->
  (evaluation <e> ^numeric-value [number]))
II.3.5. Symbolic evaluation of state
(sp [problem space name]*evaluate*state*symbolic
  (goal <g> ^problem-space <p> ^state <s> ^desired <d>)
  (problem-space <p> ^name [problem space name])
  (state <s> [augmentations used to determine distance to desired state])
  (desired <d> [augmentations used to determine distance of state]
  -->
  (state <s> ^[required-success, success, partial-success, indifferent,
                  failure, partial-failure, or prohibit-failure ] <d>))
II.4. Operators
II.4.1 Propose operator
(sp [problem space name]*propose*operator*[operator name]
  (goal <g> ^problem-space <p> ^state <s>)
  (problem-space <p> ^name [problem space name])
  (state <s> [necessary context for proposal]
             [arguments or substructure for operator])
  [other conditions]
-->
  (goal <g> ^operator <o>)
  (operator <o> ^name [operator name]
                [preferences for any arguments or substructure])
II.4.2. Compare operators, binary preferences
(sp [problem space name]*compare*operator*[better operator name]*[worse operato
  (goal <g> ^problem-space <p> ^state <s> ^operator <o1> + { <> <o1> <o2> } +)
  (problem-space <p> ^name [problem space name])
  (state <s> [structure tested to compare worth of operators])
  (operator <o1> ^name [first operator name])
  (operator <o2> ^name [second operator name])
-->
  (goal <g> ^operator <o1> [ >, =, or < ] <o2>))
II.4.3. Select operator, unary preferences
(sp [problem space name]*select*operator*[operator name]
  (goal <g> ^problem-space <p> ^state <s> ^operator <o1> +)
  (problem-space <p> ^name [problem space name])
  (state <s> [structure tested to determine worth of operator])
  (operator <o> ^name [operator name])
-->
  (goal <g> ^operator <o1> [ !, >, =, <, -, or ~ ]))
II.4.4. Operator application
(sp implement*[operator name]
  (goal <g> ^state <s> ^operator <o>)
  (state <s> [structure to be augmented, changed, or removed by operator])
  (operator <o> ^name [operator name] [additional arguments])
-->
  (state <s> [preferences to augment, change, or remove structure])
  [preferences for state substructure])
II.4.5. Operator termination
(sp terminate*[operator name]
  (goal <g> ^state <s> ^operator <o>)
  (state <s> [structure that indicates operator applied])
  (operator <o> ^name [operator name] [arguments or structure])
-->
  (goal <g> ^operator <o> @))
II.5. Goal test
II.5.1. Detect desired feature
(sp [problem space name]*detect*state*[feature]
  (goal <g> ^problem-space <p> ^state <s> ^desired <d>)
  (problem-space <p> ^name [problem space name])
  (state <s> [structure indicates goal partially achieved])
  (desired <d> [structure of desired compared to state])
  -->
  (state <s> [structure that records goal partially achieved]))
II.5.2. Detect desired state
(sp [problem space name]*detect*state*success
  (goal <g> ^problem-space <p> ^state <s> ^desired <d>)
  (problem-space <p> ^name [problem space name])
  (state <s> [structure that indicates goal is achieved])
  (desired <d> [structure that indicates goal is achieved])
-->
  (state <s> ^[required-success, success, or partial-success] <d>))
II.5.3. Detect failed state
(sp [problem space name]*detect*state*failure
  (goal <g> ^problem-space <p> ^state <s> ^desired <d>)
  (problem-space <p> ^name [problem space name])
  (state <s> [structure that indicates that state failed])
  (desired <d> [structure that indicates that state failed])
-->
  (state <s> ^[required-failure, failure, or partial-failure] <d>))
II.6. Results
II.6.1. Result superoperator
(sp [superproblem space name]*result*operator*[problem space name]
  (goal <g> ^problem-space <p> ^state <s> ^desired <d> ^object <sg>)
  (problem-space <p> ^name [problem space name])
  (state <s> ^success <d>
             [structure indicating appropriate superoperator]
             [arguments or substructure to pass to superoperator])
  (goal <sg> ^problem-space <sp> ^state <ss>)
-->
  (goal <sg> ^operator <o>)
  (operator <o> ^name [appropriate operator name]
                      [arguments or substructure]))
References

[Acharya and Tambe 89a]
               Acharya, A. and Tambe, M.
               Production systems on message passing computers: Simulation
                  results and analysis.
               In Proceedings of the International Conference on Parallel
                  Processing, pages 246-254.  1989.

[Acharya and Tambe 89b]
               Acharya, A. and Tambe, M.
               Efficient implementations of production systems.
               VIVEK: A quarterly in artificial intelligence2(1):3-18, 1989.

[Adelson 88]   Adelson, B.
               Modeling software design in a problem-space architecture.
               In Proceedings of the Annual Conference of the Cognitive Science
                  Society, pages 174-180.  August, 1988.

[Akyurek 90a]  Akyurek, A.
               On a Computational Model of Human Planning.
               Technical Report RUG-FA-90-1, University of Groningen,
               August, 1990.
               revised.

[Akyurek 90b]  Akyurek, A.
               Means-Ends Planning, Operator Subgoaling, and Operator
                  Valuation: An Example Program.
               Technical Report RUG-FA-90-3, University of Groningen,
               August, 1990.

[Altmann, Newell, and Yost 90]
               Altmann, E., Newell, A., and Yost, G.R.
               Mapping Domains to Computational Models:  Shared concerns of
                  problem spaces and object-oriented systems (extended
                  abstract).
               To be presented at the Finding the Object workshop, Object
                  Oriented Programming Systems, Languages, and Applications
                  conference, Ottawa, October, 1990.

[Carley and Wendt 88]
               Carley, K. and Wendt, K.
               Electronic Mail and the Diffusion of Scientific Information: The
                  study of Soar and its dominant users.
               Department of Social and Decision Sciences, Carnegie Mellon
                  University, July, 1988.  Unpublished.

[Congdon 90]   Congdon, C.B.
               Learning Control Knowledge in an Unsupervised Planning Domain.
               Artificial Intelligence Laboratory, The University of Michigan,
                  February, 1990.  Unpublished.

[Covrigaru 90] Covrigaru, A.
               The Goals of Autonomous Systems.
               Artificial Intelligence Laboratory, The University of Michigan,
                  May, 1990.  Unpublished.

[Flynn 88a]    Flynn, R.
               Restructuring Knowledge in Soar: Searching for the right
                  paradigm-specific representations.
               Digital Equipment Corporation, September, 1988.  Reprinted and
                  available from Carnegie Mellon University.  Unpublished.

[Flynn 88b]    Flynn, R.
               Placing Soar on the Connection Machine.
               Digital Equipment Corporation, September, 1988.  An extended
                  abstract of this paper was distributed at the AAAI
                  Mini-Symposium, How Can Slow Components Think So Fast?,
                  Spring, 1988.  Both are reprinted and are available at
                  Carnegie Mellon University.

[Forgy 79]     Forgy, C. L.
               On the Efficient Implementation of Production Systems.
               PhD thesis, Computer Science Department, Carnegie Mellon
                  University, February, 1979.

[Forgy 81]     Forgy, C. L.
               OPS5 User's Manual.
               Technical Report CMU-CS-81-135, Computer Science Department,
                  Carnegie Mellon University,
               July, 1981.

[Forgy 82]     Forgy, C. L.
               Rete: A fast algorithm for the many pattern/many object pattern
                  match problem.
               Artificial Intelligence19(1):17-37, 1982.

[Forgy 84]     Forgy, C. L.
               The OPS83 Report.
               Technical Report CMU-CS-84-133, Computer Science Department,
                  Carnegie Mellon University,
               May, 1984.

[Forgy and Gupta 86]
               Forgy, C. and Gupta, A.
               Preliminary architecture of the CMU production system machine.
               In Hawaii International Conference on Systems Sciences, pages
                  194-200.  January, 1986.

[Golding 87]   Golding, A.
               Learning to Pronounce Names by Taking Advice.
               Thesis Proposal, Knowledge Systems Laboratory, Stanford
                  University, November, 1987.  Unpublished.

[Golding, Rosenbloom, and Laird 87]
               Golding, A., Rosenbloom, P. S., and Laird, J. E.
               Learning general search control from outside guidance.
               In Proceedings of the Tenth International Joint Conference on
                  Artificial Intelligence, pages 334-337.  August, 1987.

[Gupta 84a]    Gupta, A.
               Implementing OPS5 production systems on DADO.
               Technical Report CMU-CS-84-115, Computer Science Department,
                  Carnegie Mellon University,
               March, 1984.

[Gupta 84b]    Gupta, A.
               Parallelism in Production Systems:  The sources and the expected
                  speed-up.
               Technical Report CMU-CS-84-169, Computer Science Department,
                  Carnegie Mellon University,
               December, 1984.

[Gupta 86]     Gupta, A.
               Parallelism in Production Systems.
               PhD thesis, Computer Science Department, Carnegie Mellon
                  University, March, 1986.
               Also available as Parallelism in Production Systems, Los Altos,
                  CA: Morgan-Kaufman, 1987.

[Gupta and Forgy 83]
               Gupta, A. and Forgy, C.
               Measurements on Production Systems.
               Technical Report CMU-CS-83-167, Computer Science Department,
                  Carnegie Mellon University,
               December, 1983.

[Gupta and Tambe 88]
               Gupta, A. and Tambe, M.
               Suitability of message passing computers for implementing
                  production systems.
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 687-692.  August, 1988.

[Gupta and Tucker 88]
               Gupta, A. and Tucker, A.
               Exploiting variable grain parallelism at runtime.
               In Proceedings of the ACM/SIGPLAN Symposium on Parallel
                  Programming: Experience with applications, languages, and
                  systems, pages 212-221.  July, 1988.

[Gupta, et. al. 87]
               Gupta, A., Forgy, C.L., Kalp, D., Newell, A., and Tambe, M.
               Results of Parallel Implementation of OPS5 on the Encore
                  Multiprocessor.
               Technical Report CMU-CS-87-146, Computer Science Department,
                  Carnegie Mellon University,
               August, 1987.

[Gupta, et. al. 88a]
               Gupta, A., Forgy, C. L., Kalp, D., Newell, A., and Tambe, M.
               Parallel OPS5 on the Encore Multimax.
               In Proceedings of the International Conference on Parallel
                  Processing, pages 271-280.  August, 1988.

[Gupta, et. al. 88b]
               Gupta, A., Tambe, M., Kalp, D., Forgy, C. L., and Newell, A.
               Parallel implementation of OPS5 on the Encore Multiprocessor:
                  Results and analysis.
               International Journal of Parallel Programming17(2):95-124, 1988.

[Gupta, Forgy, Newell, and Wedig 86]
               Gupta, A., Forgy, C., Newell, A., and Wedig, R.
               Parallel algorithms and architectures for production systems.
               In Proceedings of the Thirteenth International Symposium on
                  Computer Architectures, pages 28-35.  June, 1986.

[Harvey, et. al. 89]
               Harvey, W., Kalp, D., Tambe, M., McKeown, D., and Newell, A.
               Measuring the Effectiveness of Task-Level Parallelism for
                  High-Level Vision.
               Technical Report CMU-CS-89-125, School of Computer Science,
                  Carnegie Mellon University,
               March, 1989.

[Hsu, Newell, Prietula, and Steier 89]
               Hsu, W.L., Newell, A., Prietula, M.J., and Steier, D.M.
               Sharing scheduling knowledge between intelligent agents
                  (Extended abstract).
               To appear in the proceedings of the AAAI-SIGMAN Workshop on
                  Manufacturing Scheduling, Eleventh International Joint
                  Conference on Artificial Intelligence, August 23, 1989.

[Hsu, Prietula and Steier 88]
               Hsu, W., Prietula, M., and Steier, D.M.
               Merl-Soar:  Applying Soar to scheduling.
               In Proceedings of the Workshop on Artificial Intelligence
                  Simulation, The National Conference on Artificial
                  Intelligence, pages 81-84.  August, 1988.
                  s paper  as prepa ed for d st ibu ion at the w
               Thiextendedwabstractrappearediinrthetproceedings.orkshop.  An

[Hsu, Prietula, and Steier 89]
               Hsu, W., Prietula, M., and Steier, D.M.
               Merl-Soar: Scheduling within a general architecture for
                  intelligence.
               In Proceedings of the Third International Conference on Expert
                  Systems and the Leading Edge in Production and Operations
                  Management, pages 467-481.  May, 1989.

[Hucka 89]     Hucka, M.
               Planning, Interruptability, and Learning in Soar.
               Department of Electrical Engineering and Computer Science,
                  University of Michigan, May, 1989, Report on directed-study
                  research.  Unpublished.

[Huffman 89]   Huffman, S.B.
               A Natural-language System for Interaction with Problem-solving
                  Domains: Extensions to NL-Soar.
               Department of Electrical Engineering and Computer Science,
                  University of Michigan, May, 1989.  Report on directed-study
                  research.  Unpublished.

[Hughes 88]    Hughes, K.
               COAL:  A New Framework for Performance Evaluation.
               Master's thesis, Department of Electrical and Computer
                  Engineering, Carnegie Mellon University, August, 1988.

[John 88]      John, B.E.
               Contributions to Engineering Models of Human-Computer
                  Engineering.
               PhD thesis, Department of Psychology, Carnegie Mellon
                  University, May, 1988.

[John 90]      John, B.E.
               Extensions of GOMS analyses to expert performance requiring
                  perception of dynamic visual and auditory information.
               In Proceedings of the Conference on Human Factors and Computing
                  Systems, pages 107-115.  April, 1990.

[Johnson, Smith, and Smith 90]
               Johnson, K.A., Smith, J.A., and Smith, P.
               Design of a blood bank tutor.
               In Proceedings of the AAAI Mini-Symposium on Artificial
                  Intelligence in Medicine, pages 102-104.  March, 1990.

[Kalp, et. al. 88]
               Kalp, D., Tambe, M., Gupta, A., Forgy, C., Newell, A., Acharya,
               A., Milnes, B., and Swedlow, K.
               Parallel OPS5 User's Manual.
               Technical Report CMU-CS-88-187, Computer Science Department,
                  Carnegie Mellon University,
               November, 1988.

[Laird 84]     Laird, J.E.
               Universal Subgoaling.
               PhD thesis, Department of Computer Science, Carnegie Mellon
                  University, May, 1984.

[Laird 86a]    Laird, J.E.
               Soar User's Manual:  Version 4.0.
               Technical Report , Intelligent Systems Laboratory, Palo Alto
                  Research Center, Xerox Corporation,
               1986.
               Reprinted and available from Carnegie Mellon University.

[Laird 86b]    Laird, J.E.
               The Soar Casebook.
               Intelligent Systems Laboratory, Palo Alto Research Center, Xerox
                  Corporation, 1986.  Reprinted and available from Carnegie
                  Mellon University.

[Laird 88]     Laird, J.
               Recovery from incorrect knowledge in Soar.
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 618-623.  August, 1988.

[Laird 90]     Laird, J.E.
               Integrating planning and execution in Soar.
               To appear in the Proceedings of the 1990 AAAI Spring Symposium
                  Series on Planning in Uncertain, Unpredictable, and Changing
                  Environments.

[Laird and Newell 83a]
               Laird, J.E. and Newell, A.
               A Universal Weak Method.
               Technical Report CMU-CS-83-141, Computer Science Department,
                  Carnegie Mellon University,
               June, 1983.

[Laird and Newell 83b]
               Laird, J.E. and Newell, A.
               A universal weak method: Summary of results.
               In Proceedings of the Eighth International Joint Conference on
                  Artificial Intelligence, pages 771-773.  August, 1983.

[Laird and Rosenbloom 87]
               Laird, J.E. and Rosenbloom, P.S.
               Research on learning in Soar.
               In Proceedings of the Second Annual Artificial Intelligence
                  Research Forum, pages 240-253.  1987.

[Laird and Rosenbloom 90]
               Laird, J.E. and Rosenbloom, P.S.
               Integrating planning, execution, and learning in Soar for
                  external environments.
               To appear in the Proceedings of the National Conference on
                  Artificial Intelligence, August, 1990.
               An earlier version of this paper will appear in the AAAI Spring
                  Symposium Workshop on Planning in Uncertain, Unpredictable,
                  and Changing Environments.

[Laird, et. al. 85]
               Laird, J.E., Rosenbloom, P.S., Newell, A., McDermott, J., and
               Orciuch, E.
               Two Soar Studies:  Towards chunking as a general learning
                  mechanism and R1-Soar: An experiment in knowledge-intensive
                  programming in a problem-solving architecture.
               Technical Report CMU-CS-85-110, Carnegie Mellon University,
               January, 1985.
               This report is a reprint of two papers, previously published
                  separately.

[Laird, et. al. 89a]
               Laird, J.E., Swedlow, K.R., Altmann, E., Congdon, C.B., and
               Wiesmeyer, M.
               Soar 4.5 User's Manual.
               School of Computer Science, Carnegie Mellon University and
                  Department of Electrical Engineering and Computer Science,
                  University of Michigan, June, 1989.  Unpublished.

[Laird, et. al. 89b]
               Laird, J.E., Swedlow, K.R., Altmann, E., and Congdon, C.B.
               Soar 5 User's Manual.
               School of Computer Science, Carnegie Mellon University and
                  Department of Electrical Engineering and Computer Science,
                  University of Michigan, June, 1989.  Unpublished.

[Laird, Hucka, Yager, and Tuck 90]
               Laird, J.E., Hucka, M., Yager, E.S., and Tuck, C.M.
               Correcting and extending domain knowledge using outside
                  guidance.
               To appear in the Proceedings of the Seventh International
                  Conference on Machine Learning, June 1990.

[Laird, Newell, and Rosenbloom 87]
               Laird, J.E., Newell, A., and Rosenbloom, P.S.
               Soar:  An architecture for general intelligence.
               Artificial Intelligence33(1):1-64, 1987.

[Laird, Rosenbloom, and Newell 84]
               Laird, J.E., Rosenbloom, P.S., and Newell, A.
               Towards chunking as a general learning mechanism.
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 188-192.  August, 1984.

[Laird, Rosenbloom, and Newell 86a]
               Laird, J.E., Rosenbloom, P.S., and Newell, A.
               Universal Subgoaling and Chunking:  The automatic generation and
                  learning of goal hierarchies.
               Kluwer Academic Publishers, Boston, Massachusetts, 1986.

[Laird, Rosenbloom, and Newell 86b]
               Laird, J.E., Rosenbloom, P.S., and Newell, A.
               Universal Subgoaling: The Automatic Generation of Goal
                  Hierarchies.
               Kluwer Academic Publishers, Boston, MA, 1986.

[Laird, Rosenbloom, and Newell 86c]
               Laird, J. E., Rosenbloom, P.S., and Newell, A.
               Chunking in Soar:  The anatomy of a general learning mechanism.
               Machine Learning1(1):11-46, 1986.

[Laird, Rosenbloom, and Newell 86d]
               Laird, J.E., Rosenbloom, P.S., and Newell, A.
               Overgeneralization during knowledge compilation in Soar.
               In Proceedings of the Workshop on Knowledge Compilation, pages
                  46-57.  September, 1986.

[Laird, Yager, Hucka, and Tuck 90]
               Laird, J.E., Yager, E.S., Hucka, M., and Tuck, C.M.
               Robo-Soar: An integration of external interaction, planning.
                  and learning using Soar.
               To appear in Van de Velde (ed.) Machine Learning for Autonomous
                  Agents, 1990.

[Laird, Yager, Tuck, and Hucka 89]
               Laird, J.E., Yager, E.S., Tuck, C.M., and Hucka, M.
               Learning in tele-autonomous systems using Soar.
               To appear in the proceedings of the NASA Conference on Space
                  Telerobics, January, 1989.

[Lehr 86]      Lehr, T.F.
               The implementation of a production system machine.
               In Proceedings of the Hawaii International Conference on Systems
                  Sciences, pages 177-186.  January, 1986.

[Letovsky 90]  Letovsky, S.
               Operationality criteria for recursive predicates.
               To appear in the Proceedings of the National Conference on
                  Artificial Intelligence, August, 1990.

[Lewis, et. al. 90]
               Lewis, R.L., Huffman, S.B., John, B.E., Laird, J.E., Lehman,
               J.F., Newell, A., Rosenbloom, P.S., Simon, T., Tessler, S.G.
               Soar as a Unified Theory of Cognition: Spring 1990.
               Proceedings of the Twelfth Annual Conference of the Cognitive
                  Science Society, Cambridge, MA, July 25-28, 1990.

[Lewis, Newell, and Polk 89]
               Lewis, R.L., Newell, A., and Polk, T.A.
               Toward a Soar theory of taking instructions for immediate
                  reasoning tasks.
               In Proceedings of the Annual Conference of the Cognitive Science
                  Society, pages 514-521.  1989.

[Miller and Laird 90]
               Miller, C.S. and Laird, J.E.
               A Simple, Symbolic Model for Associative Learning and Retrieval.
               Artificial Intelligence Laboratory, The University of Michigan,
                  March, 1990.  Unpublished.

[Milnes and Swedlow 88]
               Milnes, B. G. and Swedlow, K. R.
               Soar Teaching Slides.
               Teaching slides for the June, 1988 Soar class.  Unpublished. .

[Modi 89]      Modi, A.K.
               Integrating Learning and Problem Solving Within a Chemical
                  Process Designer.
               Thesis Proposal, Engineering Design Research Center, Carnegie
                  Mellon University, May, 1989.  Unpublished.

[Modi and Westerberg 89]
               Modi, A.K. and Westerberg, A.W.
               Integrating learning and problem solving within a chemical
                  process designer.
               Presented at the Annual Meeting of the American Institute of
                  Chemical Engineers, November, 1989.

[Modi, Steier, and Westerberg 90]
               Modi, A.K., Steier, D.M., and Westerberg, A.W.
               Learning to use approximations and abstractions in the design of
                  chemical processes.
               In Proceedings of the AAAI Workshop on Automatic Generation of
                  Approximation and Abtractions.  July, 1990.

[Nayak, Gupta, and Rosenbloom 88]
               Nayak, P., Gupta, A., and Rosenbloom, P.
               Comparison of the Rete and Treat production matchers for Soar (A
                  Summary).
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 693-698.  August, 1988.

[Newell 81]    Newell, A.
               Reasoning, problem solving and decision processes:  The problem
                  space as a fundamental category.
               In Nickerson, N. (ed.), Attention and Performance VIII:693-718,
                  1981.
               Lawrence Erlbaum Associates, Hillsdale, New Jersey.

[Newell 82]    Newell, A.
               The knowledge level.
               Artificial Intelligence18(1):87-127, 1982.

[Newell 86]    Newell, A.
               New Problem Spaces.
               Computer Science Department, Carnegie Mellon University,
                  February, 1986.  Unpublished.

[Newell 87]    Newell, A.
               Soar Research Tasks.
               Computer Science Department, Carnegie Mellon University,
                  September, 1987.  Unpublished.

[Newell 88]    Newell, A.
               Annotated Models.
               Computer Science Department, Carnegie Mellon University,
                  November, 1988.  Unpublished.

[Newell 89]    Newell, A.
               The quest for architectures for integrated intelligent systems
                  (Extended abstract).
               Presented at the Eleventh International Joint Conference on
                  Artificial Intelligence, August, 1989.  Unpublished.

[Newell 90]    Newell, A.
               Unified Theories of Cognition.
               Harvard University Press, Cambridge, Massachusetts, 1990.
               In press.

[Newell and Laird 80]
               Newell, A. and Laird, J.E.
               Operationalizing Problem Spaces.
               Computer Science Department, Carnegie Mellon University,
                  October, 1980.  Unpublished.

[Newell and Rosenbloom 80]
               Newell, A. and Rosenbloom, P.S.
               Mechanisms of Skill Acquisition and the Law of Practice.
               Technical Report CMU-CS-80-145, Computer Science Department,
                  Carnegie Mellon University,
               September, 1980.

[Newell, et. al. 90]
               Newell, A., Yost, G.R., Laird, J.E., Rosenbloom, P.S., and
               Altmann, E.
               Formulating the problem space computational model.
               To be presented at the 25th Anniversary Symposium, School of
                  Computer Science, Carnegie Mellon University, September
                  24-26, 1990.

[Newell, Rosenbloom, and Laird 89]
               Newell, A., Rosenbloom, P.S., and Laird, J.E.
               Symbolic architectures for cognition.
               In Posner, M.I. (editor), Foundations of Cognitive Science,
                  pages 93-131. Bradford Books/MIT Press, Cambridge,
                  Massachusetts, 1989.

[Polk and Newell 88]
               Polk, T. A. and Newell, A.
               Modeling human syllogistic reasoning in Soar.
               In Proceedings of the Annual Conference of the Cognitive Science
                  Society, pages 181-187.  August, 1988.

[Polk, Newell, and Lewis 89]
               Polk, T.A., Newell, A., and Lewis, R.L.
               Toward a unified theory of immediate reasoning in Soar.
               In Proceedings of the Annual Conference of the Cognitive Science
                  Society, pages 506-513.  1989.

[Polk, Newell, and VanLehn 90]
               Polk, T. A., Newell, A., and VanLehn, K.
               Fitting Symbolic Parameter Cognitive Models:  A Proposal for the
                  ASPM System.
               School of Computer Science, Carnegie Mellon University and
                  Learning Research and Development Center, University of
                  Pittsburgh, 19 July 1990.

[Reich 88a]    Reich, Y.
               Learning Plans as a Weak Method for Design.
               Department of Civil Engineering, Carnegie Mellon University,
                  March, 1988.  Unpublished.

[Reich 88b]    Reich, Y.
               Learning Efficient Representations For Design.
               Thesis Proposal, Department of Civil Engineering, Carnegie
                  Mellon University, July, 1988.  Unpublished.

[Reich and Fenves 88]
               Reich, Y. and Fenves, S.
               Floor-System Design in Soar: A case study of learning to learn.
               Technical Report EDRC-12-26-88, Engineering Design Research
                  Center, Carnegie Mellon University,
               March, 1988.

[Reich and Fenves 89]
               Reich, Y. and Fenves, S.
               Integration of Generic Learning Tasks.
               Technical Report EDRC-12-28-89, Engineering Design Research
                  Center, Carnegie Mellon University,
               December, 1989.

[Rosenbloom 83]
               Rosenbloom, P. S.
               The Chunking of Goal Hierarchies: A model of practice and
                  stimulus-response compatibility.
               PhD thesis, Computer Science Department, Carnegie Mellon
                  University, August, 1983.
               Also available in Laird, J.E., Rosenbloom, P.S. and Newell
                  A. (eds.) Universal Subgoaling and Chunking: The automatic
                  generation of goal hierarchies, (1986) Kluwer Academic
                  Publishers, Boston, MA.

[Rosenbloom 88a]
               Rosenbloom, P.
               White Paper on Soar:  Matching Representation to Performance and
                  Learning.
               Information Sciences Institute, University of Southern
                  California, January, 1988.  Unpublished.

[Rosenbloom 88b]
               Rosenbloom, P. S.
               Beyond generalization as search:  Towards a unified framework
                  for the acquisition of new knowledge.
               In Proceedings of the AAAI Symposium on Explanation-Based
                  Learning, pages 17-21.  March, 1988.

[Rosenbloom 89]
               Rosenbloom, P.S.
               A symbolic goal-oriented perspective on connectionism and Soar.
               Connectionism in Perspective.
               In Pfeifer, R., Schreter, Z., Fogelman-Soulie, F., and Steels,
                  L. (eds.),
               Elsevier (North-Holland), Amsterdam, The Netherlands, 1989,
                  pages 245-263.

[Rosenbloom and Aasman 90]
               Rosenbloom, P.S. and Aasman J.
               Knowledge level and inductive uses of chunking (EBL).
                  appear in  he Proceeding  of the Natio
               To ArtificialtIntelligence,sAugust, 1990.nal Conference on

[Rosenbloom and Laird 86]
               Rosenbloom, P. S. and Laird, J. E.
               Mapping explanation-based generalization onto Soar.
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 561-567.  August, 1986.

[Rosenbloom and Newell 82]
               Rosenbloom, P. S. and Newell, A.
               Learning by chunking: Summary of a task and a model.
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 255-257.  August, 1982.

[Rosenbloom and Newell 86]
               Michalski, R. S., Carbonell, J. G., and Mitchell, T. M. (eds.)
               (editors).
               The chunking of goal hierarchies:  A generalized model of
                  practice.
               Morgan Kaufmann Publishers, Inc., Los Altos, California, 1986.

[Rosenbloom and Newell 87a]
               Rosenbloom, P. S. and Newell, A.
               Learning by chunking: A production-system model of practice.
               In Klahr, D., Langley, P., and Neches, R. (editors), Production
                  Systems Models of Learning and Development, pages 221-286.
                  MIT Press, Cambridge, Massachusetts, 1987.

[Rosenbloom and Newell 87b]
               Rosenbloom, P.S. and Newell, A.
               An integrated computational model of stimulus-response
                  compatibility and practice.
               In Bower, G.H. (editor), The Psychology of Learning and
                  Motivation, pages 183-198. Academic Press, New York, 1987.

[Rosenbloom, et. al. 85]
               Rosenbloom, P. S., Laird, J. E., McDermott, J., Newell, A., and
               Orciuch, E.
               R1-Soar: An experiment in knowledge-intensive programming in a
                  problem-solving architecture.
               IEEE Transactions on Pattern Analysis and Machine
                  Intelligence7(5):561-569, 1985.
               Reprinted in Two Soar Studies and available from Carnegie Mellon
                  University.

[Rosenbloom, et. al. 86]
               Rosenbloom, P.S., Laird, J.E., Newell, A., Golding, A., and
               Unruh, A.
               Current research on learning in Soar.
               In Mitchell, T.M., Carbonell, J.G., and Michalski, R.S.
                  (editors), Machine Learning: A Guide To Current Research,
                  pages 290-297. Kluwer Academic Press, Boston, Massachusetts,
                  1986.

[Rosenbloom, Laird, and Newell 87a]
               Rosenbloom, P. S., Laird, J. E., and Newell, A.
               Knowledge level learning in Soar.
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 499-504.  August, 1987.

[Rosenbloom, Laird, and Newell 87b]
               Rosenbloom, P. S., Laird, J. E., and Newell, A.
               Meta-levels in Soar.
               In Maes, P. and Nardi, D. (editors), Meta-Level Architectures
                  and Reflection, pages 227-240. North Holland Publishing
                  Company, Amsterdam, 1987.

[Rosenbloom, Laird, and Newell 88]
               Rosenbloom, P. S., Laird, J. E., and Newell, A.
               The chunking of skill and knowledge.
               In Bouma, H. and Elsendoorn, A.G. (editors), Working Models of
                  Human Perception, pages 391-410. Academic Press, London,
                  England, 1988.

[Rosenbloom, Laird, Newell, and McCarl 89]
               Rosenbloom, P. S., Laird, J. E., Newell, A., and McCarl, R.
               A preliminary analysis of the Soar architecture as a basis for
                  general intelligence.
               In Kirsh, D. and Hewitt, C. (editors), Proceedings of the
                  Workshop on Foundations of Artificial Intelligence. MIT
                  Press, Cambridge, Massachusetts, 1989.
               In press.

[Rosenbloom, Lee, and Unruh 90]
               Rosenbloom, P.S., Lee, S., and Unruh, A.
               Responding to Impasses in Memory-Driven Behavior: A framework
                  for planning.
               Information Sciences Institute, University of Southern
                  California and Knowledge Systems Laboratory, Stanford
                  University, July, 1990.  Unpublished.

[Rosenbloom, Newell, and Laird 90]
               Rosenbloom, P.S., Newell, A., and Laird, J.E.
               Towards the knowledge level in Soar: The role of the
                  architecture in the use of knowledge.
               In VanL ehn, K. (ed.), Architectures for Intelligence.
               Lawrence Erlbaum Associates, Hillsdale, NJ, 1990 In press.

[Ruiz 87]      Ruiz, D.
               Learning and Problem-Solving: What is learned while solving the
                  towers of Hanoi.
               PhD thesis, Department of Psychology, Stanford University,
                  September, 1987.
               Reprinted and available at Carnegie Mellon University.

[Ruiz and Newell 89]
               Ruiz, D. and Newell, A.
               Tower-noticing triggers strategy-change in the Tower of Hanoi: A
                  Soar model.
               In Proceedings of the Annual Conference of the Cognitive Science
                  Society, pages 522-529.  1989.

[Ruiz and Rosenbloom 88]
               Ruiz, D. and Rosenbloom, P. S.
               Learning and Problem-Solving: What is learned while solving the
                  towers of Hanoi.
               Department of Psychology, Carnegie Mellon University and
                  Information Sciences Institute, University of Southern
                  California, July, 1988.  Unpublished.

[Scales 86]    Scales, D.J.
               Efficient matching algorithms for the SOAR/OPS5 production
                  system.
               Technical Report KSL-86-47, Knowledge Systems Laboratory,
                  Stanford University,
               June, l986.

[Simon 90a]    Simon, T.
               Generalisation Domain Theories as Complements to Psychological
                  Performance Models.
               Department of Psychology, Carnegie Mellon University, January,
                  1990.  Unpublished.

[Simon 90b]    Simon, T.
               Modelling Human Cognitive Development with Explanation-Based
                  Learning in Soar.
               Department of Psychology, Carnegie Mellon University, February,
                  1990.  Unpublished.

[Smith and Rosenbloom 90]
               Smith, B.D. and Rosenbloom, P.S.
               Incremental non-backtracking focusing: A polynomially bounded
                  generalization algorithm for version spaces.
               To appear in the Proceedings of the National Conference on
                  Artificial Intelligence, August, 1990.

[Soar 87]      The Soar Group.
               Transparencies from the Third Soar Workshop.
               Knowledge Systems Laboratory, Stanford University, June, 1987.
                  Unpublished.

[Soar 88a]     The Soar Group.
               Transparencies from the Fourth Soar Workshop.
               Department of Electrical and Computer Engineering, University of
                  Michigan, January 1988.  Unpublished.

[Soar 88b]     The Soar Group.
               Transparencies from the Fifth Soar Workshop.
               Computer Science Department, Carnegie Mellon University,
                  September, 1988.  Unpublished.

[Soar 88c]     The Soar Group.
               Transparencies from the First EuroSoar Workshop.
               The Open University, Milton Keynes, U.K., October, 1988.
                  Unpublished.

[Soar 89]      The Soar Group.
               Transparencies from the Sixth Soar Workshop.
               Department of Electrical and Computer Engineering, The
                  University of Michigan, May, 1989.  Unpublished. .

[Soar 90a]     The Soar Group.
               Transparencies from the Seventh Soar Workshop.
               School of Computer Science, Carnegie Mellon University.
                  February, 1990.  Unpublished.

[Soar 90b]     The Soar Group.
               Transparencies from the Third European Soar Workshop.
               Psychology Department, University of Nottingham, U.K., March
                  10-11, 1990.  Unpublished.

[Steier 86]    Steier, D.M.
               Speeding up Soarware.
               Computer Science Department, Carnegie Mellon University, April,
                  1986.  Unpublished.

[Steier 87a]   Steier, D.M.
               Integrating Multiple Sources of Knowledge into an Automatic
                  Algorithm Designer.
               Thesis Proposal, Computer Science Department, Carnegie Mellon
                  University, September, 1987.  Unpublished.

[Steier 87b]   Steier, D. M.
               Cypress-Soar:  A case study in search and learning in algorithm
                  design.
               In Proceedings of the Tenth International Joint Conference on
                  Artificial Intelligence, pages 327-330.  August, 1987.

[Steier 89a]   Steier, D.M.
               Automating Algorithm Design Within an Architecture for General
                  Intelligence.
               PhD thesis, School of Computer Science, Carnegie Mellon
                  University, March, 1989.

[Steier 89b]   Steier, D.M.
               "But How Did You Know To Do That?": What a theory of algorithm
                  design process can tell us.
               Engineering Design Research Center, Carnegie Mellon University,
                  August, 1989.  Unpublished.

[Steier 90]    Steier, D.M.
               Intelligent architectures for integration.
               In Proceedings of the IEEE Conference on Systems Integration.
                  August, 1990.
               A shorter version of this paper will appear in the proceedings.

[Steier and Newell 88]
               Steier, D.M. and Newell, A.
               Integrating multiple sources of knowledge into Designer-Soar, an
                  automatic algorithm designer.
               In Proceedings of the National Conference on Artificial
                  Intelligence, pages 8-13.  August, 1988.

[Steier, et. al. 87]
               Steier, D. M., Laird, J. E., Newell, A., Rosenbloom, P. S.,
               Flynn, R. A., Golding, A., Polk, T. A., Shivers, O. G., Unruh,
               A., and Yost, G. R.
               Varieties of learning in Soar: 1987.
               In Proceedings of the Fourth International Workshop on Machine
                  Learning, pages 300-311.  June, 1987.

[Tambe 88]     Tambe, M.
               Speculations on the Computational Effects of Chunking.
               Computer Science Department, Carnegie Mellon University,
                  December, 1988.  Unpublished.

[Tambe and Acharya 89]
               Tambe, M. and Acharya, A.
               Parallel implementations of production systems.
               VIVEK: A quarterly in artificial intelligence2(2):3-22, 1989.

[Tambe and Newell 88a]
               Tambe, M. and Newell, A.
               Some chunks are expensive.
               In Proceedings of the Fifth International Conference on Machine
                  Learning, pages 451-458.  June, 1988.

[Tambe and Newell 88b]
               Tambe, M. and Newell, A.
               Why Some Chunks Are Expensive.
               Technical Report CMU-CS-88-103, Computer Science Department,
                  Carnegie Mellon University,
               January, 1988.

[Tambe and Rosenbloom 88]
               Tambe, M. and Rosenbloom, P.
               Eliminating Expensive Chunks.
               Technical Report CMU-CS-88-189, Computer Science Department,
                  Carnegie Mellon University,
               November, 1988.

[Tambe and Rosenbloom 89]
               Tambe, M. and Rosenbloom, P.
               Eliminating expensive chunks by restricting expressiveness.
               In Proceedings of the Eleventh International Joint Conference on
                  Artificial Intelligence, pages 731-737.  1989.

[Tambe, Acharya, and Gupta 89]
               Tambe, M., Acharya, A., and Gupta, A.
               Implementation of Production Systems on Message Passing
                  Computers: Techniques, simulation results and analysis.
               Technical Report CMU-CS-89-129, School of Computer Science,
                  Carnegie Mellon University,
               April, 1989.

[Tambe, et. al. 88]
               Tambe, M., Kalp, D., Gupta, A., Forgy, C.L., Milnes, B.G., and
               Newell, A.
               Soar/PSM-E: Investigating match parallelism in a learning
                  production system.
               In Proceedings of the ICM/SIGPLAN Symposium on Parallel
                  Programming: Experience with Applications, Languages, and
                  Systems, pages 146-160.  July, 1988.

[Tambe, Newell, and Rosenbloom 90]
               Tambe, M., Newell, A., & Rosenbloom, P. S.
               The problem of expensive chunks and its solution by restricting
                  expressiveness.
               Machine Learning, 1990.
               In press.

[Unruh 90]     Unruh, A.
               Abstraction in Soar.
               Thesis Proposal, Knowledge Systems Laboratory, Stanford
                  University, April, 1988.  Unpublished.

[Unruh and Rosenbloom 89]
               Unruh, A. and Rosenbloom, P.
               Abstraction in problem solving and learning.
               In Proceedings of the Eleventh International Joint Conference on
                  Artificial Intelligence, pages 681-687.  1989.

[Unruh and Rosenbloom 90]
               Unruh, A. and Rosenbloom, P. S.
               Two new weak method increments for abstraction.
               In Proceedings of the AAAI Workshop on Automatic Generation of
                  Approximation and Abtractions.  July, 1990.

[Unruh, Rosenbloom, and Laird 87]
               Unruh, A., Rosenbloom, P. S., and Laird, J. E.
               Dynamic abstraction problem solving in Soar.
               In Proceedings of the Third Annual Conference on Aerospace
                  Applications of Artificial Intelligence, pages 245-256.
                  October, 1987.

[Vicinanza and Prietula 89]
               Vicinanza, S. and Prietula, M.J.
               A computational model of musical creativity (Extended abstract).
               Prepared for the AI and Music Workshop, Eleventh International
                  Joint Conference on Artificial Intelligence, August 20-25,
                  1989.

[Ward 88]      Ward, B..
               A Soar-Based Intelligent Tutor for Electrostatics.
               Thesis Proposal, School of Computer Science, Carnegie Mellon
                  University, May, 1988.  Unpublished.

[Wiesmeyer 88] Wiesmeyer, M.
               A Computer Implementation of a Model of Visual Perception and
                  Attention.
               Thesis Proposal, Department of Electrical Engineering and
                  Computer Science, University of Michigan, August, 1988.
                  Unpublished.

[Yost 88a]     Yost, G. R.
               Data Chunking in TAQ.
               Computer Science Department, Carnegie Mellon University,
                  November, 1988.  Unpublished.

[Yost 88b]     Yost, G. R.
               TAQ: Soar Task Acquisition System User's Manual.
               Computer Science Department, Carnegie Mellon University, March,
                  1988.  Unpublished.

[Yost 89]      Yost, G.R.
               A Problem Space Tool for Expert System Development.
               Thesis Proposal, School of Computer Science, Carnegie Mellon
                  University, February, 1989.  Unpublished.

[Yost and Altmann 89]
               Yost, G.R. and Altmann, E.
               TAQL 3.0: Soar Task Acquisition Language User Manual.
               School of Computer Science, Carnegie Mellon University,
                  December, 1989.  Unpublished.

[Yost and Altmann 90a]
               Yost, G.R. and Altmann, E.
               TAQL 3.1.1: Soar Task Acquisition Language User Manual.
               School of Computer Science, Carnegie Mellon University, July,
                  1990.  Unpublished.

[Yost and Altmann 90b]
               Yost, G.R. and Altmann, E.
               Transparencies and Handouts for the 7/10 & 7/12 TAQL Tutorial.
               School of Computer Science, Carnegie Mellon University, July,
                  1990.  Unpublished.

[Yost and Milnes 88]
               Yost, G. R. and Milnes, B. G.
               Soar Programs.
               Teaching programs for the June, 1988 Soar class.  Unpublished.

[Yost and Newell 88]
               Yost, G. R. and Newell, A.
               Learning New Tasks in Soar.
               Computer Science Department, Carnegie Mellon University,
                  February, 1988.  Unpublished.

[Yost and Newell 89]
               Yost, G.R. and Newell, A.
               A problem space approach to expert system specification.
               In Proceedings of the Eleventh International Joint Conference on
                  Artificial Intelligence, pages 621-627.  1989.

[Young 89]     Young, R.M.
               Cognitive Architecture for Integrated Models of the User.
               Technical Report PP 93, MRC Applied Psychology Unit,
               March, 1989.

[Young and Simon 86]
               Young, R. M. and Simon, T.
               Soar as an Evidence-Gathering Engine: Final report on matrix
                  exercise for Soar cell(s).
               Pum Project PP 49, MRC Applied Psychology Unit,
               December, 1986.

[Young and Whittington 90a]
               Young, R.M. and Whittington, J.
               Using a knowledge analysis to predict conceptual errors in
                  text-editor usage.
               In Proceedings of the Conference on Human Factors and Computing
                  Systems, pages 91-97.  April, 1990.

[Young and Whittington 90b]
               Young, R. M. and Whittington, J.
               Interim Report on Means-Ends Analysis in SOAR.
               MRC Applied Psychology Unit, Cambridge, England, August 2, 1990.
                  Unpublished.
Index
                                                    General
          <   20                                       I/O   29
          <<   20                                      input   29
          << >>   38                                   input example   30
          <=   20                                      output example   31
          <>   20                                   Get-input-link   30
                                                    Get-output-augmentations
          =   20                                            31
                                                    Get-output-values   31
          >   20                                    Goal   5, 6
          >=   20                                      comparison   6
          >>   20                                      conjunctive   5
                                                       context   9, 19, 58
          *standard-input*   29                        disjunctive   5
          *standard-output*   29                       hierarchy   5
          *chunk-free-problem-spaces*                  meta   5
                  48                                   proposal   6
          *default-user-select*   48                   refinement   6, 41
          *max-chunk-conditions*   48                  result   13
          *max-elaborations*   48                      selection   6
          *mem-array-size*   48                        termination   6, 13, 22
          *pfired*   48                                top-level   5
          *spo-default-depth*   48
          *subgoal-tabs*   48                       Halt   21
          *warning*   48                               with   symbolic   values
          *watch-free-problem-spaces*                       36
                  48
          *max-elaborations*   31                   I-support   10, 14, 20, 43,
                                                            44
          Accept   21, 26                           I/O   26
          Acceptable preference   10,                  general   29
                  11, 19, 42                           structures   29
          Accessibility   23                           text   26
          Action   10, 21, 58                       Identifier   9, 19, 58
             functions   21                            variablization of   23
             linking   21                           Impasse   5, 13, 22, 58
             side   21                                 attribute   13
          Add-input   30                               conflict   13
          All-attributes-at-level                      constraint-failure   13
                  (attribute)   34                     goal no-change   33
          Applied (attribute)   44                     multi-choice   33
          Apply                                        no-change   13, 33
             external operator   15                    object   22
             internal operator   16                    operator no-change   33,
             operator   7, 43                               41
          Atom (value)   28                            resolution   13, 22
          Atom mode   27                               tie   13
          Attribute   9, 19, 58                     Indifferent      preference
             impasse   13, 28, 40                           11, 35, 36
          Augmentation   9, 19, 58                  Init-context   39, 48
                                                    Init-soar   26, 39, 48, 50
          Back-trace (function)   52                Init-task   26, 48, 50
          Backtracing   23, 58                      Init-wm   39, 48
          Best preference    11,  36,               Initial state   5, 6
                  43                                   proposal   6, 7, 15
          Better         higher/lower                  selection   6
                  (augmentation)   35               Initializing Soar   39
          Better preference   11, 42                Input   14
          Bind   21                                    augmentation   29
          Blocks World   5, 37                         cycle   26
             PSCM implementation   7                   example of general   30
             PSCM level   7                            function     declaration
             PSCM search control   7                        29
             PSCM trace   7                            functions   26, 29
             SLCM implementation   14                  general   29
          Bottom-up chunking   23                      interface functions   29
          Break character   28                         link   29, 30
                                                       owner   29
          Call2   21                                   relation to PSCM   6
          Carriage                                     relation to SLCM   9
             control   28                              stream   29
             return   27                               structure   29
          Carriage-control                             structures   29
                  (attribute)   26                     text   27
          Cc (value)   28                           Input and output   26
          Change-input-value   30                   Instantiation
          Change-input-value-and-old                   production   10, 58
                  30                                   support   10
          Char-mode (attribute)   26                Io-state (attribute)   42
          Character mode   27                       Item (attribute)   22, 33
          Chunk   58
          Chunking   23                             Justification   14, 58
             actions   23
             Blocks World   18                                 *chunk-free-prob
             bottom-up   23
             conditions   23, 24                       chunks from   14
             constants   37
             creation   23                          Knowledge
             disjunction, effects  of                  default   33
                  38                                   search control   7
             duplicate chunks   23                     task implementation   6,
             equality tests   37                            7
             generality   37, 43
             justifications   14                    Last-chunk   56
             negated conditions   24                Last-justification   55
             overgeneral   14, 24                   Learn
             overspecific   38                         full-trace   23
             predicates   37                           function   56
             PSCM process   14                         off   23
             refractory    inhibition                  on   23
                  24                                Learning   5, 14, 23
             SLCM process   9                          Blocks World   18
          Class   19, 58                               relation to PSCM   6
          Compare operator    7,  15,               Link   9, 19, 31
                  42                                   chunk action   23
          Compute   21                                 input   29
          Condition   10, 58                           output   29, 31
             acceptable    preference               Linked   58
                  20                                   actions   21
             linking   20                              conditions   10, 20
          Conflict                                     preferences   10
             impasse   11, 13, 58                      working memory   10
             resolution   19                        Lispsyntax   49
          Conjunctive                               List-chunks   56
             conditions   20, 58                    List-justifications   56
             goals   5                              Load   49
             negation   20, 58                      Lookahead   17
          Constant value   9, 19, 37                   search   33, 45
          Constraint-failure   13                      state   17
             default knowledge   33                    state copy   34
             impasse   11, 58
          Context                                   Match-input   30
             impasse   13                           Matcher   9, 24
             object   9, 58                         Matching conditions   10
             slot   9, 19                           Memories   42, 57
             stack   9, 58                          Meta-goals   5, 14
          Copying state   34, 45                    Mini decision cycle   29
          Crlf   21, 27, 28                         Monitoring   36
          Current-input-link                        Ms   40, 44, 53
                  (attribute)   30                  Multi-attribute     19, 22,
                                                            29, 39, 40, 58
          D   41, 49                                Multi-attributes (function)
          Debugging   26                                    57
          Decide-trace   50                         Multi-choice
          Decision                                     impasse   33
             phase   11
             procedure   9, 13                      Necessity  preference   10,
          Default                                           24, 33
             knowledge   14, 33, 58                 Negated
             productions   16, 37, 45                  conditions   20, 23, 24,
          Default-operator-copy                             58
                  (attribute)   35                     conjunctions   20
          Default-state-copy                        New-input-link   29
                  (attribute)   34                  No-change impasse   13, 17,
          Delete-input   30                                 41, 58
          Desirability     preference               Novalue (value)   33, 36
                  10                                Numeric evaluations   35
          Desired   22                              Numeric-value   (attribute)
             object   33, 35                                34
             state   5, 7, 44
          Disjunction  of   constants               O-support   10, 13, 14, 20,
                  20                                        43, 44
          Disjunctive                               Object (attribute)   19
             goals   5                              Object   9, 19, 58
             tests   38                                duplicated   35
          Dont-copy (attribute)   34                Object  nil  (augmentation)
          Duplicated object   35                            39
          Dynamic  information    38,               Object-dynamic (structures)
                  39                                        39, 45
                                                    Object-static  (structures)
          Efficiency   21                                   39
             multi-attributes                       One-level-attributes   45
                  function   57                        attribute   34
             state copying   34                     Op-apps   55
          Elaboration                               Op-apps-undo   55
             cycle   10, 11, 26, 29                 Operator   5
             phase   11                                application     5, 6, 7,
          Encoding a task   37                              10, 20, 33, 43
          Equal       not-indifferent                  comparison   7, 15, 42
                  (augmentation)   35                  copying   35
          Evaluate-object    operator                  external     application
                  33                                        15
             application   34                          instantiation     6, 15,
          Evaluation                                        20, 33
             evaluate-object operator                  internal     application
                  17, 33                                    16
             novalue   36                              no-change impasse   41
             numeric   34                              proposal   6, 7, 15, 42
             object   33, 34                           refinement   6
             subgoal   17, 33, 34                      subgoaling   5, 33, 36
             symbolic   34                             support   10
             type   33                                 termination    6, 7, 16,
          Excise   55                                       44
          Excise-chunks   56                           tie impasse   33
          Excise-task   55                          Operator-selection
          Exclusivity preference   10                       (attribute)   33
          Exhaustion   23, 24                       Output   14, 26, 31
          Expensive chunk   58                         augmentation   29
          External                                     cycle   26
             environment   5                           functions   26, 29, 31
             interaction   26                          general   29
             operator   15                             interface functions   31
                                                       link   29, 31
          Failure                                      mappings   31
             halting Soar   36                         relation to PSCM   6
             value   36                                relation to SLCM   9
          Full-matches   53                            stream   29
          Full-trace   23                              structure   26, 29
          Functional overloading   38                  text   28
          Output structure   26                     Support   43, 58
          Overgeneral chunk   23, 24,               Swm   53
                  58                                Symbol  Level Computational
          Owner   29                                        Model
                                                         See also   SLCM
          Parallel preference     11,               Symbolic evaluations   36
                  19, 40                            Symbolic value
          Parallelism                                  failure   34
             PSCM level   9                            success   34
          Partial-failure     (value)
                  36                                Tab   28
          Partial-success     (value)               Tab settings   28
                  36                                Tab-settings
          Pbreak   49                                  attribute   26, 28
          Permanent memory   9                      Tabstop   21
          Persistence   5                           Tabto (value)   28
          Pfired   54                               Tabto   21, 28
          Pgs   39, 52                              Tally   53
          Pi   54                                   Task encoding   37
          Pm   54                                   Task implementation
          Po   52                                      Blocks  World  knowledge
          Pop-goal   55                                     7, 14
          Ppwm   53                                    knowledge   6, 7
          Predicates   20, 58                          PSCM level   7
             effect on chunking   37                Terminate operator   7, 16
          Preference   9, 10, 19, 53,               Text
                  58                                   input   26, 27
             acceptable   10, 11, 19,                  output   26, 28
                  39, 42                               structures   26
             acceptable  as condition               Text I/O environment   26
                  20                                Text-command link   26
             best   11, 36, 43                      Text-input
             better   11, 42                           attribute   26
             desirability   10                         link   26
             exclusivity   10                          structure   26, 27
             indifferent   11, 35, 36               Text-input-stream
             memory   9, 10                                 (attribute)   26
             necessity   10, 33                     Text-output
             parallel   11, 19, 40                     attribute   26
             phase   11, 26, 40                        link   26
             processing   11                           structure   28
             prohibit   11                          Text-output-stream
             reconsider   11, 16, 44,                       (attribute)   26
                  45                                Tie impasse   13, 17, 45
             reject   10, 11, 19                    Tie-context state   34
             require   10, 11                       Time-function   30
             semantics   11                         Time-tag   40, 58
             support   43, 44                          use with swm   53
             type   19                                 use with wm   53
             worse   11                             Token   21, 58
             worst    11, 16, 36, 40,               Top-goal   39
                  43                                Top-level state   26, 29
          Preferences (function)   43               Top-ps   39
          Print-stats   54, 55                      Top-state   30, 39
          Problem solving   5                       Trace   23
          Problem space   5, 58                        memory   9
             comparison   6                         Trace-attributes   51
             proposal   6, 7, 15, 41                   use   with   user-select
             refinement   6, 41                             49
             top-level   5                          Truth-Maintenance    System
          Problem Space Computational                       10
                  Model                             Two-level-attributes   45
               See also   PSCM                         attribute   34
          Production   9, 10, 19, 58                Type (attribute)   27
             action   10, 21                           atom   28
             condition   10                            cc   28
             instantiation   10, 20                    tabto   28
             naming   37
             systems   19                           Unpbreak   50
          Prohibit preference   11                  Unptrace   51
          Prohibit-failure    (value)               Untrace-attributes   51
                  36                                User-select   33, 49
          Proposal
             initial state    7,  15,               Value   9, 19, 58
                  41                                Value t (augmentation)   34
             operator   7, 15, 42                   Variable   10, 20
             problem  space    7, 15,               Variablization   23
                  41
             task operator   7, 15                  Wait   16, 40
          PSCM   3, 6                               Watch   40, 51
             Blocks World   7                       Wm   40, 53
             Blocks   World    search               Wme-attribute   30
                  control   7                       Wme-class   30
             Blocks World trace   7                 Wme-id   30
             functions   6, 9, 10                   Wme-value   30
             task implementation   7                Working memory   9, 19, 26,
             templates   37                                 29, 58
          Ptrace   50                                  element   9
          Punctuation   27                             elements   19
                                                       phase   26, 40
          Quiescence   11, 22, 26                      trace   9, 23
          Quiescence t (augmentation)               Worse preference   11
                  23, 24, 36                        Worst preference   11,  16,
                                                            36, 43
          Readtable   27                            Write1   21, 26, 28, 40
          Recognition memory   9, 10                Write1+   28
          Reconsider preference   11,               Write2   21, 28
                  16, 44                            Write2+   28
          Refinement   5, 58
             goal   6
             operator   6
             problem space   6, 41
             relation   to  I-support
                  20
             state   6
             state copying   34
          Reject preference   10, 11,
                  19
          Relevance in chunking   23
          Representation
             generality   37
          Require preference   11
          Require-success     (value)
                  36
          Restart-soar   48
          Result   13, 23
          Retraction   10, 20, 44
          Role   19
             subgoal    augmentations
                  22
          Rule-based systems
               See  also   Production
                  systems
          Run   40, 50
          Run-task   26, 39, 50

          Search  control   knowledge
                  7
          Selection   problem   space
                  17, 33, 48
          Set-break-char   27, 28, 56
          Set-carriage-control   56
          Set-carriage-control-mode
                  27
          Set-char-mode   27, 56
          Set-input-functions   56
          Set-learning-choice     49,
                  56
          Set-macro-character     27,
                  56
          Set-output-mappings     31,
                  56
          Set-tab-settings   28, 57
          Set-text-input   27, 57
          Set-text-input-stream   29,
                  57
          Set-text-output   27, 57
          Set-text-output-stream
                  29, 57
          Set-user-select   49
          Single state principle   9
          SLCM   3, 9
             Blocks             World
                  implementation   14
             input   9, 14
             operations   9
             output   9, 14
          Slot   19
          Smake   55
          Smatches   54
          Soar-menu   49
          Soarnews   55
          Soarsyntax   49
          Soarsyntaxp   49
          Sp   55
          Space   28
          Spm   54
          Spo   52
          Sppwm   39, 53
          Spr   40, 41, 53, 54
          Sremove   55
          Start-default   49
          State   5
             copying   45
             proposal   41
             refinement   6
             refinement  and  copying
                  34
             representation   38
             top-level   5
          State copy   34
             augmentations   35
             default   34
             duplicated object   35
             example   35
          Static information   38, 39
          Stop-default   49
          Structures   29
          Subgoal   6,  13,  14,  16,
                  22, 23
             result   13
             termination   13, 22
          Substructure   10
          Success
             halting Soar   36
             value   36
          Supergoal   19, 22, 39
          Superproblem-space   33
          Superstate (attribute)   42
          Superstate   33, 41
Function Summary and Index


Function                  Summary                                    Page
back-trace [I] [G]        Prints a back-trace as though created by chunking.
                          52
d [N]                     Runs Soar for a number of decision cycles. 49
decide-trace [X]          Toggles the tracing of the decision procedure.
                          50
excise P [*]              Removes productions from production memory.
                          55
excise-chunks             Removes all productions created by chunking.
                          56
excise-task               Removes all non-default productions.       55
full-matches P [*]        Prints the most complete instantiation of a
                          production.                                53
init-context [G] [P] [S] [O]                                         Clears
                          working memory and then creates an initial context.
                          48
init-soar                 Empties working memory and re-initializes runtime
                          statistics.                                48
init-task                 A user-defined Lisp function that initializes the
                          task.                                      48
init-wm [X] [*]           Calls init-soar and initializes working memory.
                          48
last-chunk                Prints the last production created by chunking.
                          56
last-justification        Prints the last justification created.     56
learn [A] [*]             Modifies or lists the flags that control chunking.
                          56
lispsyntax                Changes the readtable to use standard Lisp
                          conventions.                               49
list-chunks ["filename"]  Prints all chunks, to a file, if specified.
                          56
list-justifications ["filename"]                                     Prints all
                          justifications, to a file, if specified.   56
load "filename"           Loads a file.                              49
memories [N]              Prints the productions with the largest token
                          memories.                                  57
ms                        Prints the instantiations and retractions in the
                          match set.                                 53
multi-attributes L        Declares multi-attributes to increase match
                          efficiency.                                57
op-apps L                 Declares productions to be operator-application
                          productions.                               55
op-apps-undo L            Undoes the effects of op-apps.             55
pbreak [X] [*]            Sets or lists current break points.        49
pfired [D]                Prints the number of times each production fired.
                          54
pgs                       Prints the goal-context stack.             52
pi P [N]                  Prints a current instantiation of a production.
                          54
pm P [*]                  Prints productions; conditions are reordered by
                          matcher.                                   54
ppwm [X] [*]              Prints augmentations in working memory.    53
po I                      Prints the augmentations for an identifier.
                          52
pop-goal [X]              Removes a goal and all objects supported by it.
                          55
preferences O A           Prints the preferences for a given object and
                          attribute.                                 53
print-stats               Prints a summary of run statistics.        54
ptrace [X] [*]            Turns on tracing of items, or lists all items being
                          traced.                                    50
restart-soar              Empties production and working memory and resets all
                          globals.                                   48
run [N] [X]               Runs Soar for a number of cycles or until a specified
                          break.                                     50
run-task [N]              Calls init-soar, init-task, and d.         50
set-break-char X          Resets the break character when text input is on.
                          56
set-carriage-control X    Sets carriage-control mode for text input. 56
set-char-mode X           Sets character mode for text input.        56
set-input-functions L     Declares the functions to be called in the input
                          cycle.                                     56
set-learning-choice       Prompts user for learning mode.            49
set-macro-character X Y Z R                                          Sets
                          terminating characters for text input.     56
set-output-mappings L     Declares the functions to be called in the output
                          cycle.                                     56
set-text-input X          Turns text input on or off.                57
set-text-input-stream X   Redefines the text-input stream.           57
set-text-output X         Turns text output on or off.               57
set-text-output-stream X  Redefines the text-output stream.          57
set-tab-settings N [*]    Redefines the tab settings used for text output.
                          57
set-user-select           Prompts user for user-select mode.         49
smake X                   Adds preferences to preference memory.     55
smatches P [*]            Prints partial instantiations of productions.
                          54
soar-menu "string" L      Provides a menu for the user.              49
soarnews                  Prints news about the current release.     55
soarsyntax                Changes the readtable to use Soar conventions.
                          49
soarsyntaxp               Returns T if the Soar readtable is being used;
                          otherwise, returns NIL.                    49
sp X                      Creates new productions.                   55
spm P [*]                 Prints productions; conditions are not reordered.
                          54
spo I [* D]               Prints Soar objects in working memory.     52
sppwm [X] [*]             Prints objects in working memory.          53
spr X [*]                 Prints Soar objects or productions.        53
sremove N [*]             Removes augmentations from working memory. 55
start-default             New productions will be considered default
                          productions.                               49
stop-default              New productions will not be considered default
                          productions.                               49
swm N [*]                 Given time-tags, prints objects in working memory.
                          53
tally O A                 Runs a fake decision given object and attribute.
                          53
trace-attributes L        Adds attributes of context objects to the tracing of
                          a run.                                     51
unpbreak [X] [*]          Removes break points.                      50
unptrace [X] [*]          Removes tracing set by unptrace.           51
untrace-attributes L      Removes tracing set by trace-attributes.   51
user-select [X]           Sets or displays the user-select mode.     49
watch [N] [T]             Prints trace information about Soar's run. 51
wm N [*]                  Given time-tags, prints augmentations in working
                          memory.                                    53
                               Table of Contents

Preface                                                                       1

Mailing Lists                                                                 2

1. Introduction                                                               3

   1.1. Overview                                                              3
   1.2. How to read this manual                                               3

2. The Problem Space Level                                                    5

   2.1. Overview                                                              5
   2.2. The Problem Space Computational Model                                 6
   2.3. Encoding a task                                                       7

3. Semantics of the Symbol Level                                              9

   3.1. Overview                                                              9
   3.2. Working memory                                                        9
   3.3. Recognition memory                                                   10
   3.4. Preference memory                                                    10
   3.5. Preference processing                                                11
   3.6. Impasses and subgoals                                                13
   3.7. Learning                                                             14
   3.8. Input and output                                                     14
   3.9. Default knowledge                                                    14
   3.10. Encoding a task                                                     14

4. Syntax of the Symbol Level                                                19

   4.1. Working memory                                                       19
   4.2. Production memory                                                    19
   4.3. Impasses and subgoals                                                22

5. Learning                                                                  23

   5.1. Chunk creation                                                       23
   5.2. Determining conditions and actions                                   23
   5.3. Variablizing identifiers                                             23
   5.4. Ordering conditions                                                  24
   5.5. Refractory inhibition of chunks                                      24
   5.6. Overgeneralization                                                   24

6. Input and Output                                                          26

   6.1. Overview                                                             26
   6.2. Text I/O                                                             26
   6.3. General I/O                                                          29

7. Default Knowledge                                                         33

   7.1. The top context                                                      33
   7.2. Responding to impasses                                               33
   7.3. The selection space for multi-choice impasses                        33
   7.4. Operator subgoaling                                                  36
   7.5. Execution monitoring                                                 36

8. Encoding A Task in Soar                                                   37

   8.1. Task representation                                                  37
   8.2. Initialization                                                       39
   8.3. Proposal of the operator to perform the task                         40
   8.4. Subgoal creation for operator application                            41
   8.5. Problem space proposal for subgoal                                   41
   8.6. Problem space refinement                                             41
   8.7. Proposal of the initial state                                        41
   8.8. Operator proposal                                                    42
   8.9. Operator comparison                                                  42
   8.10. Operator application                                                43
   8.11. Operator termination                                                44
   8.12. Task operator termination                                           44
   8.13. Using lookahead search                                              45

9. Top-Level Variables and Functions                                         48

   9.1. Soar global variables                                                48
   9.2. Initializing Soar                                                    48
   9.3. Setting the initial environment                                      48
   9.4. Loading productions                                                  49
   9.5. Running and breaking Soar                                            49
   9.6. Tracing decisions, productions, and objects                          50
   9.7. Displaying working memory                                            52
   9.8. Displaying preference memory                                         53
   9.9. Displaying production memory                                         53
   9.10. Displaying other information                                        54
   9.11. Changing working memory                                             55
   9.12. Changing preference memory                                          55
   9.13. Changing production memory                                          55
   9.14. Justifications                                                      56
   9.15. Learning                                                            56
   9.16. Input and output                                                    56
   9.17. Increasing and checking efficiency                                  57

I. Glossary of Terms                                                         58

II. Templates for Common PSCM Operations                                     59

References                                                                   61

Index                                                                        67

Function Summary and Index                                                   69
                                List of Figures
   Figure 2-1:   Formulation of simple Blocks World task within a problem     5
                 space.
   Figure 2-2:   Example Blocks World problem and state description.          5
   Figure 2-4:   Blocks World goals decomposed into conjunctive subgoals      5
                 represented in Soar as operators.
   Figure 2-3:   Example impasse in the Blocks World problem.                 5
   Figure 2-5:   Example Blocks World problem.                                7
   Figure 3-1:   The structure of the SLCM components of Soar.                9
   Figure 3-2:   Graphical depiction of the contents of working memory.       9
                 Circles represent identifiers, arcs represent attributes,
                 and squares represent constants.
   Figure 3-3:   An abstract depiction of computing values for the same      10
                 slot.  Values A, B, and C all have acceptable
                 preferences, denoted by "+".  A is better than B, denoted
                 by "A > B".  C is best, denoted by "C >".
   Figure 3-4:   Soar's decision cycle.                                      12
   Figure 3-5:   The creation of a result by a production firing in a        14
                 subgoal and modifying the state shared by the
                 supercontext.
   Figure 6-1:   Details of the elaboration phase of a decision cycle.       26
                 Input functions are called before the match set is
                 determined for the preference phase. Output functions are
                 called after the working memory phase. Input functions
                 are also called before quiescence.
   Figure 6-2:   A sample text-input structure.                              26
   Figure 6-3:   Saving a text structure.                                    27
   Figure 6-4:   The Soar alternate readtable functions.  Each entry         27
                 includes a terminating character and its corresponding
                 Soar readtable function.  Any of these characters may be
                 changed to non-terminating by using the
                 set-macro-character function.
